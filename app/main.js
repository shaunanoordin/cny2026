/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/avo/avo.js":
/*!************************!*\
  !*** ./src/avo/avo.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ AvO)\n/* harmony export */ });\n/* harmony import */ var _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/constants.js */ \"./src/avo/constants.js\");\n/* harmony import */ var _avo_physics_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @avo/physics.js */ \"./src/avo/physics.js\");\n/* harmony import */ var _avo_story_examples_example_story_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @avo/story/examples/example-story.js */ \"./src/avo/story/examples/example-story.js\");\n/* harmony import */ var _avo_interaction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @avo/interaction */ \"./src/avo/interaction/index.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n // TODO: remove, or replace with a simpler version\n\nvar searchParams = new URLSearchParams(window.location.search);\nvar DEBUG = searchParams.get('debug') || false;\nvar AvO = /*#__PURE__*/function () {\n  function AvO() {\n    var _this$story;\n    var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classCallCheck(this, AvO);\n    var _args$story = args.story,\n      story = _args$story === void 0 ? _avo_story_examples_example_story_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"] : _args$story,\n      _args$width = args.width,\n      width = _args$width === void 0 ? 24 * _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE : _args$width,\n      _args$height = args.height,\n      height = _args$height === void 0 ? 16 * _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE : _args$height;\n    this.html = {\n      main: document.getElementById('main'),\n      canvas: document.getElementById('canvas'),\n      homeMenu: document.getElementById('home-menu'),\n      interactionMenu: document.getElementById('interaction-menu'),\n      buttonHome: document.getElementById('button-home'),\n      buttonFullscreen: document.getElementById('button-fullscreen'),\n      buttonReload: document.getElementById('button-reload')\n    };\n    this.homeMenu = false;\n    this.setHomeMenu(false);\n    this.interactionMenu = false;\n    this.setInteractionMenu(false);\n    this.canvas2d = this.html.canvas.getContext('2d');\n    this.canvasWidth = width;\n    this.canvasHeight = height;\n    this._canvasHasCameraTransforms = false; // Safety check\n\n    this.camera = {\n      target: null,\n      // Target entity to follow. If null, camera is static.\n      x: 0,\n      y: 0,\n      zoom: 1\n    };\n    this.setupUI();\n    this.entities = []; // Game objects\n    this.hero = null; // Main player-controlled entity\n    this.gameMap = {\n      // Game map and environment\n      tiles: [],\n      // 2D array of map tiles\n      width: 0,\n      height: 0\n    };\n    this.rules = new Map(); // Game rules, including win/loss conditions and player controls\n\n    this.story = story ? new story(this) : undefined; // Game story, i.e. the \"container\" that describes an adventure or experience, which contains game objects and game rules and etc\n    this.assets = ((_this$story = this.story) === null || _this$story === void 0 ? void 0 : _this$story.assets) || {};\n    this.secretAssets = {};\n    this.eventListeners = {\n      'keydown': [],\n      'keyup': [],\n      'pointerdown': [],\n      'pointermove': [],\n      'pointerup': [],\n      'pointertap': [],\n      'pointerholdend': []\n    };\n    this.playerInput = {};\n    this.resetPlayerInput();\n    this.initialised = false;\n    this.timeAccumulator = 0;\n    this.prevTime = null;\n    this.nextFrame = window.requestAnimationFrame(this.main.bind(this));\n  }\n  return _createClass(AvO, [{\n    key: \"initialisationCheck\",\n    value: function initialisationCheck() {\n      var _this = this;\n      // Assets check\n      var allAssetsReady = true;\n      var numReadyAssets = 0;\n      var numTotalAssets = 0;\n      Object.keys(this.assets).forEach(function (id) {\n        var asset = _this.assets[id];\n        allAssetsReady = allAssetsReady && asset.ready;\n        if (asset.ready) numReadyAssets++;\n        numTotalAssets++;\n      });\n      Object.keys(this.secretAssets).forEach(function (id) {\n        var secretAsset = _this.secretAssets[id];\n        var secretAssetIsReady = secretAsset.ready || secretAsset.error;\n        allAssetsReady = allAssetsReady && secretAssetIsReady;\n        if (secretAssetIsReady) numReadyAssets++;\n        numTotalAssets++;\n      });\n\n      // Paint status\n      this.canvas2d.clearRect(0, 0, this.canvasWidth, this.canvasHeight);\n      this.canvas2d.textAlign = 'start';\n      this.canvas2d.textBaseline = 'top';\n      this.canvas2d.fillStyle = '#ccc';\n      this.canvas2d.font = \"1em monospace\";\n      this.canvas2d.fillText(\"Loading \".concat(numReadyAssets, \" / \").concat(numTotalAssets, \" \"), _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE, _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE);\n      if (allAssetsReady) {\n        var _this$story2;\n        // Clean up secret assets\n        Object.keys(this.secretAssets).forEach(function (id) {\n          if (_this.secretAssets[id].error) delete _this.secretAssets[id];\n        });\n\n        // Let's go!\n        this.initialised = true;\n        this.showUI();\n        (_this$story2 = this.story) === null || _this$story2 === void 0 || _this$story2.start();\n      }\n    }\n\n    /*\r\n    Section: General Logic\r\n    ----------------------------------------------------------------------------\r\n     */\n\n    /*\r\n    The main loop. Run a single frame of gameplay.\r\n    - time: the current/total time (milliseconds) since the game started.\r\n     */\n  }, {\n    key: \"main\",\n    value: function main(time) {\n      var timeStep = this.prevTime ? time - this.prevTime : time;\n      this.prevTime = time;\n      this.timeAccumulator += timeStep;\n\n      // Sanity/safety check: timeStep can be huge\n      // e.g. if player pauses game by switching windows.\n      this.timeAccumulator = Math.min(this.timeAccumulator, _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.FRAME_DURATION * 10);\n      if (this.initialised) {\n        // Keep a consistent \"frame rate\" for logic processing\n        while (this.timeAccumulator >= _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.FRAME_DURATION) {\n          this.play();\n          this.timeAccumulator -= _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.FRAME_DURATION;\n          // TODO: add safety counter to prevent excessively long while() loops.\n        }\n        // Paint whenever possible\n        this.paint();\n      } else {\n        this.initialisationCheck();\n      }\n      this.nextFrame = window.requestAnimationFrame(this.main.bind(this));\n    }\n\n    /*\r\n    Run the gameplay/physics logic for a single frame.\r\n     */\n  }, {\n    key: \"play\",\n    value: function play() {\n      var _this2 = this;\n      // If a menu is open, pause all action gameplay\n      if (this.homeMenu || this.interactionMenu) return;\n\n      // Run the action gameplay\n      // ----------------\n      this.rules.forEach(function (rule) {\n        return rule.play();\n      });\n      this.entities.forEach(function (entity) {\n        return entity.play();\n      });\n      this.checkCollisions();\n\n      // Cleanup: entities\n      this.entities.filter(function (entity) {\n        return entity._expired;\n      }).forEach(function (entity) {\n        return entity.deconstructor();\n      });\n      this.entities = this.entities.filter(function (entity) {\n        return !entity._expired;\n      });\n\n      // Cleanup: rules\n      this.rules.forEach(function (rule, id) {\n        if (rule.expired) {\n          rule.deconstructor();\n          _this2.rules[\"delete\"](id);\n        }\n      });\n\n      // Sort Entities along the y-axis, for paint()/rendering purposes.\n      // WARNING: inefficient\n      this.entities.sort(function (a, b) {\n        return a.y - b.y;\n      });\n      // ----------------\n\n      // Increment the duration of each currently pressed key\n      Object.keys(this.playerInput.keysPressed).forEach(function (key) {\n        if (_this2.playerInput.keysPressed[key]) _this2.playerInput.keysPressed[key].duration += _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.FRAME_DURATION;\n      });\n\n      // Increment the duration of the pointer being active\n      if (this.playerInput.pointerState === _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.POINTER_STATES.POINTER_DOWN) {\n        this.playerInput.pointerDownDuration += _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.FRAME_DURATION;\n      }\n    }\n\n    /*\r\n    Paint/draw the game visuals onto the canvas.\r\n     */\n  }, {\n    key: \"paint\",\n    value: function paint() {\n      var _this3 = this;\n      var c2d = this.canvas2d;\n      var camera = this.camera;\n\n      // Camera Controls: focus the camera on the target entity, if any.\n      // ----------------\n      if (camera.target) {\n        camera.x = this.canvasWidth / 2 - camera.target.x * camera.zoom;\n        camera.y = this.canvasHeight / 2 - camera.target.y * camera.zoom;\n      }\n      c2d.clearRect(0, 0, this.canvasWidth, this.canvasHeight);\n      c2d.resetTransform();\n      c2d.strokeStyle = 'rgba(128, 128, 128, 0.05)';\n      c2d.lineWidth = 2;\n      // ----------------\n\n      // Draw background grid\n      // ----------------\n      var GRID_SIZE = _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE * camera.zoom;\n      var offsetX = this.camera.x % GRID_SIZE - GRID_SIZE;\n      var offsetY = this.camera.y % GRID_SIZE - GRID_SIZE;\n      for (var y = offsetY; y < this.canvasHeight; y += GRID_SIZE) {\n        for (var x = offsetX; x < this.canvasWidth; x += GRID_SIZE) {\n          c2d.beginPath();\n          c2d.rect(x, y, GRID_SIZE, GRID_SIZE);\n          c2d.stroke();\n\n          // Debug Grid\n          if (DEBUG) {\n            c2d.fillStyle = '#ccc';\n            c2d.font = \"\".concat(camera.zoom * 0.5, \"em Source Code Pro\");\n            c2d.textAlign = 'center';\n            c2d.textBaseline = 'middle';\n            var col = Math.floor((x - this.camera.x) / GRID_SIZE);\n            var row = Math.floor((y - this.camera.y) / GRID_SIZE);\n            c2d.fillText(col + ',' + row, x + GRID_SIZE / 2, y + GRID_SIZE / 2); // using template strings here messes up colours in Brackets.\n          }\n        }\n      }\n      // ----------------\n\n      // Draw map tiles, entities, and other elements\n      // ----------------\n      var _loop = function _loop(layer) {\n        // 1. draw map tiles first, as these form the background. \n        for (var _row = 0; _row < _this3.gameMap.height; _row++) {\n          for (var _col = 0; _col < _this3.gameMap.width; _col++) {\n            var _this3$gameMap$tiles;\n            (_this3$gameMap$tiles = _this3.gameMap.tiles) === null || _this3$gameMap$tiles === void 0 || (_this3$gameMap$tiles = _this3$gameMap$tiles[_row]) === null || _this3$gameMap$tiles === void 0 || (_this3$gameMap$tiles = _this3$gameMap$tiles[_col]) === null || _this3$gameMap$tiles === void 0 || _this3$gameMap$tiles.paint(layer);\n          }\n        }\n\n        // 2. draw entities next.\n        _this3.entities.forEach(function (entity) {\n          return entity.paint(layer);\n        });\n\n        // 3. draw rules last, as these usually represent HUD visualisations.\n        _this3.rules.forEach(function (rule) {\n          return rule.paint(layer);\n        });\n      };\n      for (var layer = _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.MIN_LAYER; layer <= _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.MAX_LAYER; layer++) {\n        _loop(layer);\n      }\n      // ----------------\n    }\n\n    /*\r\n    Section: UI\r\n    ----------------------------------------------------------------------------\r\n     */\n  }, {\n    key: \"setupUI\",\n    value: function setupUI() {\n      this.html.canvas.width = this.canvasWidth;\n      this.html.canvas.height = this.canvasHeight;\n      this.canvas2d.imageSmoothingEnabled = false; /* Pixel art: Maintains sprites' pixel sharpness when scaled up via drawImage() */\n\n      if (window.PointerEvent) {\n        this.html.canvas.addEventListener('pointerdown', this.onPointerDown.bind(this));\n        this.html.canvas.addEventListener('pointermove', this.onPointerMove.bind(this));\n        this.html.canvas.addEventListener('pointerup', this.onPointerUp.bind(this));\n        this.html.canvas.addEventListener('pointercancel', this.onPointerUp.bind(this));\n      } else {\n        this.html.canvas.addEventListener('mousedown', this.onPointerDown.bind(this));\n        this.html.canvas.addEventListener('mousemove', this.onPointerMove.bind(this));\n        this.html.canvas.addEventListener('mouseup', this.onPointerUp.bind(this));\n      }\n\n      // Prevent \"touch and hold to open context menu\" menu on touchscreens.\n      this.html.canvas.addEventListener('touchstart', stopEvent);\n      this.html.canvas.addEventListener('touchmove', stopEvent);\n      this.html.canvas.addEventListener('touchend', stopEvent);\n      this.html.canvas.addEventListener('touchcancel', stopEvent);\n      this.html.buttonHome.addEventListener('click', this.buttonHome_onClick.bind(this));\n      this.html.buttonFullscreen.addEventListener('click', this.buttonFullscreen_onClick.bind(this));\n      this.html.buttonReload.addEventListener('click', this.buttonReload_onClick.bind(this));\n      this.html.main.addEventListener('keydown', this.onKeyDown.bind(this));\n      this.html.main.addEventListener('keyup', this.onKeyUp.bind(this));\n      window.addEventListener('resize', this.updateUI.bind(this));\n      this.updateUI();\n      this.hideUI(); // Hide until all assets are ready\n\n      this.html.main.focus();\n    }\n  }, {\n    key: \"hideUI\",\n    value: function hideUI() {\n      this.html.buttonHome.style.visibility = 'hidden';\n      this.html.buttonReload.style.visibility = 'hidden';\n    }\n  }, {\n    key: \"showUI\",\n    value: function showUI() {\n      this.html.buttonHome.style.visibility = 'visible';\n      this.html.buttonReload.style.visibility = 'visible';\n    }\n  }, {\n    key: \"updateUI\",\n    value: function updateUI() {\n      // Fit the interaction layers (menus, etc) to the canvas\n      var mainDivBounds = this.html.main.getBoundingClientRect();\n      var canvasBounds = this.html.canvas.getBoundingClientRect();\n      this.html.homeMenu.style.width = \"\".concat(canvasBounds.width, \"px\");\n      this.html.homeMenu.style.height = \"\".concat(canvasBounds.height, \"px\");\n      this.html.homeMenu.style.top = \"\".concat(canvasBounds.top - mainDivBounds.top, \"px\");\n      this.html.homeMenu.style.left = \"\".concat(canvasBounds.left, \"px\");\n      this.html.interactionMenu.style.width = \"\".concat(canvasBounds.width, \"px\");\n      this.html.interactionMenu.style.height = \"\".concat(canvasBounds.height, \"px\");\n      this.html.interactionMenu.style.top = \"\".concat(canvasBounds.top - mainDivBounds.top, \"px\");\n      this.html.interactionMenu.style.left = \"\".concat(canvasBounds.left, \"px\");\n    }\n  }, {\n    key: \"setHomeMenu\",\n    value: function setHomeMenu(homeMenu) {\n      this.homeMenu = homeMenu;\n      if (homeMenu) {\n        this.html.homeMenu.style.visibility = 'visible';\n        this.html.buttonReload.style.visibility = 'hidden';\n      } else {\n        this.html.homeMenu.style.visibility = 'hidden';\n        this.html.buttonReload.style.visibility = 'visible';\n        this.html.main.focus();\n      }\n    }\n  }, {\n    key: \"setInteractionMenu\",\n    value: function setInteractionMenu(interactionMenu) {\n      var div = this.html.interactionMenu;\n      this.interactionMenu && this.interactionMenu.unload(); // Unload the old menu, if any\n      this.interactionMenu = interactionMenu; // Set the new menu\n\n      if (interactionMenu) {\n        while (div.firstChild) {\n          div.removeChild(div.firstChild);\n        } // Clear div\n        interactionMenu.load(div); // load the new menu\n        div.style.visibility = 'visible';\n      } else {\n        div.style.visibility = 'hidden';\n        this.html.main.focus();\n      }\n    }\n\n    /*\r\n    Section: Event Handling\r\n    ----------------------------------------------------------------------------\r\n     */\n  }, {\n    key: \"addEventListener\",\n    value: function addEventListener(eventName, listener) {\n      var _this$eventListeners;\n      (_this$eventListeners = this.eventListeners) === null || _this$eventListeners === void 0 || (_this$eventListeners = _this$eventListeners[eventName]) === null || _this$eventListeners === void 0 || _this$eventListeners.push(listener);\n    }\n  }, {\n    key: \"removeEventListener\",\n    value: function removeEventListener(eventName, listener) {\n      var _this$eventListeners2, _this$eventListeners3;\n      if (!((_this$eventListeners2 = this.eventListeners) !== null && _this$eventListeners2 !== void 0 && _this$eventListeners2[eventName])) return;\n      this.eventListeners[eventName] = (_this$eventListeners3 = this.eventListeners) === null || _this$eventListeners3 === void 0 ? void 0 : _this$eventListeners3[eventName].filter(function (l) {\n        return l !== listener;\n      });\n    }\n  }, {\n    key: \"broadcastEvent\",\n    value: function broadcastEvent(eventName, args) {\n      var _this$eventListeners4;\n      (_this$eventListeners4 = this.eventListeners) === null || _this$eventListeners4 === void 0 || (_this$eventListeners4 = _this$eventListeners4[eventName]) === null || _this$eventListeners4 === void 0 || _this$eventListeners4.forEach(function (eventHandler) {\n        eventHandler(args);\n      });\n    }\n  }, {\n    key: \"onPointerDown\",\n    value: function onPointerDown(e) {\n      var coords = getEventCoords(e, this.html.canvas);\n\n      // Initialise\n      this.playerInput.pointerState = _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.POINTER_STATES.POINTER_DOWN;\n      this.playerInput.pointerStart = coords;\n      this.playerInput.pointerCurrent = coords;\n      this.playerInput.pointerEnd = undefined;\n      this.playerInput.pointerTapOrHold = true;\n      this.playerInput.pointerDownDuration = 0;\n      this.html.main.focus();\n      this.broadcastEvent('pointerdown', {\n        coords: coords\n      });\n      return stopEvent(e);\n    }\n  }, {\n    key: \"onPointerMove\",\n    value: function onPointerMove(e) {\n      var coords = getEventCoords(e, this.html.canvas);\n      this.playerInput.pointerCurrent = coords;\n\n      // If the pointer never moves far from the initial position, then the\n      // pointer interaction is considered a tap or hold.\n      if (this.playerInput.pointerState === _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.POINTER_STATES.POINTER_DOWN && this.playerInput.pointerTapOrHold) {\n        var distX = this.playerInput.pointerCurrent.x - this.playerInput.pointerStart.x;\n        var distY = this.playerInput.pointerCurrent.y - this.playerInput.pointerStart.y;\n        var pointerDistance = Math.sqrt(distX * distX + distY * distY);\n        if (pointerDistance > _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.POINTER_DEADZONE_RADIUS) {\n          this.playerInput.pointerTapOrHold = false;\n        }\n      }\n      this.broadcastEvent('pointermove', {\n        coords: coords\n      });\n      return stopEvent(e);\n    }\n  }, {\n    key: \"onPointerUp\",\n    value: function onPointerUp(e) {\n      var coords = getEventCoords(e, this.html.canvas);\n      if (this.playerInput.pointerState === _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.POINTER_STATES.POINTER_DOWN) {\n        this.playerInput.pointerEnd = coords;\n        this.playerInput.pointerState = _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.POINTER_STATES.IDLE;\n\n        // Is the pointer action a tap or hold action?\n        if (this.playerInput.pointerTapOrHold) {\n          if (this.playerInput.pointerDownDuration <= _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.POINTER_TAP_DURATION) {\n            this.broadcastEvent('pointertap', {\n              coords: coords\n            });\n          } else {\n            this.broadcastEvent('pointerholdend', {\n              coords: coords,\n              duration: this.playerInput.pointerDownDuration\n            });\n          }\n        }\n      }\n      this.broadcastEvent('pointerup', {\n        coords: coords\n      });\n      return stopEvent(e);\n    }\n  }, {\n    key: \"onKeyDown\",\n    value: function onKeyDown(e) {\n      // Special cases\n      switch (e.key) {\n        // Open home menu\n        case 'Escape':\n          this.setHomeMenu(!this.homeMenu);\n          break;\n\n        // DEBUG\n        case 'x':\n        case 'X':\n          if (!this.interactionMenu) {\n            this.setInteractionMenu(new _avo_interaction__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this));\n          }\n          break;\n        case '-':\n        case '_':\n          this.camera.zoom = Math.max(0.5, this.camera.zoom - 0.5);\n          break;\n        case '+':\n        case '=':\n          this.camera.zoom = Math.min(4, this.camera.zoom + 0.5);\n          break;\n      }\n\n      // General input\n      if (!this.playerInput.keysPressed[e.key]) {\n        this.playerInput.keysPressed[e.key] = {\n          duration: 0,\n          acknowledged: false\n        };\n      }\n      this.broadcastEvent('keydown', {\n        key: e.key\n      });\n    }\n  }, {\n    key: \"onKeyUp\",\n    value: function onKeyUp(e) {\n      var _this$playerInput$key;\n      var duration = ((_this$playerInput$key = this.playerInput.keysPressed[e.key]) === null || _this$playerInput$key === void 0 ? void 0 : _this$playerInput$key.duration) || 0;\n      this.playerInput.keysPressed[e.key] = undefined;\n      this.broadcastEvent('keyup', {\n        key: e.key,\n        duration: duration\n      });\n    }\n  }, {\n    key: \"buttonHome_onClick\",\n    value: function buttonHome_onClick() {\n      this.setHomeMenu(!this.homeMenu);\n    }\n  }, {\n    key: \"buttonFullscreen_onClick\",\n    value: function buttonFullscreen_onClick() {\n      var _this4 = this;\n      var isFullscreen = document.fullscreenElement;\n      if (!isFullscreen) {\n        if (this.html.main.requestFullscreen) {\n          this.html.main.requestFullscreen().then(function () {\n            _this4.html.main.className = 'fullscreen';\n            _this4.updateUI();\n          })[\"catch\"](function (err) {\n            console.error('requestFullscreen() error: ', err);\n          });\n        }\n      } else {\n        var _document$exitFullscr, _document;\n        (_document$exitFullscr = (_document = document).exitFullscreen) === null || _document$exitFullscr === void 0 || _document$exitFullscr.call(_document).then(function () {\n          _this4.html.main.className = '';\n          _this4.updateUI();\n        })[\"catch\"](function (err) {\n          console.error('exitFullscreen() error: ', err);\n        });\n      }\n    }\n  }, {\n    key: \"buttonReload_onClick\",\n    value: function buttonReload_onClick() {\n      var _this$story3;\n      (_this$story3 = this.story) === null || _this$story3 === void 0 || _this$story3.reload();\n    }\n\n    /*\r\n    Section: Gameplay\r\n    ----------------------------------------------------------------------------\r\n     */\n  }, {\n    key: \"addEntity\",\n    value: function addEntity(entity) {\n      if (!entity) return null;\n      if (!this.entities.includes(entity)) this.entities.push(entity);\n      return entity;\n    }\n  }, {\n    key: \"removeEntity\",\n    value: function removeEntity(entityOrMatchingFn) {\n      if (!entityOrMatchingFn) return;\n      if (typeof entityOrMatchingFn === 'function') {\n        this.entities.filter(entityOrMatchingFn).forEach(function (entity) {\n          entity._expired = true;\n        });\n      } else if (this.entities.includes(entityOrMatchingFn)) {\n        entityOrMatchingFn._expired = true;\n      }\n    }\n  }, {\n    key: \"clearEntities\",\n    value: function clearEntities() {\n      this.entities.forEach(function (entity) {\n        return entity.deconstructor();\n      });\n      this.entities = [];\n    }\n  }, {\n    key: \"resetGameMap\",\n    value: function resetGameMap() {\n      // TODO: do tiles need to be deconstructed?\n      this.gameMap = {\n        // Game map and environment\n        tiles: [],\n        // 2D array of map tiles\n        width: 0,\n        height: 0\n      };\n    }\n  }, {\n    key: \"addRule\",\n    value: function addRule(rule) {\n      if (!rule) return;\n      var id = rule._type;\n      this.rules.set(id, rule);\n    }\n  }, {\n    key: \"clearRules\",\n    value: function clearRules() {\n      var _this5 = this;\n      this.rules.forEach(function (rule, id) {\n        rule.deconstructor();\n        _this5.rules[\"delete\"](id);\n      });\n    }\n  }, {\n    key: \"resetCamera\",\n    value: function resetCamera() {\n      this.camera = {\n        target: null,\n        x: 0,\n        y: 0,\n        zoom: 1\n      };\n    }\n\n    /*\r\n    Section: Painting\r\n    ----------------------------------------------------------------------------\r\n     */\n\n    /*\r\n    Applies camera transforms to the canvas.\r\n    Should be run right before drawing an Entity (or etc) so the object is drawn\r\n    relative to the camera's view.\r\n     */\n  }, {\n    key: \"applyCameraTransforms\",\n    value: function applyCameraTransforms() {\n      if (this._canvasHasCameraTransforms) throw new Error('Canvas already has camera transforms.');\n      this._canvasHasCameraTransforms = true;\n      var c2d = this.canvas2d;\n      var camera = this.camera;\n      c2d.save();\n      c2d.translate(camera.x, camera.y);\n      c2d.scale(camera.zoom, camera.zoom);\n    }\n\n    /*\r\n    Removes camera transforms from the canvas.\r\n     */\n  }, {\n    key: \"undoCameraTransforms\",\n    value: function undoCameraTransforms() {\n      if (!this._canvasHasCameraTransforms) throw new Error('Canvas doesn\\'t have camera transforms.');\n      this._canvasHasCameraTransforms = false;\n      this.canvas2d.restore();\n    }\n\n    /*\r\n    Section: Misc\r\n    ----------------------------------------------------------------------------\r\n     */\n  }, {\n    key: \"checkCollisions\",\n    value: function checkCollisions() {\n      for (var a = 0; a < this.entities.length; a++) {\n        var entityA = this.entities[a];\n        for (var b = a + 1; b < this.entities.length; b++) {\n          var entityB = this.entities[b];\n          var collisionCorrection = _avo_physics_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].checkCollision(entityA, entityB);\n          if (collisionCorrection) {\n            entityA.onCollision(entityB, collisionCorrection.a);\n            entityB.onCollision(entityA, collisionCorrection.b);\n          }\n        }\n        var range = Math.ceil(entityA.size / _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE);\n        for (var row = entityA.row - range; row <= entityA.row + range; row++) {\n          for (var col = entityA.col - range; col <= entityA.col + range; col++) {\n            var _this$gameMap$tiles;\n            var tile = (_this$gameMap$tiles = this.gameMap.tiles) === null || _this$gameMap$tiles === void 0 || (_this$gameMap$tiles = _this$gameMap$tiles[row]) === null || _this$gameMap$tiles === void 0 ? void 0 : _this$gameMap$tiles[col];\n            var _collisionCorrection = _avo_physics_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].checkCollision(entityA, tile);\n            if (_collisionCorrection) {\n              entityA.onCollision(tile, _collisionCorrection.a);\n              tile.onCollision(entityA, _collisionCorrection.b);\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: \"resetPlayerInput\",\n    value: function resetPlayerInput() {\n      this.playerInput = {\n        // Pointer (mouse/touchscreen) input\n        // pointerStart/pointerCurrent/pointerEnd = { x, y } \n        pointerState: _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.POINTER_STATES.IDLE,\n        pointerStart: undefined,\n        pointerCurrent: undefined,\n        pointerEnd: undefined,\n        // Pointer metadata\n        pointerTapOrHold: true,\n        // A pointer interaction is a tap or hold if the pointer never travels far from its initial position (i.e. never left the deadzone).\n        pointerDownDuration: 0,\n        // Keyboard input\n        // keysPressed = { key: { duration, acknowledged } }\n        keysPressed: {}\n      };\n    }\n  }]);\n}();\n\nfunction getEventCoords(event, element) {\n  var xRatio = element.width && element.offsetWidth ? element.width / element.offsetWidth : 1;\n  var yRatio = element.height && element.offsetHeight ? element.height / element.offsetHeight : 1;\n  var x = event.offsetX * xRatio;\n  var y = event.offsetY * yRatio;\n  return {\n    x: x,\n    y: y\n  };\n}\nfunction stopEvent(e) {\n  if (!e) return false;\n  e.preventDefault && e.preventDefault();\n  e.stopPropagation && e.stopPropagation();\n  e.returnValue = false;\n  e.cancelBubble = true;\n  return false;\n}\n\n//# sourceURL=webpack://cny2026/./src/avo/avo.js?");

/***/ }),

/***/ "./src/avo/constants.js":
/*!******************************!*\
  !*** ./src/avo/constants.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DIRECTIONS: () => (/* binding */ DIRECTIONS),\n/* harmony export */   FRAMES_PER_SECOND: () => (/* binding */ FRAMES_PER_SECOND),\n/* harmony export */   FRAME_DURATION: () => (/* binding */ FRAME_DURATION),\n/* harmony export */   LAYERS: () => (/* binding */ LAYERS),\n/* harmony export */   MAX_LAYER: () => (/* binding */ MAX_LAYER),\n/* harmony export */   MIN_LAYER: () => (/* binding */ MIN_LAYER),\n/* harmony export */   POINTER_DEADZONE_RADIUS: () => (/* binding */ POINTER_DEADZONE_RADIUS),\n/* harmony export */   POINTER_STATES: () => (/* binding */ POINTER_STATES),\n/* harmony export */   POINTER_TAP_DURATION: () => (/* binding */ POINTER_TAP_DURATION),\n/* harmony export */   ROTATIONS: () => (/* binding */ ROTATIONS),\n/* harmony export */   SHAPES: () => (/* binding */ SHAPES),\n/* harmony export */   TILE_ADJACENCIES: () => (/* binding */ TILE_ADJACENCIES),\n/* harmony export */   TILE_SIZE: () => (/* binding */ TILE_SIZE)\n/* harmony export */ });\n/*\r\nSection: General\r\n--------------------------------------------------------------------------------\r\n */\n\n/*\r\nAs a sprite-based game engine, we think of in-game space in terms of \"tiles\" (or\r\n\"map tiles\"). Each map tile is 32x32 pixels, and standard in-game objects should\r\nmore or less fit exactly one map tile.  \r\n */\nvar TILE_SIZE = 32;\n\n/*\r\nWe use a constant frame rate to make calculations in our game logic much easier.\r\ne.g. we can say that we expect an object with \"movement speed\" of \"2\" to travel\r\n120 pixels in 1 second. (2 pixels per frame * 60 frames per second)\r\n */\nvar FRAMES_PER_SECOND = 60;\nvar FRAME_DURATION = 1000 / FRAMES_PER_SECOND;\n\n/*\r\nSection: In-Game Objects\r\n--------------------------------------------------------------------------------\r\n */\n\n/*\r\nEach Entity has a physical shape.\r\n */\nvar SHAPES = {\n  NONE: 'none',\n  CIRCLE: 'circle',\n  SQUARE: 'square',\n  POLYGON: 'polygon'\n};\n\n/*\r\nEach Entity has a directional orientation, which can be interpreted as either\r\n\"rotation\" (if we want to know the precise angle for physics calculations) or\r\n\"direction\" (if we want to match it with up/down/left/right-facing sprites).\r\n */\nvar ROTATIONS = {\n  EAST: 0,\n  SOUTHEAST: Math.PI * 0.25,\n  SOUTH: Math.PI * 0.5,\n  SOUTHWEST: Math.PI * 0.75,\n  WEST: Math.PI,\n  NORTHWEST: Math.PI * -0.75,\n  NORTH: Math.PI * -0.5,\n  NORTHEAST: Math.PI * -0.25\n};\nvar DIRECTIONS = {\n  EAST: 0,\n  SOUTH: 1,\n  WEST: 2,\n  NORTH: 3\n};\n\n/*\r\nMap Tiles care about its cardinal neighbours. More specifically, they care about\r\nthe combination of the presence of neighbours. For example, if a \"brick wall\"\r\ntile has another brick wall to the north and another to the south, we can\r\nexpress this with the value 5 (= 1 + 4 = NORTH + SOUTH). \r\n */\nvar TILE_ADJACENCIES = {\n  NORTH: 1,\n  EAST: 2,\n  SOUTH: 4,\n  WEST: 8\n};\n\n/*\r\nSection: User Input\r\n--------------------------------------------------------------------------------\r\n */\n\n/*\r\nPointer (mouse or touch) input.\r\n */\nvar POINTER_STATES = {\n  IDLE: 'idle',\n  // Player isn't doing anything\n  POINTER_DOWN: 'pointer down' // Player is actively interacting with the canvas.\n};\n\n// Distance from its starting position that the pointer has to move, before a\n// 'move' command is issued.\nvar POINTER_DEADZONE_RADIUS = 16;\n\n// If the pointer is down and then released after a short time, it's a tap\n// action. Otherwise, it's a hold action.\nvar POINTER_TAP_DURATION = 300;\n\n/*\r\nSection: Painting\r\n--------------------------------------------------------------------------------\r\n */\n\n/*\r\nThe paint() step (of the core engine, each Entity, and each Rule) can paint\r\ninformation in different visual layers.\r\n */\nvar LAYERS = {\n  BOTTOM: 1,\n  MIDDLE: 2,\n  // Main object layer.\n  TOP: 3,\n  OVERLAY: 4\n};\nvar MIN_LAYER = 1;\nvar MAX_LAYER = 4;\n\n//# sourceURL=webpack://cny2026/./src/avo/constants.js?");

/***/ }),

/***/ "./src/avo/entity/entity.js":
/*!**********************************!*\
  !*** ./src/avo/entity/entity.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Entity)\n/* harmony export */ });\n/* harmony import */ var _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/constants.js */ \"./src/avo/constants.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n// Default physics config\n// Adjust to whatever \"feels\" right.\nvar MOVE_MAX_SPEED = 4;\nvar PUSH_MAX_SPEED = 32;\nvar MOVE_ACCELERATION = 0.4;\nvar MOVE_DECELERATION = 0.4;\nvar PUSH_DECELERATION = 0.4;\nvar GRAVITY = -0.4;\n\n// Default visuals config\nvar PAINT_HITBOX_MASS_TO_LINEWIDTH_FACTOR = 0.2;\nvar Entity = /*#__PURE__*/function () {\n  function Entity(app) {\n    _classCallCheck(this, Entity);\n    this._app = app;\n    this._type = 'entity';\n    this.name = ''; // Optional identifier.\n\n    // General entity attributes\n    this.colour = '#c0c0c0';\n    this.flying = false; // If flying, z position isn't affected by gravity.\n\n    // Expired entities are removed at the end of the cycle.\n    this._expired = false;\n\n    // Positional data\n    this.x = 0;\n    this.y = 0;\n    this.z = 0; // Pseudo position on z-axis. Doesn't affect collision. If 0, entity's \"feet\" are touching the ground.\n    this.size = _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE;\n    this._rotation = _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.ROTATIONS.SOUTH; // Rotation in radians.\n    this.shape = _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.SHAPES.CIRCLE;\n    this.shapePolygonPath = null; // Only applicable if shape === SHAPES.POLYGON.\n\n    // Physics (movement): self locomotion and external (pushed) movement\n    this.moveX = 0;\n    this.moveY = 0;\n    this.pushX = 0;\n    this.pushY = 0;\n\n    // Additional physics\n    this.solid = true; // If solid, then can interact with other solid physics entities.\n    this.movable = true; // If movable, then can be moved by external forces, e.g. by being pushed by another solid entity.\n    this.mass = 10; // Only matters if solid && movable.\n\n    // Additional \"dynamic\" physics\n    // Uses getters & setters to adjust values, e.g. in response to actions.\n    this._moveAcceleration = MOVE_ACCELERATION;\n    this._moveDeceleration = MOVE_DECELERATION;\n    this._moveMaxSpeed = MOVE_MAX_SPEED;\n    this._pushDeceleration = PUSH_DECELERATION;\n    this._pushMaxSpeed = PUSH_MAX_SPEED;\n\n    // Animation\n    this.spriteSheet = undefined; // HTML Image object (e.g. app.assets['hero'].img) containing all sprites used by this Entity.\n    this.spriteSizeX = 16; // Size of each sprite on the sprite sheet.\n    this.spriteSizeY = 16;\n    this.spriteScale = 2; // Scale of the sprite when paint()ed.\n    this.spriteOffsetX = -8; // Offset of sprite relative to this Entity's {x,y}, when painted on canvas.\n    this.spriteOffsetY = -8; // This is usually -0.5 * spriteSizeXorY to make sure the sprite is centred on Entity.\n    // Note: an Entity's {x,y} origin is usually its centre, whereas a HTML Image's {x,y} origin is its top-left corner.\n\n    // Advanced Animation\n    this.spriteFlipEastToWest = false; // For 4-directional sprite sheets, we can automatically flip East-facing sprites into West-facing sprites during paintSprite().\n    this.spriteZAddsToOffsetY = true; // If entity has a positive z-position, add that value to offsetY.\n  }\n  return _createClass(Entity, [{\n    key: \"deconstructor\",\n    value: function deconstructor() {}\n\n    /*\r\n    Section: General Logic\r\n    ----------------------------------------------------------------------------\r\n     */\n\n    /*\r\n    Run a single frame of game logic for the entity.\r\n    By default, this just handles physics (positioning and movement). Child\r\n    entities should generally call super.play() to ensure proper physics & etc.\r\n     */\n  }, {\n    key: \"play\",\n    value: function play() {\n      // Update position\n      this.x += this.moveX + this.pushX;\n      this.y += this.moveY + this.pushY;\n\n      // Upkeep: deceleration\n      this.doMoveDeceleration();\n      this.doPushDeceleration();\n\n      // Upkeep: limit speed\n      this.doMaxSpeedLimit();\n\n      // Upkeep: gravity\n      if (this.z > 0) {\n        this.z = Math.max(0, this.z + GRAVITY);\n      }\n    }\n\n    /*\r\n    Paint (render) the entity.\r\n    By default, this just paints the shape (hitbox). Child entities should do\r\n    something more interesting, such as calling this.paintSprite().\r\n     */\n  }, {\n    key: \"paint\",\n    value: function paint() {\n      var layer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var c2d = this._app.canvas2d;\n      this._app.applyCameraTransforms();\n      if (layer === _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.LAYERS.MIDDLE) {\n        c2d.fillStyle = this.colour;\n        c2d.strokeStyle = '#404040';\n        c2d.lineWidth = this.mass * PAINT_HITBOX_MASS_TO_LINEWIDTH_FACTOR;\n\n        // Draw shape outline\n        switch (this.shape) {\n          case _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.SHAPES.CIRCLE:\n            c2d.beginPath();\n            c2d.arc(this.x, this.y, this.size / 2, 0, 2 * Math.PI);\n            c2d.fill();\n            this.solid && c2d.stroke();\n            break;\n          case _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.SHAPES.SQUARE:\n            c2d.beginPath();\n            c2d.rect(this.x - this.size / 2, this.y - this.size / 2, this.size, this.size);\n            c2d.fill();\n            this.solid && c2d.stroke();\n            break;\n          case _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.SHAPES.POLYGON:\n            c2d.beginPath();\n            var coords = this.vertices;\n            if (coords.length >= 1) c2d.moveTo(coords[coords.length - 1].x, coords[coords.length - 1].y);\n            for (var i = 0; i < coords.length; i++) {\n              c2d.lineTo(coords[i].x, coords[i].y);\n            }\n            c2d.closePath();\n            c2d.fill();\n            this.solid && c2d.stroke();\n            break;\n        }\n\n        // Draw anchor point, mostly for debugging\n        c2d.strokeStyle = 'rgba(255, 255, 255, 0.5)';\n        c2d.beginPath();\n        c2d.arc(this.x, this.y, 2, 0, 2 * Math.PI); // Anchor point\n        if (this.shape === _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.SHAPES.CIRCLE) {\n          // Direction line\n          c2d.moveTo(this.x + this.size * 0.1 * Math.cos(this.rotation), this.y + this.size * 0.1 * Math.sin(this.rotation));\n          c2d.lineTo(this.x + this.size * 0.5 * Math.cos(this.rotation), this.y + this.size * 0.5 * Math.sin(this.rotation));\n        }\n        c2d.stroke();\n      }\n      this._app.undoCameraTransforms();\n    }\n\n    /*\r\n    Paint the entity's sprite, at the entity's position.\r\n    Note: args are optional; ONLY specify values for args if you want to override\r\n    the automatic calculations.\r\n     */\n  }, {\n    key: \"paintSprite\",\n    value: function paintSprite() {\n      var _args$spriteSizeX, _args$spriteSizeY, _args$spriteCol, _args$spriteRow, _ref, _args$spriteScaleX, _ref2, _args$spriteScaleY, _args$spriteOffsetX, _args$spriteOffsetY;\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n        // Source values\n        spriteCol: undefined,\n        // Column and row of source sprite on the sprite sheet. \n        spriteRow: undefined,\n        spriteSizeX: undefined,\n        // Size of source sprite on sprite sheet.\n        spriteSizeY: undefined,\n        // Painting target values\n        spriteOffsetX: undefined,\n        // Offset of sprite relative to this Entity's {x,y}, when painted on canvas.\n        spriteOffsetY: undefined,\n        // This is usually -0.5 * spriteSizeXorY to make sure the sprite is centred on Entity.\n        spriteRotation: undefined,\n        // Rotate the sprite.\n        spriteScale: undefined,\n        // Scale of the sprite when paint()ed.\n        spriteScaleX: undefined,\n        // Note: if you specify spriteScaleX/spriteScaleY, then spriteScale will be ignored.\n        spriteScaleY: undefined\n      };\n      var app = this._app;\n      var c2d = app.canvas2d;\n      if (!this.spriteSheet) return;\n      app.applyCameraTransforms();\n\n      // Calculate all the variables\n      var sizeX = (_args$spriteSizeX = args === null || args === void 0 ? void 0 : args.spriteSizeX) !== null && _args$spriteSizeX !== void 0 ? _args$spriteSizeX : this.spriteSizeX;\n      var sizeY = (_args$spriteSizeY = args === null || args === void 0 ? void 0 : args.spriteSizeY) !== null && _args$spriteSizeY !== void 0 ? _args$spriteSizeY : this.spriteSizeY;\n      var srcX = ((_args$spriteCol = args === null || args === void 0 ? void 0 : args.spriteCol) !== null && _args$spriteCol !== void 0 ? _args$spriteCol : this.getSpriteCol()) * sizeX;\n      var srcY = ((_args$spriteRow = args === null || args === void 0 ? void 0 : args.spriteRow) !== null && _args$spriteRow !== void 0 ? _args$spriteRow : this.getSpriteRow()) * sizeY;\n      var scaleX = (_ref = (_args$spriteScaleX = args === null || args === void 0 ? void 0 : args.spriteScaleX) !== null && _args$spriteScaleX !== void 0 ? _args$spriteScaleX : args === null || args === void 0 ? void 0 : args.spriteScale) !== null && _ref !== void 0 ? _ref : this.spriteScale;\n      var scaleY = (_ref2 = (_args$spriteScaleY = args === null || args === void 0 ? void 0 : args.spriteScaleY) !== null && _args$spriteScaleY !== void 0 ? _args$spriteScaleY : args === null || args === void 0 ? void 0 : args.spriteScale) !== null && _ref2 !== void 0 ? _ref2 : this.spriteScale;\n\n      // TODO: flipping sprites should be determined by a more general \"sprite rendering strategy\"\n      var flipX = this.spriteFlipEastToWest && this.getSpriteDirection() === _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.DIRECTIONS.WEST ? -1 : 1;\n      c2d.translate(this.x, this.y); // 1. This moves the 'drawing origin' to match the position of (the centre of) the Entity.\n      c2d.scale(flipX * scaleX, scaleY); // 2. This ensures the sprite scales with the 'drawing origin' as the anchor point.\n      if ((args === null || args === void 0 ? void 0 : args.spriteRotation) !== undefined) {\n        // 3. (OPTIONAL) If we wanted to, we could rotate the sprite around the 'drawing origin'.\n        c2d.rotate(args === null || args === void 0 ? void 0 : args.spriteRotation);\n      }\n\n      // 4. tgtX and tgtY specify where to draw the sprite, relative to the 'drawing origin'.\n      var tgtX = (_args$spriteOffsetX = args === null || args === void 0 ? void 0 : args.spriteOffsetX) !== null && _args$spriteOffsetX !== void 0 ? _args$spriteOffsetX : this.spriteOffsetX; // Usually this is sizeX * -0.5, to centre-align.\n      var tgtY = (_args$spriteOffsetY = args === null || args === void 0 ? void 0 : args.spriteOffsetY) !== null && _args$spriteOffsetY !== void 0 ? _args$spriteOffsetY : this.spriteOffsetY; // Usually this is sizeY * -0.75 to nudge a sprite upwards.\n\n      if (this.spriteZAddsToOffsetY) tgtY -= Math.max(0, this.z);\n      c2d.drawImage(this.spriteSheet, srcX, srcY, sizeX, sizeY, tgtX, tgtY, sizeX, sizeY);\n      app.undoCameraTransforms();\n    }\n\n    /*\r\n    Paint the entity's shadow, at the entity's position.\r\n    Actually very similar to - if not a modified copy of - the default \"paint\r\n    hitbox\" code.\r\n     */\n  }, {\n    key: \"paintShadow\",\n    value: function paintShadow() {\n      var layer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var c2d = this._app.canvas2d;\n      this._app.applyCameraTransforms();\n      if (layer === _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.LAYERS.BOTTOM) {\n        c2d.fillStyle = '#20202080';\n        switch (this.shape) {\n          case _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.SHAPES.CIRCLE:\n            c2d.beginPath();\n            c2d.arc(this.x, this.y, this.size / 2, 0, 2 * Math.PI);\n            c2d.fill();\n            break;\n          case _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.SHAPES.SQUARE:\n            c2d.beginPath();\n            c2d.rect(this.x - this.size / 2, this.y - this.size / 2, this.size, this.size);\n            c2d.fill();\n            break;\n          case _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.SHAPES.POLYGON:\n            c2d.beginPath();\n            var coords = this.vertices;\n            if (coords.length >= 1) c2d.moveTo(coords[coords.length - 1].x, coords[coords.length - 1].y);\n            for (var i = 0; i < coords.length; i++) {\n              c2d.lineTo(coords[i].x, coords[i].y);\n            }\n            c2d.closePath();\n            c2d.fill();\n            break;\n        }\n      }\n      this._app.undoCameraTransforms();\n    }\n\n    /*\r\n    Section: Game Logic\r\n    ----------------------------------------------------------------------------\r\n     */\n\n    /*\r\n    Applies an effect to this entity. Usually called by another antity.\r\n    e.g. a fireball hits this character and applies an \"ON FIRE\" effect.\r\n     */\n  }, {\n    key: \"applyEffect\",\n    value: function applyEffect(effect, source) {}\n\n    /*\r\n    Section: Event Handling\r\n    ----------------------------------------------------------------------------\r\n     */\n\n    /*\r\n    Triggers when this entity hits/touches/intersects with another.\r\n     */\n  }, {\n    key: \"onCollision\",\n    value: function onCollision(target, collisionCorrection) {\n      this.doBounce(target, collisionCorrection);\n      this.x = collisionCorrection.x;\n      this.y = collisionCorrection.y;\n    }\n\n    /*\r\n    Section: Physics\r\n    ----------------------------------------------------------------------------\r\n     */\n\n    /*\r\n    By default, every moving entity decelerates (because we don't exist in a\r\n    perfect vacuum and the game doesn't take place on a slippery ice).\r\n    Entities can intentionally override this logic,\r\n    e.g. \"if a hero is walking, ignore deceleration.\"\r\n     */\n  }, {\n    key: \"doMoveDeceleration\",\n    value: function doMoveDeceleration() {\n      var moveDeceleration = this.moveDeceleration || 0;\n      var curRotation = Math.atan2(this.moveY, this.moveX);\n      var newMoveSpeed = Math.max(0, this.moveSpeed - moveDeceleration);\n      this.moveX = newMoveSpeed * Math.cos(curRotation);\n      this.moveY = newMoveSpeed * Math.sin(curRotation);\n    }\n  }, {\n    key: \"doPushDeceleration\",\n    value: function doPushDeceleration() {\n      var pushDeceleration = this.pushDeceleration || 0;\n      var curRotation = Math.atan2(this.pushY, this.pushX);\n      var newPushSpeed = Math.max(0, this.pushSpeed - pushDeceleration);\n      this.pushX = newPushSpeed * Math.cos(curRotation);\n      this.pushY = newPushSpeed * Math.sin(curRotation);\n    }\n\n    /*\r\n    Every entity has a maximum speed limit. Intentional movement speed and\r\n    external force movement speed are treated separately.\r\n     */\n  }, {\n    key: \"doMaxSpeedLimit\",\n    value: function doMaxSpeedLimit() {\n      // Limit max move speed\n      if (this.moveMaxSpeed >= 0) {\n        var correctedSpeed = Math.min(this.moveMaxSpeed, this.moveSpeed);\n        var moveAngle = this.moveAngle;\n        this.moveX = correctedSpeed * Math.cos(moveAngle);\n        this.moveY = correctedSpeed * Math.sin(moveAngle);\n      }\n\n      // Limit max push speed\n      if (this.pushMaxSpeed >= 0) {\n        var _correctedSpeed = Math.min(this.pushMaxSpeed, this.pushSpeed);\n        var pushAngle = this.pushAngle;\n        this.pushX = _correctedSpeed * Math.cos(pushAngle);\n        this.pushY = _correctedSpeed * Math.sin(pushAngle);\n      }\n    }\n\n    /*\r\n    When a solid pushed entity hits another solid entity, momentum is transferred.\r\n    Usually, this leads to elastic collisions, because that chaos is fun!\r\n     */\n  }, {\n    key: \"doBounce\",\n    value: function doBounce(target, collisionCorrection) {\n      // If this object isn't a movable solid, it can't bounce.\n      if (!(this.movable && this.solid)) return;\n      if (\n      // this object is bouncing off an unmovable object\n      this.movable && this.solid && !target.movable && target.solid) {\n        if (this.shape === _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.SHAPES.CIRCLE && target.shape === _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.SHAPES.CIRCLE) {\n          // For circle + circle collisions, the collision correction already\n          // tells us the bounce direction.\n          var angle = Math.atan2(collisionCorrection.y - this.y, collisionCorrection.x - this.x);\n          var speed = Math.sqrt(this.pushX * this.pushX + this.pushY * this.pushY);\n          this.pushX = Math.cos(angle) * speed;\n          this.pushY = Math.sin(angle) * speed;\n        } else if (this.shape === _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.SHAPES.CIRCLE && (target.shape === _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.SHAPES.SQUARE || target.shape === _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.SHAPES.POLYGON)) {\n          // For circle + polygon collisions, we need to know...\n          // - the original angle this circle was moving towards (or rather, its\n          //   reverse, because we want a bounce)\n          // - the normal vector (of the edge) of the polygon this circle collided\n          //   into (which we can get from the collision correction)\n          // - the angle between them\n          var reverseOriginalAngle = Math.atan2(-this.pushY, -this.pushX);\n          var normalAngle = Math.atan2(collisionCorrection.y - this.y, collisionCorrection.x - this.x);\n          var angleBetween = normalAngle - reverseOriginalAngle;\n          var _angle = reverseOriginalAngle + 2 * angleBetween;\n          var _speed = Math.sqrt(this.pushX * this.pushX + this.pushY * this.pushY);\n          this.pushX = Math.cos(_angle) * _speed;\n          this.pushY = Math.sin(_angle) * _speed;\n        } else {\n          // For the moment, we're not too concerned about polygons bumping into each other\n        }\n      } else if (\n      // this object is bouncing off another movable object\n      target.movable && target.solid && collisionCorrection.pushX !== undefined && collisionCorrection.pushY !== undefined) {\n        this.pushX = collisionCorrection.pushX;\n        this.pushY = collisionCorrection.pushY;\n      }\n    }\n\n    /*\r\n    Section: Animation\r\n    ----------------------------------------------------------------------------\r\n     */\n\n    /*\r\n    NOTE: an Entity usually has one of two styles of sprite sheets:\r\n    1. 4-directional (Zelda-style) sprite sheets, used for characters/actors.\r\n    2. Static sprite sheets, used for environmental objects and etc.\r\n      For 4-directional sprite sheets, each sprite has a variation that faces a\r\n    different cardinal direction. The sprite sheet is usually divided so that each\r\n    row represents a state/action (e.g. idle0, move1, move2) and each column\r\n    represents a direction (South, East, North, West - though the West column can\r\n    be omitted if we just flip the East-facing sprite in-game).\r\n     */\n\n    /*\r\n    Get the directional orientation of the sprite, for a 4-directional\r\n    (Zelda-style) sprite sheet.\r\n     */\n  }, {\n    key: \"getSpriteDirection\",\n    value: function getSpriteDirection() {\n      //Favour East and West when rotation is exactly SW, NW, SE or NE.\n      if (this._rotation <= Math.PI * 0.25 && this._rotation >= Math.PI * -0.25) {\n        return _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.DIRECTIONS.EAST;\n      } else if (this._rotation > Math.PI * 0.25 && this._rotation < Math.PI * 0.75) {\n        return _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.DIRECTIONS.SOUTH;\n      } else if (this._rotation < Math.PI * -0.25 && this._rotation > Math.PI * -0.75) {\n        return _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.DIRECTIONS.NORTH;\n      } else {\n        return _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.DIRECTIONS.WEST;\n      }\n    }\n\n    /*\r\n    Get the column/row of the current sprite on the sprite sheet.\r\n     */\n  }, {\n    key: \"getSpriteCol\",\n    value: function getSpriteCol() {\n      return 0;\n    }\n  }, {\n    key: \"getSpriteRow\",\n    value: function getSpriteRow() {\n      return 0;\n    }\n\n    /*\r\n    Section: Getters and Setters\r\n    ----------------------------------------------------------------------------\r\n     */\n  }, {\n    key: \"left\",\n    get: function get() {\n      return this.x - this.size / 2;\n    },\n    set: function set(val) {\n      this.x = val + this.size / 2;\n    }\n  }, {\n    key: \"right\",\n    get: function get() {\n      return this.x + this.size / 2;\n    },\n    set: function set(val) {\n      this.x = val - this.size / 2;\n    }\n  }, {\n    key: \"top\",\n    get: function get() {\n      return this.y - this.size / 2;\n    },\n    set: function set(val) {\n      this.y = val + this.size / 2;\n    }\n  }, {\n    key: \"bottom\",\n    get: function get() {\n      return this.y + this.size / 2;\n    },\n    set: function set(val) {\n      this.y = val - this.size / 2;\n    }\n  }, {\n    key: \"radius\",\n    get: function get() {\n      return this.size / 2;\n    },\n    set: function set(val) {\n      this.size = val * 2;\n    }\n  }, {\n    key: \"col\",\n    get: function get() {\n      return Math.floor(this.x / _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE);\n    },\n    set: function set(val) {\n      this.x = val * _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE + _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE / 2;\n    }\n  }, {\n    key: \"row\",\n    get: function get() {\n      return Math.floor(this.y / _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE);\n    },\n    set: function set(val) {\n      this.y = val * _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE + _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE / 2;\n    }\n\n    /*\r\n    Rotation tracks the precise angle the entity is facing, in radians, clockwise\r\n    positive. 0 (0 rad) is east/right-facing, 90 (+pi/4 rad) is\r\n    south/down-facing.\r\n     */\n  }, {\n    key: \"rotation\",\n    get: function get() {\n      return this._rotation;\n    },\n    set: function set(val) {\n      this._rotation = val;\n      while (this._rotation > Math.PI) {\n        this._rotation -= Math.PI * 2;\n      }\n      while (this._rotation <= -Math.PI) {\n        this._rotation += Math.PI * 2;\n      }\n    }\n\n    /*\r\n    Every entity has a shape that can be represented by a polygon. (Yes, even\r\n    circles.) Each vertex is a point in the polygon where two segments/lines/edges\r\n    intersect.\r\n     */\n  }, {\n    key: \"vertices\",\n    get: function get() {\n      var _this = this;\n      var v = [];\n      if (this.shape === _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.SHAPES.SQUARE) {\n        v.push({\n          x: this.left,\n          y: this.top\n        });\n        v.push({\n          x: this.right,\n          y: this.top\n        });\n        v.push({\n          x: this.right,\n          y: this.bottom\n        });\n        v.push({\n          x: this.left,\n          y: this.bottom\n        });\n      } else if (this.shape === _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.SHAPES.CIRCLE) {\n        //Approximation\n        CIRCLE_TO_POLYGON_APPROXIMATOR.map(function (approximator) {\n          v.push({\n            x: _this.x + _this.radius * approximator.cosAngle,\n            y: _this.y + _this.radius * approximator.sinAngle\n          });\n        });\n      } else if (this.shape === _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.SHAPES.POLYGON) {\n        if (!this.shapePolygonPath) return [];\n        for (var i = 0; i < this.shapePolygonPath.length; i += 2) {\n          v.push({\n            x: this.x + this.shapePolygonPath[i],\n            y: this.y + this.shapePolygonPath[i + 1]\n          });\n        }\n      }\n      return v;\n    },\n    set: function set(val) {\n      console.error('ERROR: Entity.vertices is read only');\n    }\n\n    /*\r\n    Each segment is a line in the polygonal shape (or polygon-approximated shape)\r\n    of the entity.\r\n     */\n  }, {\n    key: \"segments\",\n    get: function get() {\n      var vertices = this.vertices;\n      if (vertices.length < 2) return [];\n      return vertices.map(function (vertex1, i) {\n        var vertex2 = vertices[(i + 1) % vertices.length];\n        return {\n          start: {\n            x: vertex1.x,\n            y: vertex1.y\n          },\n          end: {\n            x: vertex2.x,\n            y: vertex2.y\n          }\n        };\n      });\n    },\n    set: function set(val) {\n      console.error('ERROR: Entity.segments is read only');\n    }\n  }, {\n    key: \"moveAcceleration\",\n    get: function get() {\n      return this._moveAcceleration;\n    },\n    set: function set(val) {\n      this._moveAcceleration = val;\n    }\n  }, {\n    key: \"moveDeceleration\",\n    get: function get() {\n      return this._moveDeceleration;\n    },\n    set: function set(val) {\n      this._moveDeceleration = val;\n    }\n  }, {\n    key: \"moveMaxSpeed\",\n    get: function get() {\n      return this._moveMaxSpeed;\n    },\n    set: function set(val) {\n      this._moveMaxSpeed = val;\n    }\n  }, {\n    key: \"pushDeceleration\",\n    get: function get() {\n      return this._pushDeceleration;\n    },\n    set: function set(val) {\n      this._pushDeceleration = val;\n    }\n  }, {\n    key: \"pushMaxSpeed\",\n    get: function get() {\n      return this._pushMaxSpeed;\n    },\n    set: function set(val) {\n      this._pushMaxSpeed = val;\n    }\n  }, {\n    key: \"moveSpeed\",\n    get: function get() {\n      return Math.sqrt(this.moveX * this.moveX + this.moveY * this.moveY);\n    },\n    set: function set(val) {\n      console.error('ERROR: Entity.moveSpeed is read only');\n    }\n  }, {\n    key: \"moveAngle\",\n    get: function get() {\n      return Math.atan2(this.moveY, this.moveX);\n    },\n    set: function set(val) {\n      console.error('ERROR: Entity.moveAngle is read only');\n    }\n  }, {\n    key: \"pushSpeed\",\n    get: function get() {\n      return Math.sqrt(this.pushX * this.pushX + this.pushY * this.pushY);\n    },\n    set: function set(val) {\n      console.error('ERROR: Entity.pushSpeed is read only');\n    }\n  }, {\n    key: \"pushAngle\",\n    get: function get() {\n      return Math.atan2(this.pushY, this.pushX);\n    },\n    set: function set(val) {\n      console.error('ERROR: Entity.pushAngle is read only');\n    }\n  }]);\n}();\n\nvar CIRCLE_TO_POLYGON_APPROXIMATOR = [_avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.ROTATIONS.EAST, _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.ROTATIONS.SOUTHEAST, _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.ROTATIONS.SOUTH, _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.ROTATIONS.SOUTHWEST, _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.ROTATIONS.WEST, _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.ROTATIONS.NORTHWEST, _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.ROTATIONS.NORTH, _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.ROTATIONS.NORTHEAST].map(function (angle) {\n  return {\n    cosAngle: Math.cos(angle),\n    sinAngle: Math.sin(angle)\n  };\n});\n\n//# sourceURL=webpack://cny2026/./src/avo/entity/entity.js?");

/***/ }),

/***/ "./src/avo/entity/examples/ball.js":
/*!*****************************************!*\
  !*** ./src/avo/entity/examples/ball.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Ball)\n/* harmony export */ });\n/* harmony import */ var _avo_entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/entity */ \"./src/avo/entity/index.js\");\n/* harmony import */ var _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @avo/constants.js */ \"./src/avo/constants.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n\n\nvar Ball = /*#__PURE__*/function (_Entity) {\n  function Ball(app) {\n    var _this;\n    var col = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var row = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    _classCallCheck(this, Ball);\n    _this = _callSuper(this, Ball, [app]);\n    _this._type = 'ball';\n    _this.colour = '#48c';\n    _this.solid = true;\n    _this.movable = true;\n    _this.x = col * _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE + _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE / 2;\n    _this.y = row * _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE + _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE / 2;\n    return _this;\n  }\n  _inherits(Ball, _Entity);\n  return _createClass(Ball);\n}(_avo_entity__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n\n//# sourceURL=webpack://cny2026/./src/avo/entity/examples/ball.js?");

/***/ }),

/***/ "./src/avo/entity/examples/enemy.js":
/*!******************************************!*\
  !*** ./src/avo/entity/examples/enemy.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Enemy)\n/* harmony export */ });\n/* harmony import */ var _avo_entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/entity */ \"./src/avo/entity/index.js\");\n/* harmony import */ var _avo_entity_examples_shot_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @avo/entity/examples/shot.js */ \"./src/avo/entity/examples/shot.js\");\n/* harmony import */ var _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @avo/constants.js */ \"./src/avo/constants.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && \"function\" == typeof p ? function (t) { return p.apply(e, t); } : p; }\nfunction _get() { return _get = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }\nfunction _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n\n\n\nvar Enemy = /*#__PURE__*/function (_Entity) {\n  function Enemy(app) {\n    var _this;\n    var col = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var row = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    _classCallCheck(this, Enemy);\n    _this = _callSuper(this, Enemy, [app]);\n    _this._type = 'enemy';\n    _this.colour = '#4c4';\n    _this.x = col * _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.TILE_SIZE + _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.TILE_SIZE / 2;\n    _this.y = row * _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.TILE_SIZE + _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.TILE_SIZE / 2;\n    _this.action = {\n      name: 'shoot',\n      counter: 0,\n      acknowledged: false\n    };\n    return _this;\n  }\n  _inherits(Enemy, _Entity);\n  return _createClass(Enemy, [{\n    key: \"play\",\n    value: function play() {\n      _superPropGet(Enemy, \"play\", this, 3)([]);\n      this.processAction();\n    }\n  }, {\n    key: \"processAction\",\n    value: function processAction() {\n      if (!this.action) return;\n      var action = this.action;\n      var app = this._app;\n      if (action.name === 'shoot') {\n        var DURATION = 500;\n        var progress = action.counter / DURATION;\n        if (!action.acknowledged && progress > 0.5) {\n          action.acknowledged = true;\n          app.addEntity(new _avo_entity_examples_shot_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](app, this.x, this.y, this.rotation, this));\n        }\n        action.counter += _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.FRAME_DURATION;\n        if (action.counter >= DURATION) {\n          this.action = {\n            name: 'shoot',\n            counter: 0,\n            acknowledged: false\n          };\n        }\n      }\n    }\n  }]);\n}(_avo_entity__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n\n//# sourceURL=webpack://cny2026/./src/avo/entity/examples/enemy.js?");

/***/ }),

/***/ "./src/avo/entity/examples/hero.js":
/*!*****************************************!*\
  !*** ./src/avo/entity/examples/hero.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Hero)\n/* harmony export */ });\n/* harmony import */ var _avo_entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/entity */ \"./src/avo/entity/index.js\");\n/* harmony import */ var _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @avo/constants.js */ \"./src/avo/constants.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && \"function\" == typeof p ? function (t) { return p.apply(e, t); } : p; }\nfunction _get() { return _get = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }\nfunction _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n\n\nvar INVULNERABILITY_WINDOW = 3000;\nvar MOVE_ACTION_CYCLE_DURATION = 500;\nvar Hero = /*#__PURE__*/function (_Entity) {\n  function Hero(app) {\n    var _this;\n    var col = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var row = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    _classCallCheck(this, Hero);\n    _this = _callSuper(this, Hero, [app]);\n    _this._type = 'hero';\n    _this.colour = '#000';\n    _this.x = col * _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE + _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE / 2;\n    _this.y = row * _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE + _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE / 2;\n    _this.intent = undefined;\n    _this.action = undefined;\n    _this.health = 3;\n    _this.invulnerability = 0; // Invulnerability time\n    return _this;\n  }\n\n  /*\r\n  Section: General Logic\r\n  ----------------------------------------------------------------------------\r\n   */\n  _inherits(Hero, _Entity);\n  return _createClass(Hero, [{\n    key: \"play\",\n    value: function play() {\n      _superPropGet(Hero, \"play\", this, 3)([]);\n      this.processIntent();\n      this.processAction();\n\n      // Count down invulnerability time\n      if (this.invulnerability > 0) {\n        this.invulnerability = Math.max(this.invulnerability - _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.FRAME_DURATION, 0);\n      }\n    }\n  }, {\n    key: \"paint\",\n    value: function paint() {\n      var layer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var app = this._app;\n      if (this.invulnerability > 0) {\n        // If invulnerable, flash!\n        var flash = Math.floor(this.invulnerability / 300) % 2;\n        if (flash === 1) return;\n      }\n      this.colour = app.playerInput.pointerState === _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.POINTER_STATES.POINTER_DOWN ? '#e42' : '#c44';\n      _superPropGet(Hero, \"paint\", this, 3)([layer]);\n      var c2d = app.canvas2d;\n      var animationSpriteSheet = app.assets['hero-4dir'];\n      if (!animationSpriteSheet) return;\n      this._app.applyCameraTransforms();\n      var SPRITE_SIZE = 48;\n      var FLIP_SPRITE = 1;\n      var SPRITE_SCALE = 2 * (Math.min(this.health / 3, 1) * 0.5 + 0.5); // Shrink after taking damage\n\n      // Draw any special vfx\n      var action = this.action;\n      if ((action === null || action === void 0 ? void 0 : action.name) === 'dash' && (action === null || action === void 0 ? void 0 : action.state) === 'execution' && layer === _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.LAYERS.MIDDLE) {\n        // Draw a \"dash line\"\n        var dashLength = this.size * 2;\n        var dashWidth = this.size;\n        var dashTailX = this.x - dashLength * Math.cos(this.rotation);\n        var dashTailY = this.y - dashLength * Math.sin(this.rotation);\n        c2d.beginPath();\n        c2d.moveTo(this.x, this.y);\n        c2d.lineTo(dashTailX, dashTailY);\n        c2d.strokeStyle = 'rgba(255, 255, 0, 0.5)';\n        c2d.lineWidth = dashWidth;\n        c2d.stroke();\n      }\n\n      // Draw the sprite\n      if (layer === _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.LAYERS.MIDDLE) {\n        var srcX = this.getSpriteCol() * SPRITE_SIZE;\n        var srcY = this.getSpriteRow() * SPRITE_SIZE;\n        var sizeX = SPRITE_SIZE;\n        var sizeY = SPRITE_SIZE;\n        c2d.translate(this.x, this.y); // 1. This moves the 'drawing origin' to match the position of (the centre of) the Entity.\n        c2d.scale(SPRITE_SCALE * FLIP_SPRITE, SPRITE_SCALE); // 2. This ensures the sprite scales with the 'drawing origin' as the anchor point.\n        // c2d.rotate(this.rotation)  // 3. If we wanted to, we could rotate the sprite around the 'drawing origin'.\n\n        // 4. tgtX and tgtY specify where to draw the sprite, relative to the 'drawing origin'.\n        var tgtX = -sizeX / 2; // Align centre of sprite to origin\n        var tgtY = -sizeY * 0.75; // Align bottom(-ish) of sprite to origin\n\n        c2d.drawImage(animationSpriteSheet.img, srcX, srcY, sizeX, sizeY, tgtX, tgtY, sizeX, sizeY);\n      }\n      this._app.undoCameraTransforms();\n    }\n\n    /*\r\n    Section: Game Logic\r\n    ----------------------------------------------------------------------------\r\n     */\n  }, {\n    key: \"applyEffect\",\n    value: function applyEffect(effect, source) {\n      _superPropGet(Hero, \"applyEffect\", this, 3)([effect, source]);\n      if (!effect) return;\n      if (effect.name === 'damage') {\n        if (this.invulnerability === 0) {\n          this.health = Math.max(this.health - 1, 0);\n          this.invulnerability = INVULNERABILITY_WINDOW;\n        }\n      }\n    }\n\n    /*\r\n    Section: Intent and Actions\r\n    ----------------------------------------------------------------------------\r\n     */\n\n    /*\r\n    Translate intent into action.\r\n     */\n  }, {\n    key: \"processIntent\",\n    value: function processIntent() {\n      // Failsafe\n      if (!this.action) this.goIdle();\n      var action = this.action;\n      var intent = this.intent;\n      if (!intent) {\n        // Go idle\n        if ((action === null || action === void 0 ? void 0 : action.name) === 'move') this.goIdle();\n      } else {\n        // Perform a new action\n        // Note: every 'move' action is considered a new action\n\n        if ((action === null || action === void 0 ? void 0 : action.name) === 'idle' || (action === null || action === void 0 ? void 0 : action.name) === 'move') {\n          // Can the action be overwritten by a new action? If not, the action must play through to its finish.\n          this.action = _objectSpread(_objectSpread({}, intent), {}, {\n            name: intent.name,\n            counter: action.name === intent.name ? action.counter : 0 // If the current action and new intent have the same name, it's just a continuation of the idle or move action, but with other new values (e.g. new directions)\n          });\n        }\n      }\n    }\n\n    /*\r\n    Perform the action.\r\n     */\n  }, {\n    key: \"processAction\",\n    value: function processAction() {\n      if (!this.action) return;\n      var action = this.action;\n      if (action.name === 'idle') {\n\n        // Do nothing\n      } else if (action.name === 'move') {\n        var moveAcceleration = this.moveAcceleration || 0;\n        var directionX = action.directionX || 0;\n        var directionY = action.directionY || 0;\n        var actionRotation = Math.atan2(directionY, directionX);\n        this.moveX += moveAcceleration * Math.cos(actionRotation);\n        this.moveY += moveAcceleration * Math.sin(actionRotation);\n        this.rotation = actionRotation;\n        action.counter = (action.counter + _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.FRAME_DURATION) % MOVE_ACTION_CYCLE_DURATION;\n      } else if (action.name === 'dash') {\n        var WINDUP_DURATION = _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.FRAME_DURATION * 5;\n        var EXECUTION_DURATION = _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.FRAME_DURATION * 2;\n        var WINDDOWN_DURATION = _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.FRAME_DURATION * 10;\n        var PUSH_POWER = this.size * 0.3;\n        var MAX_PUSH = EXECUTION_DURATION / 1000 * 60 * PUSH_POWER;\n        if (!action.state) {\n          // Trigger only once, at the start of the action\n\n          // Figure out the initial direction of the dash\n          var _directionX = action.directionX || 0;\n          var _directionY = action.directionY || 0;\n          this.rotation = _directionX === 0 && _directionY === 0 ? this.rotation : Math.atan2(_directionY, _directionX);\n          action.rotation = this.rotation; // Records the initial direction of the dash\n\n          action.state = 'windup';\n        }\n        if (action.state === 'windup') {\n          action.counter += _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.FRAME_DURATION;\n          if (action.counter >= WINDUP_DURATION) {\n            action.state = 'execution';\n            action.counter = 0;\n          }\n        } else if (action.state === 'execution') {\n          this.pushX += PUSH_POWER * Math.cos(action.rotation);\n          this.pushY += PUSH_POWER * Math.sin(action.rotation);\n          action.counter += _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.FRAME_DURATION;\n          if (action.counter >= EXECUTION_DURATION) {\n            action.state = 'winddown';\n            action.counter = 0;\n          }\n        } else if (action.state === 'winddown') {\n          action.counter += _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.FRAME_DURATION;\n          if (action.counter >= WINDDOWN_DURATION) {\n            this.goIdle();\n          }\n        }\n      }\n    }\n  }, {\n    key: \"goIdle\",\n    value: function goIdle() {\n      this.action = {\n        name: 'idle',\n        counter: 0\n      };\n    }\n\n    /*\r\n    Section: Event Handling\r\n    ----------------------------------------------------------------------------\r\n     */\n\n    /*\r\n    Triggers when this entity hits/touches/intersects with another.\r\n     */\n  }, {\n    key: \"onCollision\",\n    value: function onCollision(target, collisionCorrection) {\n      _superPropGet(Hero, \"onCollision\", this, 3)([target, collisionCorrection]);\n      if (!target) return;\n    }\n\n    /*\r\n    Section: Physics/Getters and Setters\r\n    ----------------------------------------------------------------------------\r\n     */\n  }, {\n    key: \"moveDeceleration\",\n    get: function get() {\n      var _this$action;\n      if (((_this$action = this.action) === null || _this$action === void 0 ? void 0 : _this$action.name) === 'move') return 0;\n      return this._moveDeceleration;\n    }\n  }, {\n    key: \"pushDeceleration\",\n    get: function get() {\n      var _this$action2, _this$action3;\n      if (((_this$action2 = this.action) === null || _this$action2 === void 0 ? void 0 : _this$action2.name) === 'dash' && ((_this$action3 = this.action) === null || _this$action3 === void 0 ? void 0 : _this$action3.state) === 'execution') return 0;\n      return this._pushDeceleration;\n    }\n\n    /*\r\n    Section: Animation\r\n    ----------------------------------------------------------------------------\r\n     */\n  }, {\n    key: \"getSpriteCol\",\n    value: function getSpriteCol() {\n      switch (this.getSpriteDirection()) {\n        case _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.DIRECTIONS.NORTH:\n          return 1;\n        case _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.DIRECTIONS.EAST:\n          return 2;\n        case _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.DIRECTIONS.SOUTH:\n          return 0;\n        case _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.DIRECTIONS.WEST:\n          return 3;\n      }\n      return 0;\n    }\n  }, {\n    key: \"getSpriteRow\",\n    value: function getSpriteRow() {\n      var action = this.action;\n      if (!action) return 0;\n      if (action.name === 'move') {\n        var progress = action.counter / MOVE_ACTION_CYCLE_DURATION;\n        if (progress < 0.3) return 2;else if (progress < 0.5) return 1;else if (progress < 0.8) return 3;else if (progress < 1) return 1;\n      } else if (action.name === 'dash') {\n        if (action.state === 'windup') return 4;else if (action.state === 'execution') return 1;else if (action.state === 'winddown') return 1;\n      }\n      return 0;\n    }\n  }]);\n}(_avo_entity__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n\n//# sourceURL=webpack://cny2026/./src/avo/entity/examples/hero.js?");

/***/ }),

/***/ "./src/avo/entity/examples/shot.js":
/*!*****************************************!*\
  !*** ./src/avo/entity/examples/shot.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Shot)\n/* harmony export */ });\n/* harmony import */ var _avo_entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/entity */ \"./src/avo/entity/index.js\");\n/* harmony import */ var _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @avo/constants.js */ \"./src/avo/constants.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && \"function\" == typeof p ? function (t) { return p.apply(e, t); } : p; }\nfunction _get() { return _get = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }\nfunction _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n\n\nvar Shot = /*#__PURE__*/function (_Entity) {\n  function Shot(app) {\n    var _this;\n    var x = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var y = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var rotation = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    var source = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : undefined;\n    _classCallCheck(this, Shot);\n    _this = _callSuper(this, Shot, [app]);\n    _this._type = 'shot';\n    _this.source = source; // The entity that this shot came from\n\n    _this.colour = '#cc4';\n    _this.solid = false;\n    _this.movable = true;\n    _this.size = _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE / 2;\n    _this.x = x;\n    _this.y = y;\n    _this.rotation = rotation;\n    _this.moveAcceleration = 1;\n    _this.moveDeceleration = 0;\n    _this.moveMaxSpeed = _this.size * 2;\n    _this.distance = _this.size * 1;\n    return _this;\n  }\n  _inherits(Shot, _Entity);\n  return _createClass(Shot, [{\n    key: \"onCollision\",\n    value: function onCollision(target, collisionCorrection) {\n      _superPropGet(Shot, \"onCollision\", this, 3)([target, collisionCorrection]);\n      if (this.source !== target && target.solid) {\n        target.applyEffect({\n          name: 'damage'\n        }, this);\n        this._expired = true;\n      }\n    }\n  }, {\n    key: \"play\",\n    value: function play() {\n      _superPropGet(Shot, \"play\", this, 3)([]);\n      var moveAcceleration = this.moveAcceleration || 0;\n      this.moveX += moveAcceleration * Math.cos(this.rotation);\n      this.moveY += moveAcceleration * Math.sin(this.rotation);\n      this.distance -= moveAcceleration;\n      if (this.distance <= 0) this._expired = true;\n    }\n  }]);\n}(_avo_entity__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n\n//# sourceURL=webpack://cny2026/./src/avo/entity/examples/shot.js?");

/***/ }),

/***/ "./src/avo/entity/examples/wall.js":
/*!*****************************************!*\
  !*** ./src/avo/entity/examples/wall.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Wall)\n/* harmony export */ });\n/* harmony import */ var _avo_entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/entity */ \"./src/avo/entity/index.js\");\n/* harmony import */ var _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @avo/constants.js */ \"./src/avo/constants.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n\n\nvar Wall = /*#__PURE__*/function (_Entity) {\n  function Wall(app) {\n    var _this;\n    var col = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var row = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var width = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n    var height = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n    var cutCorner = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n    _classCallCheck(this, Wall);\n    _this = _callSuper(this, Wall, [app]);\n    _this._type = 'wall';\n    _this.colour = '#888';\n    _this.solid = true;\n    _this.movable = false;\n    _this.x = col * _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE;\n    _this.y = row * _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE;\n    _this.shape = _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.SHAPES.POLYGON;\n    _this.shapePolygonPath = [];\n    if (cutCorner !== 'nw') _this.shapePolygonPath.push(0, 0);\n    if (cutCorner !== 'ne') _this.shapePolygonPath.push(width * _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE, 0);\n    if (cutCorner !== 'se') _this.shapePolygonPath.push(width * _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE, height * _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE);\n    if (cutCorner !== 'sw') _this.shapePolygonPath.push(0, height * _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE);\n    return _this;\n  }\n  _inherits(Wall, _Entity);\n  return _createClass(Wall);\n}(_avo_entity__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n\n//# sourceURL=webpack://cny2026/./src/avo/entity/examples/wall.js?");

/***/ }),

/***/ "./src/avo/entity/index.js":
/*!*********************************!*\
  !*** ./src/avo/entity/index.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _entity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./entity.js */ \"./src/avo/entity/entity.js\");\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_entity_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n//# sourceURL=webpack://cny2026/./src/avo/entity/index.js?");

/***/ }),

/***/ "./src/avo/entity/types/creature.js":
/*!******************************************!*\
  !*** ./src/avo/entity/types/creature.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Creature)\n/* harmony export */ });\n/* harmony import */ var _entity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../entity.js */ \"./src/avo/entity/entity.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n\nvar Creature = /*#__PURE__*/function (_Entity) {\n  function Creature(app) {\n    var _this;\n    _classCallCheck(this, Creature);\n    _this = _callSuper(this, Creature, [app]);\n    _this._type = 'creature';\n    return _this;\n  }\n  _inherits(Creature, _Entity);\n  return _createClass(Creature);\n}(_entity_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n\n//# sourceURL=webpack://cny2026/./src/avo/entity/types/creature.js?");

/***/ }),

/***/ "./src/avo/image-asset.js":
/*!********************************!*\
  !*** ./src/avo/image-asset.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ImageAsset)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nvar ImageAsset = /*#__PURE__*/_createClass(function ImageAsset(url) {\n  _classCallCheck(this, ImageAsset);\n  this.url = url;\n  this.ready = false;\n  this.error = false;\n  this.img = new Image();\n  this.img.onload = function () {\n    this.ready = true;\n    this.error = false;\n  }.bind(this);\n  this.img.onerror = function (err) {\n    console.error('ImageAsset Error (' + this.url + '): ', err);\n    this.ready = false;\n    this.error = true;\n  }.bind(this);\n  this.img.src = this.url;\n});\n\n\n//# sourceURL=webpack://cny2026/./src/avo/image-asset.js?");

/***/ }),

/***/ "./src/avo/index.js":
/*!**************************!*\
  !*** ./src/avo/index.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _avo_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./avo.js */ \"./src/avo/avo.js\");\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_avo_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n//# sourceURL=webpack://cny2026/./src/avo/index.js?");

/***/ }),

/***/ "./src/avo/interaction/index.js":
/*!**************************************!*\
  !*** ./src/avo/interaction/index.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _interaction_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interaction.js */ \"./src/avo/interaction/interaction.js\");\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_interaction_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n//# sourceURL=webpack://cny2026/./src/avo/interaction/index.js?");

/***/ }),

/***/ "./src/avo/interaction/interaction.js":
/*!********************************************!*\
  !*** ./src/avo/interaction/interaction.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Interaction)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar Interaction = /*#__PURE__*/function () {\n  function Interaction(app) {\n    _classCallCheck(this, Interaction);\n    this._app = app;\n    this._type = 'interaction';\n    this.name = ''; // Optional identifier\n  }\n  return _createClass(Interaction, [{\n    key: \"load\",\n    value: function load(div) {\n      var _this = this;\n      var menu = document.createElement('div');\n      menu.innerHTML = \"\\n      <h3>Example Interaction Menu</h3>\\n      <p>Debug Controls:</p>\\n      <ul>\\n        <li><b>[X]</b> Open example interaction menu</li>\\n        <li><b>[Z]</b> Action</li>\\n      </ul>\\n    \";\n      var closeButton = document.createElement('button');\n      closeButton.type = 'button';\n      closeButton.innerText = 'OK!';\n      closeButton.onclick = function () {\n        _this._app.setInteractionMenu(false);\n      };\n      menu.appendChild(closeButton);\n      div.appendChild(menu);\n      setTimeout(function () {\n        closeButton.focus();\n      }, 100);\n    }\n  }, {\n    key: \"unload\",\n    value: function unload() {}\n  }]);\n}();\n\n\n//# sourceURL=webpack://cny2026/./src/avo/interaction/interaction.js?");

/***/ }),

/***/ "./src/avo/misc.js":
/*!*************************!*\
  !*** ./src/avo/misc.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   angleDiff: () => (/* binding */ angleDiff),\n/* harmony export */   isZero: () => (/* binding */ isZero),\n/* harmony export */   transformSpriteSheet: () => (/* binding */ transformSpriteSheet)\n/* harmony export */ });\n/*\r\nChecks if a number is (close enough) to zero.\r\nDue to the imprecise way floating number data can be stored, it's possible for\r\na mathematical 0 to be represented as something incredibly small like\r\n1.4210854715202004e-14. This screws boolean checks like (num === 0)\r\n */\nfunction isZero(num) {\n  return -1e-10 < num && num < 1e-10;\n}\n\n/*\r\nFinds the difference between angle B and angle A, in radians.\r\n */\nfunction angleDiff(angleA, angleB) {\n  var diff = angleB - angleA;\n\n  // Clamp diff value to -180 <= x <= +180\n  while (diff < -Math.PI) diff += Math.PI * 2; // While diff < -180, rotate by +360\n  while (diff > Math.PI) diff -= Math.PI * 2; // While diff > 180, rotate by -360\n\n  return diff;\n}\n\n/*\r\nTransforms a sprite sheet (basically a HTMLImageElement), pixel by pixel.\r\n */\nfunction transformSpriteSheet(image) {\n  var transform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (r, g, b, a) {\n    return {\n      r: r,\n      g: g,\n      b: b,\n      a: a\n    };\n  };\n  if (!image || !(image !== null && image !== void 0 && image.width) || !(image !== null && image !== void 0 && image.height)) return image;\n\n  // Create an OffscreenCanvas and paint the image on it.\n  var width = image.width;\n  var height = image.height;\n  var offscreenCanvas = new OffscreenCanvas(width, height);\n  var c2dOff = offscreenCanvas.getContext('2d');\n  c2dOff.drawImage(image, 0, 0, width, height, 0, 0, width, height);\n\n  // Extract the data from the painted image.\n  var offImage = c2dOff.getImageData(0, 0, width, height);\n  var offData = offImage === null || offImage === void 0 ? void 0 : offImage.data;\n  var dataLength = (offData === null || offData === void 0 ? void 0 : offData.length) || 0;\n\n  // Go through every pixel in the data, and run it through the transformer.\n  for (var i = 0; i < dataLength; i += 4) {\n    var _r = offData[i + 0];\n    var _g = offData[i + 1];\n    var _b = offData[i + 2];\n    var _a = offData[i + 3];\n    var _transform = transform(_r, _g, _b, _a),\n      r = _transform.r,\n      g = _transform.g,\n      b = _transform.b,\n      a = _transform.a;\n    offData[i + 0] = r;\n    offData[i + 1] = g;\n    offData[i + 2] = b;\n    offData[i + 3] = a;\n  }\n\n  // Commit the changes\n  c2dOff.putImageData(offImage, 0, 0);\n\n  // Convert transformed image into an ImageBitmap object.\n  // I *think* this provides better performance than returning an offscreenCanvas, but I'm not 100% sure.\n  var transformedImageBitmap = offscreenCanvas.transferToImageBitmap();\n  // transformedImageBitmap.close()  // DON'T close.\n  return transformedImageBitmap;\n\n  // Alternatively, just return the offscreenCanvas - but this may result in a performance cost.\n  // return offscreenCanvas\n}\n\n//# sourceURL=webpack://cny2026/./src/avo/misc.js?");

/***/ }),

/***/ "./src/avo/physics.js":
/*!****************************!*\
  !*** ./src/avo/physics.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Physics)\n/* harmony export */ });\n/* harmony import */ var _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/constants.js */ \"./src/avo/constants.js\");\n/* harmony import */ var _avo_misc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @avo/misc.js */ \"./src/avo/misc.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\nvar USE_CIRCLE_APPROXIMATION = false;\nvar Physics = /*#__PURE__*/function () {\n  function Physics() {\n    _classCallCheck(this, Physics);\n  }\n  return _createClass(Physics, null, [{\n    key: \"checkCollision\",\n    value:\n    //----------------------------------------------------------------\n\n    /*\r\n    Checks if objA is touching objB.\r\n    - If true, returns the corrected coordinates for objA and objB, in form:\r\n      { a: { x, y },\r\n        b: { x, y } }\r\n    - If false, returns null.\r\n     */\n    function checkCollision(objA, objB) {\n      if (!objA || !objB || objA === objB) return null;\n\n      // Circle + Circle collision\n      if (objA.shape === _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.SHAPES.CIRCLE && objB.shape === _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.SHAPES.CIRCLE) {\n        return Physics.checkCollision_circleCircle(objA, objB);\n      }\n\n      // Polygon + Polygon collision. (Squares are polygons, of course.)\n      else if ((objA.shape === _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.SHAPES.SQUARE || objA.shape === _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.SHAPES.POLYGON) && (objB.shape === _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.SHAPES.SQUARE || objB.shape === _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.SHAPES.POLYGON)) {\n        return Physics.checkCollision_polygonPolygon(objA, objB);\n      }\n\n      // Circle + Polygon collision.\n      else if (objA.shape === _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.SHAPES.CIRCLE && (objB.shape === _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.SHAPES.SQUARE || objB.shape === _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.SHAPES.POLYGON)) {\n        if (USE_CIRCLE_APPROXIMATION) return Physics.checkCollision_polygonPolygon(objA, objB);\n        return Physics.checkCollision_circlePolygon(objA, objB);\n      }\n\n      // Polygon + Circle collision\n      // It's the reverse of the previous scenario.\n      else if ((objA.shape === _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.SHAPES.SQUARE || objA.shape === _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.SHAPES.POLYGON) && objB.shape === _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.SHAPES.CIRCLE) {\n        if (USE_CIRCLE_APPROXIMATION) return Physics.checkCollision_polygonPolygon(objA, objB);\n        var correction = Physics.checkCollision_circlePolygon(objB, objA);\n        if (correction) {\n          correction = {\n            a: correction.b,\n            b: correction.a\n          };\n        }\n        return correction;\n      }\n      return null;\n    }\n    //----------------------------------------------------------------\n  }, {\n    key: \"checkCollision_circleCircle\",\n    value: function checkCollision_circleCircle(objA, objB) {\n      var fractionA = 0;\n      var fractionB = 0;\n      if (!objA.solid || !objB.solid) {\n        //If either object isn't solid, there's no collision correction.\n      } else if (objA.movable && objB.movable) {\n        fractionA = 0.5;\n        fractionB = 0.5;\n      } else if (objA.movable) {\n        fractionA = 1;\n      } else if (objB.movable) {\n        fractionB = 1;\n      }\n      var distX = objB.x - objA.x;\n      var distY = objB.y - objA.y;\n      var dist = Math.sqrt(distX * distX + distY * distY);\n      var minimumDist = objA.radius + objB.radius;\n      if (dist < minimumDist) {\n        var angle = Math.atan2(distY, distX);\n        var correctDist = minimumDist;\n        var cosAngle = Math.cos(angle);\n        var sinAngle = Math.sin(angle);\n        var motion = Physics.getPostCollisionMotion(objA, objB);\n        return {\n          a: {\n            x: objA.x - cosAngle * (correctDist - dist) * fractionA,\n            y: objA.y - sinAngle * (correctDist - dist) * fractionA,\n            pushX: motion && motion.a.pushX,\n            pushY: motion && motion.a.pushY\n          },\n          b: {\n            x: objB.x + cosAngle * (correctDist - dist) * fractionB,\n            y: objB.y + sinAngle * (correctDist - dist) * fractionB,\n            pushX: motion && motion.b.pushX,\n            pushY: motion && motion.b.pushY\n          }\n        };\n      }\n      return null;\n    }\n\n    //----------------------------------------------------------------\n  }, {\n    key: \"checkCollision_polygonPolygon\",\n    value: function checkCollision_polygonPolygon(objA, objB) {\n      var fractionA = 0;\n      var fractionB = 0;\n      if (!objA.solid || !objB.solid) {\n        //If either object isn't solid, there's no collision correction.\n      } else if (objA.movable && objB.movable) {\n        fractionA = 0.5;\n        fractionB = 0.5;\n      } else if (objA.movable) {\n        fractionA = 1;\n      } else if (objB.movable) {\n        fractionB = 1;\n      }\n      var correction = null;\n      var verticesA = objA.vertices;\n      var verticesB = objB.vertices;\n      var projectionAxes = [].concat(_toConsumableArray(Physics.getShapeNormals(objA)), _toConsumableArray(Physics.getShapeNormals(objB)));\n      for (var i = 0; i < projectionAxes.length; i++) {\n        var axis = projectionAxes[i];\n        var projectionA = {\n          min: Infinity,\n          max: -Infinity\n        };\n        var projectionB = {\n          min: Infinity,\n          max: -Infinity\n        };\n        for (var j = 0; j < verticesA.length; j++) {\n          var val = Physics.dotProduct(axis, verticesA[j]);\n          projectionA.min = Math.min(projectionA.min, val);\n          projectionA.max = Math.max(projectionA.max, val);\n        }\n        for (var _j = 0; _j < verticesB.length; _j++) {\n          var _val = Physics.dotProduct(axis, verticesB[_j]);\n          projectionB.min = Math.min(projectionB.min, _val);\n          projectionB.max = Math.max(projectionB.max, _val);\n        }\n        var overlap = Math.max(0, Math.min(projectionA.max, projectionB.max) - Math.max(projectionA.min, projectionB.min));\n        if (!correction || overlap < correction.magnitude) {\n          var sign = Math.sign(projectionB.min + projectionB.max - (projectionA.min + projectionA.max));\n          correction = {\n            magnitude: overlap,\n            x: axis.x * overlap * sign,\n            y: axis.y * overlap * sign\n          };\n        }\n      }\n      if (correction && correction.magnitude > 0) {\n        return {\n          a: {\n            x: objA.x - correction.x * fractionA,\n            y: objA.y - correction.y * fractionA\n          },\n          b: {\n            x: objB.x + correction.x * fractionB,\n            y: objB.y + correction.y * fractionB\n          }\n        };\n      }\n      return null;\n    }\n\n    //----------------------------------------------------------------\n  }, {\n    key: \"checkCollision_circlePolygon\",\n    value: function checkCollision_circlePolygon(objA, objB) {\n      var fractionA = 0;\n      var fractionB = 0;\n      if (!objA.solid || !objB.solid) {\n        //If either object isn't solid, there's no collision correction.\n      } else if (objA.movable && objB.movable) {\n        fractionA = 0.5;\n        fractionB = 0.5;\n      } else if (objA.movable) {\n        fractionA = 1;\n      } else if (objB.movable) {\n        fractionB = 1;\n      }\n      var distX = objB.x - objA.x;\n      var distY = objB.y - objA.y;\n      var dist = Math.sqrt(distX * distX + distY * distY);\n      var centreToCentreAxis = dist !== 0 ? {\n        x: distX / dist,\n        y: distY / dist\n      } : {\n        x: 0,\n        y: 0\n      };\n      var correction = null;\n      var verticesB = objB.vertices;\n      var projectionAxes = [centreToCentreAxis].concat(_toConsumableArray(Physics.getShapeNormals(objB)));\n      for (var i = 0; i < projectionAxes.length; i++) {\n        var axis = projectionAxes[i];\n        var scalarA = Physics.dotProduct(axis, {\n          x: objA.x,\n          y: objA.y\n        });\n        var projectionA = {\n          min: scalarA - objA.radius,\n          max: scalarA + objA.radius\n        };\n        var projectionB = {\n          min: Infinity,\n          max: -Infinity\n        };\n        for (var j = 0; j < verticesB.length; j++) {\n          var val = Physics.dotProduct(axis, verticesB[j]);\n          projectionB.min = Math.min(projectionB.min, val);\n          projectionB.max = Math.max(projectionB.max, val);\n        }\n        var overlap = Math.max(0, Math.min(projectionA.max, projectionB.max) - Math.max(projectionA.min, projectionB.min));\n        if (!correction || overlap < correction.magnitude) {\n          var sign = Math.sign(projectionB.min + projectionB.max - (projectionA.min + projectionA.max));\n          correction = {\n            magnitude: overlap,\n            x: axis.x * overlap * sign,\n            y: axis.y * overlap * sign\n          };\n        }\n      }\n      if (correction && correction.magnitude > 0) {\n        return {\n          a: {\n            x: objA.x - correction.x * fractionA,\n            y: objA.y - correction.y * fractionA\n          },\n          b: {\n            x: objB.x + correction.x * fractionB,\n            y: objB.y + correction.y * fractionB\n          }\n        };\n      }\n    }\n\n    //----------------------------------------------------------------\n\n    /*  Gets the NORMALISED normals for each edge of the object's shape. Assumes the object has the 'vertices' property.\r\n     */\n  }, {\n    key: \"getShapeNormals\",\n    value: function getShapeNormals(obj) {\n      var vertices = obj.vertices;\n      if (!vertices) return null;\n      if (vertices.length < 2) return []; //Look, you need to have at least three vertices to be a shape.\n\n      //First, calculate the edges connecting each vertice.\n      //--------------------------------\n      var edges = [];\n      for (var i = 0; i < vertices.length; i++) {\n        var p1 = vertices[i];\n        var p2 = vertices[(i + 1) % vertices.length];\n        edges.push({\n          x: p2.x - p1.x,\n          y: p2.y - p1.y\n        });\n      }\n      //--------------------------------\n\n      //Calculate the NORMALISED normals for each edge.\n      //--------------------------------\n      return edges.map(function (edge) {\n        var dist = Math.sqrt(edge.x * edge.x + edge.y * edge.y);\n        if (dist === 0) return {\n          x: 0,\n          y: 0\n        };\n        return {\n          x: -edge.y / dist,\n          y: edge.x / dist\n        };\n      });\n      //--------------------------------\n    }\n\n    //----------------------------------------------------------------\n  }, {\n    key: \"getPostCollisionMotion\",\n    value: function getPostCollisionMotion(objA, objB) {\n      if (!objA || !objB) return null;\n      if (!objA.movable || !objA.solid || objA.mass === 0 || !objB.movable || !objB.solid || objB.mass === 0 || objA.mass + objB.mass === 0) return null;\n      var collisionAngle = Math.atan2(objB.y - objA.y, objB.x - objA.x);\n      var ANGLE_90 = Math.PI / 2;\n      var totalMass = objA.mass + objB.mass;\n      var aSpd = objA.pushSpeed;\n      var bSpd = objB.pushSpeed;\n      var aAng = objA.pushAngle;\n      var bAng = objB.pushAngle;\n      var aMass = objA.mass;\n      var bMass = objB.mass;\n      var aGroup = (aSpd * Math.cos(aAng - collisionAngle) * (aMass - bMass) + 2 * bMass * bSpd * Math.cos(bAng - collisionAngle)) / totalMass;\n      var bGroup = (bSpd * Math.cos(bAng - collisionAngle) * (bMass - aMass) + 2 * aMass * aSpd * Math.cos(aAng - collisionAngle)) / totalMass;\n      var objA_pushX = aGroup * Math.cos(collisionAngle) + aSpd * Math.sin(aAng - collisionAngle) * Math.cos(collisionAngle + ANGLE_90);\n      var objA_pushY = aGroup * Math.sin(collisionAngle) + aSpd * Math.sin(aAng - collisionAngle) * Math.sin(collisionAngle + ANGLE_90);\n      var objB_pushX = bGroup * Math.cos(collisionAngle) + bSpd * Math.sin(bAng - collisionAngle) * Math.cos(collisionAngle + ANGLE_90);\n      var objB_pushY = bGroup * Math.sin(collisionAngle) + bSpd * Math.sin(bAng - collisionAngle) * Math.sin(collisionAngle + ANGLE_90);\n      return {\n        a: {\n          pushX: objA_pushX,\n          pushY: objA_pushY\n        },\n        b: {\n          pushX: objB_pushX,\n          pushY: objB_pushY\n        }\n      };\n    }\n\n    //----------------------------------------------------------------\n  }, {\n    key: \"dotProduct\",\n    value: function dotProduct(vectorA, vectorB) {\n      if (!vectorA || !vectorB) return null;\n      return vectorA.x * vectorB.x + vectorA.y * vectorB.y;\n    }\n\n    //----------------------------------------------------------------\n\n    /*\r\n    Calculate intersection between two lines (a ray and a segment of a polygon).\r\n    Useful for determining valids line of sight.\r\n      - Each line is in the format { start: { x, y }, end: { x, y } }\r\n    - Returns null if there's no intersection.\r\n    - Returns { x, y, distanceFactor } if there's an intersection.\r\n      x, y are the coordinates of the intersection point.\r\n      distanceFactor is how far from the ray's origin point the intersection\r\n      occurs. If 1, intersection occurs at the ray's end point. If 0.5,\r\n      intersection occurs halfway between the ray's origin point and end point.\r\n      Original code from https://ncase.me/sight-and-light/\r\n     */\n  }, {\n    key: \"getLineIntersection\",\n    value: function getLineIntersection(ray, segment) {\n      // Each line is represented in the format:\n      // line = originPoint + directionVector * distanceFactor\n      // Or a bit more simply:\n      // line = origin (o) + direction (d) * factor (f)\n\n      // Ray\n      var r_ox = ray.start.x;\n      var r_oy = ray.start.y;\n      var r_dx = ray.end.x - ray.start.x;\n      var r_dy = ray.end.y - ray.start.y;\n\n      // Segment\n      var s_ox = segment.start.x;\n      var s_oy = segment.start.y;\n      var s_dx = segment.end.x - segment.start.x;\n      var s_dy = segment.end.y - segment.start.y;\n\n      // The intersection occurs where ray.x === segment.x and ray.y === segment.y\n      // So, we need to solve for r_factor and s_factor in...\n      // r_ox + r_dx * r_factor = s_ox + s_dx * s_factor && r_oy + r_dy * r_factor = s_oy + s_dy * s_factor\n      var r_factor = null;\n      var s_factor = null;\n      if (!(0,_avo_misc_js__WEBPACK_IMPORTED_MODULE_1__.isZero)(s_dx * r_dy - s_dy * r_dx)) {\n        // Solve for s_factor.\n        s_factor = (r_dx * (s_oy - r_oy) + r_dy * (r_ox - s_ox)) / (s_dx * r_dy - s_dy * r_dx);\n\n        // There are two ways to solve for r_factor; one works when the ray\n        // isn't perfectly horizontal, the other works when the ray isn't\n        // perfectly vertical.\n        if (!(0,_avo_misc_js__WEBPACK_IMPORTED_MODULE_1__.isZero)(r_dx)) {\n          r_factor = (s_ox + s_dx * s_factor - r_ox) / r_dx;\n        } else if (!(0,_avo_misc_js__WEBPACK_IMPORTED_MODULE_1__.isZero)(r_dy)) {\n          r_factor = (s_oy + s_dy * s_factor - r_oy) / r_dy;\n        }\n      }\n\n      // Check if the intersection occurs within the length of both lines.\n      // (The maths above calculates for infinitely long lines.)\n      if (r_factor === null || s_factor === null || r_factor < 0 || r_factor > 1 || s_factor < 0 || s_factor > 1) return null;\n\n      // Point of intersection\n      return {\n        x: r_ox + r_dx * r_factor,\n        y: r_oy + r_dy * r_factor,\n        distanceFactor: r_factor\n      };\n    }\n\n    //----------------------------------------------------------------\n  }]);\n}();\n\n\n//# sourceURL=webpack://cny2026/./src/avo/physics.js?");

/***/ }),

/***/ "./src/avo/rule/examples/zelda-controls.js":
/*!*************************************************!*\
  !*** ./src/avo/rule/examples/zelda-controls.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ZeldaControls)\n/* harmony export */ });\n/* harmony import */ var _avo_rule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/rule */ \"./src/avo/rule/index.js\");\n/* harmony import */ var _avo_physics_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @avo/physics.js */ \"./src/avo/physics.js\");\n/* harmony import */ var _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @avo/constants.js */ \"./src/avo/constants.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && \"function\" == typeof p ? function (t) { return p.apply(e, t); } : p; }\nfunction _get() { return _get = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }\nfunction _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n\n\n\n\n/*\r\nStandard player controls for top-down adventure games.\r\n */\nvar ZeldaControls = /*#__PURE__*/function (_Rule) {\n  function ZeldaControls(app) {\n    var _this;\n    _classCallCheck(this, ZeldaControls);\n    _this = _callSuper(this, ZeldaControls, [app]);\n    _this._type = 'zelda-controls';\n    _this.inputTap = false;\n    _this.onPointerTap = _this.onPointerTap.bind(_this);\n    app.addEventListener('pointertap', _this.onPointerTap);\n    return _this;\n  }\n  _inherits(ZeldaControls, _Rule);\n  return _createClass(ZeldaControls, [{\n    key: \"deconstructor\",\n    value: function deconstructor() {\n      app.removeEventListener('pointertap', this.onPointerTap);\n    }\n  }, {\n    key: \"play\",\n    value: function play() {\n      var app = this._app;\n      var hero = app.hero;\n      _superPropGet(ZeldaControls, \"play\", this, 3)([]);\n      if (hero) {\n        var _app$playerInput = app.playerInput,\n          keysPressed = _app$playerInput.keysPressed,\n          pointerCurrent = _app$playerInput.pointerCurrent,\n          pointerStart = _app$playerInput.pointerStart,\n          pointerState = _app$playerInput.pointerState;\n        var intent = undefined;\n        var directionX = 0;\n        var directionY = 0;\n        if (pointerState === _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.POINTER_STATES.POINTER_DOWN) {\n          // Get pointer input if there's any.\n\n          var distX = pointerCurrent.x - pointerStart.x;\n          var distY = pointerCurrent.y - pointerStart.y;\n          var pointerDistance = Math.sqrt(distX * distX + distY * distY);\n          // const movementAngle = Math.atan2(distY, distX)\n\n          if (pointerDistance > _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.POINTER_DEADZONE_RADIUS) {\n            directionX = distX / pointerDistance;\n            directionY = distY / pointerDistance;\n          }\n        } else {\n          // Otherwise, check for keyboard input.\n\n          if (keysPressed['ArrowRight']) directionX++;\n          if (keysPressed['ArrowDown']) directionY++;\n          if (keysPressed['ArrowLeft']) directionX--;\n          if (keysPressed['ArrowUp']) directionY--;\n        }\n        if (keysPressed['z'] && !keysPressed['z'].acknowledged || keysPressed['Z'] && !keysPressed['Z'].acknowledged || this.inputTap) {\n          intent = {\n            name: 'dash',\n            directionX: directionX,\n            directionY: directionY\n          };\n          if (keysPressed['z']) keysPressed['z'].acknowledged = true;\n          if (keysPressed['Z']) keysPressed['Z'].acknowledged = true;\n          this.inputTap = false;\n        } else if (directionX || directionY) {\n          intent = {\n            name: 'move',\n            directionX: directionX,\n            directionY: directionY\n          };\n        }\n        hero.intent = intent;\n      }\n    }\n  }, {\n    key: \"paint\",\n    value: function paint() {\n      var layer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var hero = this._app.hero;\n      if (layer === _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.LAYERS.OVERLAY) {\n        this.paintUIData();\n        this.paintPointerInput();\n      } else if (layer === _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.LAYERS.BOTTOM) {\n        this.paintLineOfSight(hero);\n      }\n    }\n\n    /*\r\n    Draw UI data, such as Hero health.\r\n     */\n  }, {\n    key: \"paintUIData\",\n    value: function paintUIData() {\n      var _hero$action;\n      var c2d = this._app.canvas2d;\n      var hero = this._app.hero;\n      var X_OFFSET = _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.TILE_SIZE * 1.5;\n      var Y_OFFSET = _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.TILE_SIZE * -1.0;\n      var LEFT = X_OFFSET;\n      var RIGHT = this._app.canvasWidth - X_OFFSET;\n      var BOTTOM = this._app.canvasHeight + Y_OFFSET;\n      c2d.font = '2em Source Code Pro';\n      c2d.textBaseline = 'bottom';\n      c2d.lineWidth = 8;\n      var health = Math.max(hero === null || hero === void 0 ? void 0 : hero.health, 0) || 0;\n      var text = ''.repeat(health);\n      c2d.textAlign = 'left';\n      c2d.strokeStyle = '#fff';\n      c2d.strokeText(text, LEFT, BOTTOM);\n      c2d.fillStyle = '#c44';\n      c2d.fillText(text, LEFT, BOTTOM);\n      text = (hero === null || hero === void 0 || (_hero$action = hero.action) === null || _hero$action === void 0 ? void 0 : _hero$action.name) + ' (' + (hero === null || hero === void 0 ? void 0 : hero.moveSpeed.toFixed(2)) + ')';\n      c2d.textAlign = 'right';\n      c2d.strokeStyle = '#fff';\n      c2d.strokeText(text, RIGHT, BOTTOM);\n      c2d.fillStyle = '#c44';\n      c2d.fillText(text, RIGHT, BOTTOM);\n    }\n\n    /*\r\n    Draw pointer input, if any. This helps players get visual feedback on their\r\n    touchscreens.\r\n     */\n  }, {\n    key: \"paintPointerInput\",\n    value: function paintPointerInput() {\n      var c2d = this._app.canvas2d;\n      var _this$_app$playerInpu = this._app.playerInput,\n        pointerCurrent = _this$_app$playerInpu.pointerCurrent,\n        pointerStart = _this$_app$playerInpu.pointerStart,\n        pointerState = _this$_app$playerInpu.pointerState;\n      var START_POINT_RADIUS = _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.TILE_SIZE * 1,\n        CURRENT_POINT_RADIUS = _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.TILE_SIZE * 0.5;\n      if (pointerState === _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.POINTER_STATES.POINTER_DOWN) {\n        c2d.lineWidth = Math.floor(Math.min(_avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.TILE_SIZE * 0.125, 2));\n        c2d.fillStyle = '#80808080';\n        c2d.strokeStyle = '#80808080';\n        c2d.beginPath();\n        c2d.arc(pointerStart.x, pointerStart.y, START_POINT_RADIUS, 0, 2 * Math.PI);\n        c2d.stroke();\n        c2d.beginPath();\n        c2d.arc(pointerCurrent.x, pointerCurrent.y, CURRENT_POINT_RADIUS, 0, 2 * Math.PI);\n        c2d.fill();\n        c2d.beginPath();\n        c2d.moveTo(pointerStart.x, pointerStart.y);\n        c2d.lineTo(pointerCurrent.x, pointerCurrent.y);\n        c2d.stroke();\n      }\n    }\n\n    /*\r\n    Draw a line of sight (cast a ray) starting from a specified Entity (usually the\r\n    hero), in the direction they're facing.\r\n     */\n  }, {\n    key: \"paintLineOfSight\",\n    value: function paintLineOfSight(srcEntity) {\n      if (!srcEntity) return;\n      var c2d = this._app.canvas2d;\n      var camera = this._app.camera;\n      var entities = this._app.entities;\n      var MAX_LINE_OF_SIGHT_DISTANCE = _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.TILE_SIZE * 5;\n      this._app.applyCameraTransforms();\n\n      // Intended line of sight, i.e. a ray starting from the hero/source Entity.\n      var lineOfSight = {\n        start: {\n          x: srcEntity.x,\n          y: srcEntity.y\n        },\n        end: {\n          x: srcEntity.x + MAX_LINE_OF_SIGHT_DISTANCE * Math.cos(srcEntity.rotation),\n          y: srcEntity.y + MAX_LINE_OF_SIGHT_DISTANCE * Math.sin(srcEntity.rotation)\n        }\n      };\n      var actualLineOfSightEndPoint = undefined;\n\n      // For each other Entity, see if it intersects with the source Entity's LOS\n      entities.forEach(function (entity) {\n        if (entity === srcEntity) return;\n\n        // TODO: check for opaqueness and/or if the entity is visible.\n\n        var vertices = entity.vertices;\n        if (vertices.length < 2) return;\n\n        // Every entity has a \"shape\" that can be represented by a polygon.\n        // (Yes, even circles.) Check each segment (aka edge aka side) of the\n        // polygon.\n        for (var i = 0; i < vertices.length; i++) {\n          var segment = {\n            start: {\n              x: vertices[i].x,\n              y: vertices[i].y\n            },\n            end: {\n              x: vertices[(i + 1) % vertices.length].x,\n              y: vertices[(i + 1) % vertices.length].y\n            }\n          };\n\n          // Find the intersection. We want to find the intersection point\n          // closest to the source Entity (the LOS ray's starting point).\n          var intersection = _avo_physics_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getLineIntersection(lineOfSight, segment);\n          if (!actualLineOfSightEndPoint || intersection && intersection.distanceFactor < actualLineOfSightEndPoint.distanceFactor) {\n            actualLineOfSightEndPoint = intersection;\n          }\n        }\n      });\n      if (!actualLineOfSightEndPoint) {\n        actualLineOfSightEndPoint = {\n          x: srcEntity.x + MAX_LINE_OF_SIGHT_DISTANCE * Math.cos(srcEntity.rotation),\n          y: srcEntity.y + MAX_LINE_OF_SIGHT_DISTANCE * Math.sin(srcEntity.rotation)\n        };\n      }\n\n      // Expected line of sight\n      c2d.beginPath();\n      c2d.moveTo(lineOfSight.start.x, lineOfSight.start.y);\n      c2d.lineTo(lineOfSight.end.x, lineOfSight.end.y);\n      c2d.strokeStyle = '#c08080';\n      c2d.lineWidth = 3;\n      c2d.stroke();\n      c2d.setLineDash([]);\n\n      // Actual line of sight\n      c2d.beginPath();\n      c2d.moveTo(lineOfSight.start.x, lineOfSight.start.y);\n      c2d.lineTo(actualLineOfSightEndPoint.x, actualLineOfSightEndPoint.y);\n      c2d.strokeStyle = '#3399ff';\n      c2d.lineWidth = 3;\n      c2d.stroke();\n\n      // Expected end of line of sight\n      c2d.beginPath();\n      c2d.arc(lineOfSight.end.x, lineOfSight.end.y, 4, 0, 2 * Math.PI);\n      c2d.fillStyle = '#c08080';\n      c2d.fill();\n\n      // Actual end of line of sight\n      c2d.beginPath();\n      c2d.arc(actualLineOfSightEndPoint.x, actualLineOfSightEndPoint.y, 8, 0, 2 * Math.PI);\n      c2d.fillStyle = '#3399ff';\n      c2d.fill();\n      this._app.undoCameraTransforms();\n    }\n  }, {\n    key: \"onPointerTap\",\n    value: function onPointerTap() {\n      this.inputTap = true;\n    }\n  }]);\n}(_avo_rule__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n\n//# sourceURL=webpack://cny2026/./src/avo/rule/examples/zelda-controls.js?");

/***/ }),

/***/ "./src/avo/rule/index.js":
/*!*******************************!*\
  !*** ./src/avo/rule/index.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _rule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rule.js */ \"./src/avo/rule/rule.js\");\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_rule_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n//# sourceURL=webpack://cny2026/./src/avo/rule/index.js?");

/***/ }),

/***/ "./src/avo/rule/rule.js":
/*!******************************!*\
  !*** ./src/avo/rule/rule.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Rule)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar Rule = /*#__PURE__*/function () {\n  function Rule(app) {\n    _classCallCheck(this, Rule);\n    this._app = app;\n    this._type = 'rule';\n    this.name = ''; // Optional identifier\n\n    // Expired rules are removed at the end of the cycle.\n    this._expired = false;\n  }\n  return _createClass(Rule, [{\n    key: \"deconstructor\",\n    value: function deconstructor() {}\n\n    /*\r\n    Section: General Logic\r\n    ----------------------------------------------------------------------------\r\n     */\n  }, {\n    key: \"play\",\n    value: function play() {}\n  }, {\n    key: \"paint\",\n    value: function paint() {\n      var layer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    }\n  }]);\n}();\n\n\n//# sourceURL=webpack://cny2026/./src/avo/rule/rule.js?");

/***/ }),

/***/ "./src/avo/story/examples/example-story.js":
/*!*************************************************!*\
  !*** ./src/avo/story/examples/example-story.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ExampleStory)\n/* harmony export */ });\n/* harmony import */ var _story__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../story */ \"./src/avo/story/story.js\");\n/* harmony import */ var _avo_image_asset_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @avo/image-asset.js */ \"./src/avo/image-asset.js\");\n/* harmony import */ var _avo_entity_examples_hero_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @avo/entity/examples/hero.js */ \"./src/avo/entity/examples/hero.js\");\n/* harmony import */ var _avo_entity_examples_wall_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @avo/entity/examples/wall.js */ \"./src/avo/entity/examples/wall.js\");\n/* harmony import */ var _avo_entity_examples_ball_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @avo/entity/examples/ball.js */ \"./src/avo/entity/examples/ball.js\");\n/* harmony import */ var _avo_entity_examples_enemy_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @avo/entity/examples/enemy.js */ \"./src/avo/entity/examples/enemy.js\");\n/* harmony import */ var _avo_rule_examples_zelda_controls_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @avo/rule/examples/zelda-controls.js */ \"./src/avo/rule/examples/zelda-controls.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && \"function\" == typeof p ? function (t) { return p.apply(e, t); } : p; }\nfunction _get() { return _get = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }\nfunction _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n\n\n\n\n\n\n\nvar ExampleStory = /*#__PURE__*/function (_Story) {\n  function ExampleStory(app) {\n    var _this;\n    _classCallCheck(this, ExampleStory);\n    _this = _callSuper(this, ExampleStory, [app]);\n    _this.assets = {\n      \"hero-4dir\": new _avo_image_asset_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]('assets/avo-sprites-2022-05-samiel.png')\n    };\n    return _this;\n  }\n  _inherits(ExampleStory, _Story);\n  return _createClass(ExampleStory, [{\n    key: \"start\",\n    value: function start() {\n      _superPropGet(ExampleStory, \"start\", this, 3)([]);\n      this.generate_zelda_default();\n    }\n\n    /*\r\n    Default top-down adventure level.\r\n     */\n  }, {\n    key: \"generate_zelda_default\",\n    value: function generate_zelda_default() {\n      var app = this._app;\n      app.hero = app.addEntity(new _avo_entity_examples_hero_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](app, 11, 1));\n      app.camera.target = app.hero;\n      app.addRule(new _avo_rule_examples_zelda_controls_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](app));\n      app.addEntity(new _avo_entity_examples_wall_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](app, 0, 0, 1, 23)); // West Wall\n      app.addEntity(new _avo_entity_examples_wall_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](app, 22, 0, 1, 23)); // East Wall\n      app.addEntity(new _avo_entity_examples_wall_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](app, 1, 0, 21, 1)); // North Wall\n      app.addEntity(new _avo_entity_examples_wall_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](app, 1, 22, 21, 1)); // South Wall\n      app.addEntity(new _avo_entity_examples_wall_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](app, 3, 2, 3, 1));\n      app.addEntity(new _avo_entity_examples_wall_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](app, 3, 4, 3, 1));\n      app.addEntity(new _avo_entity_examples_ball_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"](app, 8, 6));\n      var enemy = app.addEntity(new _avo_entity_examples_enemy_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"](app, 4, 8));\n      enemy.rotation = -45 / 180 * Math.PI;\n    }\n  }]);\n}(_story__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n\n//# sourceURL=webpack://cny2026/./src/avo/story/examples/example-story.js?");

/***/ }),

/***/ "./src/avo/story/index.js":
/*!********************************!*\
  !*** ./src/avo/story/index.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _story_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./story.js */ \"./src/avo/story/story.js\");\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_story_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n//# sourceURL=webpack://cny2026/./src/avo/story/index.js?");

/***/ }),

/***/ "./src/avo/story/story.js":
/*!********************************!*\
  !*** ./src/avo/story/story.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Story)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar Story = /*#__PURE__*/function () {\n  function Story(app) {\n    _classCallCheck(this, Story);\n    this._app = app;\n    this.assets = {};\n  }\n\n  /*\r\n  Section: Main Scripts\r\n  ----------------------------------------------------------------------------\r\n   */\n  return _createClass(Story, [{\n    key: \"start\",\n    value: function start() {\n      this.reset();\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      var app = this._app;\n      app.hero = undefined;\n      app.clearEntities();\n      app.resetGameMap();\n      app.clearRules();\n      app.resetCamera();\n      app.resetPlayerInput();\n      app.setInteractionMenu(false);\n    }\n  }, {\n    key: \"reload\",\n    value: function reload() {\n      this.start();\n    }\n  }]);\n}();\n\n\n//# sourceURL=webpack://cny2026/./src/avo/story/story.js?");

/***/ }),

/***/ "./src/avo/tile/index.js":
/*!*******************************!*\
  !*** ./src/avo/tile/index.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _tile_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tile.js */ \"./src/avo/tile/tile.js\");\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_tile_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n//# sourceURL=webpack://cny2026/./src/avo/tile/index.js?");

/***/ }),

/***/ "./src/avo/tile/tile.js":
/*!******************************!*\
  !*** ./src/avo/tile/tile.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Tile)\n/* harmony export */ });\n/* harmony import */ var _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/constants.js */ \"./src/avo/constants.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar Tile = /*#__PURE__*/function () {\n  function Tile(app) {\n    var col = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var row = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    _classCallCheck(this, Tile);\n    this._app = app;\n    this._type = 'tile';\n    this.colour = '#f0f0f0';\n    this.solid = false;\n    this.movable = false;\n    this.mass = 100;\n    this.x = 0; // This will be set by col\n    this.y = 0; // This will be set by row\n    this.col = col;\n    this.row = row;\n    this.size = _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE;\n    this.shape = _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.SHAPES.SQUARE;\n\n    // Animation\n    this.spriteSheet = undefined; // // Image object (e.g. app.assets['map'].img)\n    this.spriteSizeX = 16; // Size of each sprite on the sprite sheet\n    this.spriteSizeY = 16;\n    this.spriteScale = 2; // Scale of the sprite when paint()ed\n    this.spriteOffsetX = -8; // Offset of the sprite when paint()ed\n    this.spriteOffsetY = -8;\n  }\n  return _createClass(Tile, [{\n    key: \"play\",\n    value: function play() {\n      console.error('Tile.play() should never be called.');\n    }\n  }, {\n    key: \"paint\",\n    value: function paint(layer) {\n      var c2d = this._app.canvas2d;\n      this._app.applyCameraTransforms();\n      if (layer === _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.LAYERS.BOTTOM) {\n        c2d.fillStyle = this.colour;\n        c2d.strokeStyle = '#ffffff';\n        c2d.lineWidth = 1;\n        c2d.beginPath();\n        c2d.rect(Math.floor(this.x - this.size / 2), Math.floor(this.y - this.size / 2), this.size, this.size);\n        c2d.fill();\n        c2d.stroke();\n      }\n      this._app.undoCameraTransforms();\n    }\n\n    /*\r\n    Paint the tiles's sprite, at the tile's position.\r\n    Note: only specify values for args if you want to override the automatic\r\n    calculations.\r\n     */\n  }, {\n    key: \"paintSprite\",\n    value: function paintSprite() {\n      var _args$spriteCol, _args$spriteRow, _args$spriteScale, _args$spriteOffsetX, _args$spriteOffsetY;\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n        spriteCol: undefined,\n        spriteRow: undefined,\n        spriteOffsetX: undefined,\n        spriteOffsetY: undefined,\n        spriteScale: undefined\n      };\n      var app = this._app;\n      var c2d = app.canvas2d;\n      if (!this.spriteSheet) return;\n      app.applyCameraTransforms();\n      var srcX = ((_args$spriteCol = args === null || args === void 0 ? void 0 : args.spriteCol) !== null && _args$spriteCol !== void 0 ? _args$spriteCol : this.getSpriteCol()) * this.spriteSizeX;\n      var srcY = ((_args$spriteRow = args === null || args === void 0 ? void 0 : args.spriteRow) !== null && _args$spriteRow !== void 0 ? _args$spriteRow : this.getSpriteRow()) * this.spriteSizeY;\n      var sizeX = this.spriteSizeX;\n      var sizeY = this.spriteSizeY;\n      var scale = (_args$spriteScale = args === null || args === void 0 ? void 0 : args.spriteScale) !== null && _args$spriteScale !== void 0 ? _args$spriteScale : this.spriteScale;\n      c2d.translate(this.x, this.y);\n      c2d.scale(scale, scale);\n      var tgtX = (_args$spriteOffsetX = args === null || args === void 0 ? void 0 : args.spriteOffsetX) !== null && _args$spriteOffsetX !== void 0 ? _args$spriteOffsetX : this.spriteOffsetX;\n      var tgtY = (_args$spriteOffsetY = args === null || args === void 0 ? void 0 : args.spriteOffsetY) !== null && _args$spriteOffsetY !== void 0 ? _args$spriteOffsetY : this.spriteOffsetY;\n      c2d.drawImage(this.spriteSheet, srcX, srcY, sizeX, sizeY, tgtX, tgtY, sizeX, sizeY);\n      app.undoCameraTransforms();\n    }\n\n    /*\r\n    Section: Event Handling\r\n    ----------------------------------------------------------------------------\r\n     */\n  }, {\n    key: \"onCollision\",\n    value: function onCollision(target, collisionCorrection) {}\n\n    /*\r\n    Section: Animation\r\n    ----------------------------------------------------------------------------\r\n     */\n  }, {\n    key: \"getSpriteCol\",\n    value: function getSpriteCol() {\n      return 0;\n    }\n  }, {\n    key: \"getSpriteRow\",\n    value: function getSpriteRow() {\n      return 0;\n    }\n\n    /*\r\n    Section: Map Logic\r\n    ----------------------------------------------------------------------------\r\n     */\n\n    /*\r\n    Checks if this tile has similar neighbour tiles. Returns an integer from 0 to\r\n    15, that indicates on which directions (NESW) that there's a similar tile.\r\n    (e.g. a return value of 3 indicates there's a tile similar to this tile on the\r\n    NORTH, and another one on the EAST. the See TILE_ADJACENCIES for details.)\r\n    This function is usually used to see if a map tile should be \"contiguous\" with\r\n    its neighbours.\r\n     */\n  }, {\n    key: \"checkSimilarAdjacencies\",\n    value: function checkSimilarAdjacencies() {\n      var _this$getAdjacentTile, _this$getAdjacentTile2, _this$getAdjacentTile3, _this$getAdjacentTile4;\n      var adjacencies = 0;\n      if (((_this$getAdjacentTile = this.getAdjacentTile(_avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_ADJACENCIES.NORTH)) === null || _this$getAdjacentTile === void 0 ? void 0 : _this$getAdjacentTile._type) === this._type) adjacencies += _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_ADJACENCIES.NORTH;\n      if (((_this$getAdjacentTile2 = this.getAdjacentTile(_avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_ADJACENCIES.EAST)) === null || _this$getAdjacentTile2 === void 0 ? void 0 : _this$getAdjacentTile2._type) === this._type) adjacencies += _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_ADJACENCIES.EAST;\n      if (((_this$getAdjacentTile3 = this.getAdjacentTile(_avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_ADJACENCIES.SOUTH)) === null || _this$getAdjacentTile3 === void 0 ? void 0 : _this$getAdjacentTile3._type) === this._type) adjacencies += _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_ADJACENCIES.SOUTH;\n      if (((_this$getAdjacentTile4 = this.getAdjacentTile(_avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_ADJACENCIES.WEST)) === null || _this$getAdjacentTile4 === void 0 ? void 0 : _this$getAdjacentTile4._type) === this._type) adjacencies += _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_ADJACENCIES.WEST;\n      return adjacencies;\n    }\n  }, {\n    key: \"getAdjacentTile\",\n    value: function getAdjacentTile(adjacencyDirection) {\n      var _this$_app$gameMap$ti;\n      if (!adjacencyDirection) return null;\n      var colOffset = 0,\n        rowOffset = 0;\n      switch (adjacencyDirection) {\n        case _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_ADJACENCIES.NORTH:\n          rowOffset--;\n          break;\n        case _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_ADJACENCIES.EAST:\n          colOffset++;\n          break;\n        case _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_ADJACENCIES.SOUTH:\n          rowOffset++;\n          break;\n        case _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_ADJACENCIES.WEST:\n          colOffset--;\n          break;\n      }\n      if (rowOffset === 0 && colOffset === 0) return null;\n      return (_this$_app$gameMap$ti = this._app.gameMap.tiles) === null || _this$_app$gameMap$ti === void 0 || (_this$_app$gameMap$ti = _this$_app$gameMap$ti[this.row + rowOffset]) === null || _this$_app$gameMap$ti === void 0 ? void 0 : _this$_app$gameMap$ti[this.col + colOffset];\n    }\n\n    /*\r\n    Section: Getters and Setters\r\n    ----------------------------------------------------------------------------\r\n     */\n  }, {\n    key: \"left\",\n    get: function get() {\n      return this.x - this.size / 2;\n    },\n    set: function set(val) {\n      this.x = val + this.size / 2;\n    }\n  }, {\n    key: \"right\",\n    get: function get() {\n      return this.x + this.size / 2;\n    },\n    set: function set(val) {\n      this.x = val - this.size / 2;\n    }\n  }, {\n    key: \"top\",\n    get: function get() {\n      return this.y - this.size / 2;\n    },\n    set: function set(val) {\n      this.y = val + this.size / 2;\n    }\n  }, {\n    key: \"bottom\",\n    get: function get() {\n      return this.y + this.size / 2;\n    },\n    set: function set(val) {\n      this.y = val - this.size / 2;\n    }\n  }, {\n    key: \"col\",\n    get: function get() {\n      return Math.floor(this.x / _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE);\n    },\n    set: function set(val) {\n      this.x = val * _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE + _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE / 2;\n    }\n  }, {\n    key: \"row\",\n    get: function get() {\n      return Math.floor(this.y / _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE);\n    },\n    set: function set(val) {\n      this.y = val * _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE + _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE / 2;\n    }\n  }, {\n    key: \"vertices\",\n    get: function get() {\n      return [{\n        x: this.left,\n        y: this.top\n      }, {\n        x: this.right,\n        y: this.top\n      }, {\n        x: this.right,\n        y: this.bottom\n      }, {\n        x: this.left,\n        y: this.bottom\n      }];\n    },\n    set: function set(val) {\n      console.error('ERROR: Tile.vertices is read only');\n    }\n  }, {\n    key: \"segments\",\n    get: function get() {\n      var vertices = this.vertices;\n      if (vertices.length < 2) return [];\n      return vertices.map(function (vertex1, i) {\n        var vertex2 = vertices[(i + 1) % vertices.length];\n        return {\n          start: {\n            x: vertex1.x,\n            y: vertex1.y\n          },\n          end: {\n            x: vertex2.x,\n            y: vertex2.y\n          }\n        };\n      });\n    },\n    set: function set(val) {\n      console.error('ERROR: Tile.segments is read only');\n    }\n  }]);\n}();\n\n\n//# sourceURL=webpack://cny2026/./src/avo/tile/tile.js?");

/***/ }),

/***/ "./src/cny2026/cny2026.js":
/*!********************************!*\
  !*** ./src/cny2026/cny2026.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ CNY2026)\n/* harmony export */ });\n/* harmony import */ var _avo_story__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/story */ \"./src/avo/story/index.js\");\n/* harmony import */ var _avo_image_asset_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @avo/image-asset.js */ \"./src/avo/image-asset.js\");\n/* harmony import */ var _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @avo/constants.js */ \"./src/avo/constants.js\");\n/* harmony import */ var _entities_hero_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./entities/hero.js */ \"./src/cny2026/entities/hero.js\");\n/* harmony import */ var _entities_passenger_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./entities/passenger.js */ \"./src/cny2026/entities/passenger.js\");\n/* harmony import */ var _entities_drop_off_zone_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./entities/drop-off-zone.js */ \"./src/cny2026/entities/drop-off-zone.js\");\n/* harmony import */ var _tiles_floor_tile__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./tiles/floor-tile */ \"./src/cny2026/tiles/floor-tile.js\");\n/* harmony import */ var _tiles_wall_tile_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./tiles/wall-tile.js */ \"./src/cny2026/tiles/wall-tile.js\");\n/* harmony import */ var _rules_player_controls_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./rules/player-controls.js */ \"./src/cny2026/rules/player-controls.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && \"function\" == typeof p ? function (t) { return p.apply(e, t); } : p; }\nfunction _get() { return _get = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }\nfunction _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n\n\n\n\n\n\n\n\n\nvar CNY2026 = /*#__PURE__*/function (_Story) {\n  function CNY2026(app) {\n    var _this;\n    _classCallCheck(this, CNY2026);\n    _this = _callSuper(this, CNY2026, [app]);\n    _this.assets = {\n      // \"hero\": new ImageAsset('assets/avo-sprites-2024-08-samiel.png'),\n      \"map\": new _avo_image_asset_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]('assets/avo-sprites-2025-03-map-tiles.png')\n    };\n    return _this;\n  }\n  _inherits(CNY2026, _Story);\n  return _createClass(CNY2026, [{\n    key: \"start\",\n    value: function start() {\n      _superPropGet(CNY2026, \"start\", this, 3)([]);\n      this.load_first_scene();\n    }\n  }, {\n    key: \"load_first_scene\",\n    value: function load_first_scene() {\n      var app = this._app;\n\n      // Setup rules\n      app.addRule(new _rules_player_controls_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"](app));\n\n      // Setup map\n      app.gameMap.tiles = [];\n      app.gameMap.width = 25;\n      app.gameMap.height = 25;\n      var MAP_STRING = \"\\n      #########################\\n      #.......................#\\n      #.......................#\\n      #.......................#\\n      #.......................#\\n      #.......................#\\n      #.......................#\\n      #.......................#\\n      #.......................#\\n      #.......................#\\n      #.......................#\\n      #.......................#\\n      #.......................#\\n      #.......................#\\n      #.......................#\\n      #.......................#\\n      #.......................#\\n      #.......................#\\n      #.......................#\\n      #.......................#\\n      #.......................#\\n      #.......................#\\n      #.......................#\\n      #.......................#\\n      #########################\\n    \".replace(/\\s/g, '');\n\n      // Create map based on map string\n      for (var row = 0; row < app.gameMap.height; row++) {\n        app.gameMap.tiles.push([]);\n        for (var col = 0; col < app.gameMap.width; col++) {\n          var tileType = MAP_STRING[row * app.gameMap.width + col];\n          if (tileType === '#') {\n            var tile = new _tiles_wall_tile_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](app, col, row);\n            app.gameMap.tiles[row].push(tile);\n          } else {\n            var _tile = new _tiles_floor_tile__WEBPACK_IMPORTED_MODULE_6__[\"default\"](app, col, row);\n            app.gameMap.tiles[row].push(_tile);\n          }\n        }\n      }\n\n      // Pretty up map tiles.\n      // For each wall tile, check adjacencies, then make walls look contiguous.\n      for (var _row = 0; _row < app.gameMap.height; _row++) {\n        for (var _col = 0; _col < app.gameMap.width; _col++) {\n          var _tile2 = app.gameMap.tiles[_row][_col];\n          if ((_tile2 === null || _tile2 === void 0 ? void 0 : _tile2._type) === 'wall-tile') {\n            var similarAdjacencies = _tile2.checkSimilarAdjacencies();\n\n            // On our avo-sprites-2025-03-map-tiles.png sprite sheet, the ceiling\n            // tiles are laid out in a 4x4 pattern.\n            _tile2.ceilingSpriteCol = similarAdjacencies % 4;\n            _tile2.ceilingSpriteRow = Math.floor(similarAdjacencies / 4);\n\n            // On our avo-sprites-2025-03-map-tiles.png sprite sheet, the wall\n            // tiles are laid out in a 1x4 pattern. btw, we're using bitwise\n            // operators here! (&, not &&)\n            _tile2.wallSpriteCol = 0;\n            if (similarAdjacencies & _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.TILE_ADJACENCIES.EAST) _tile2.wallSpriteCol += 1;\n            if (similarAdjacencies & _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.TILE_ADJACENCIES.WEST) _tile2.wallSpriteCol += 2;\n          }\n        }\n      }\n\n      // Add Hero\n      app.hero = app.addEntity(new _entities_hero_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](app, 12, 12));\n      app.hero.rotation = _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.ROTATIONS.NORTH;\n      app.camera.target = app.hero;\n\n      // Add other entities\n      app.addEntity(new _entities_passenger_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"](app, 15, 15));\n      app.addEntity(new _entities_drop_off_zone_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"](app, 9, 15));\n    }\n  }]);\n}(_avo_story__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n\n//# sourceURL=webpack://cny2026/./src/cny2026/cny2026.js?");

/***/ }),

/***/ "./src/cny2026/entities/drop-off-zone.js":
/*!***********************************************!*\
  !*** ./src/cny2026/entities/drop-off-zone.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ DropOffZone)\n/* harmony export */ });\n/* harmony import */ var _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/constants.js */ \"./src/avo/constants.js\");\n/* harmony import */ var _avo_entity_entity_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @avo/entity/entity.js */ \"./src/avo/entity/entity.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && \"function\" == typeof p ? function (t) { return p.apply(e, t); } : p; }\nfunction _get() { return _get = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }\nfunction _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n\n\nvar DropOffZone = /*#__PURE__*/function (_Entity) {\n  function DropOffZone(app) {\n    var _this;\n    var col = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var row = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    _classCallCheck(this, DropOffZone);\n    _this = _callSuper(this, DropOffZone, [app]);\n    _this._type = 'drop-off-zone';\n    _this.colour = '#e0e080';\n    _this.col = col;\n    _this.row = row;\n    _this.size = _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE * 2;\n    _this.solid = false;\n    return _this;\n  }\n\n  /*\r\n  Section: General Logic\r\n  ----------------------------------------------------------------------------\r\n   */\n  _inherits(DropOffZone, _Entity);\n  return _createClass(DropOffZone, [{\n    key: \"play\",\n    value: function play() {\n      _superPropGet(DropOffZone, \"play\", this, 3)([]);\n    }\n  }, {\n    key: \"paint\",\n    value: function paint() {\n      var layer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      _superPropGet(DropOffZone, \"paint\", this, 3)([layer]);\n      this.paintShadow(layer);\n    }\n  }]);\n}(_avo_entity_entity_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n\n\n//# sourceURL=webpack://cny2026/./src/cny2026/entities/drop-off-zone.js?");

/***/ }),

/***/ "./src/cny2026/entities/hero.js":
/*!**************************************!*\
  !*** ./src/cny2026/entities/hero.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Hero)\n/* harmony export */ });\n/* harmony import */ var _avo_entity_types_creature_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/entity/types/creature.js */ \"./src/avo/entity/types/creature.js\");\n/* harmony import */ var _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @avo/constants.js */ \"./src/avo/constants.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && \"function\" == typeof p ? function (t) { return p.apply(e, t); } : p; }\nfunction _get() { return _get = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }\nfunction _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n/*\r\nHero\r\nThe Hero is a horse that goes around picking up Passengers and dropping them off\r\nat their destination Drop Off Zones.\r\n */\n\n\n\nvar INVULNERABILITY_WINDOW = 3000;\nvar MOVE_ACTION_CYCLE_DURATION = 500;\nvar MAX_CHARGING_POWER = 1000;\nvar Hero = /*#__PURE__*/function (_Creature) {\n  function Hero(app) {\n    var _this;\n    var col = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var row = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    _classCallCheck(this, Hero);\n    _this = _callSuper(this, Hero, [app]);\n    _this._type = 'hero';\n    _this.colour = '#c04040';\n    _this.col = col;\n    _this.row = row;\n    _this.intent = undefined;\n    _this.action = undefined;\n    _this.spriteSheet = undefined;\n    _this.spriteSizeX = 24;\n    _this.spriteSizeY = 24;\n    _this.spriteScale = 2;\n    _this.spriteOffsetX = -12;\n    _this.spriteOffsetY = -18;\n    _this.spriteFlipEastToWest = true;\n\n    // this.health = 3\n    // this.invulnerability = 0  // Invulnerability time\n\n    // Physics: make the horse really fast and a bit hard to control.\n    _this._moveAcceleration = 0.8;\n    _this._moveDeceleration = 0.1;\n    _this._moveMaxSpeed = 8;\n    _this._pushDeceleration = 0.2;\n    _this._pushMaxSpeed = 32;\n\n    // Gameplay\n    _this.passenger = undefined;\n    return _this;\n  }\n\n  /*\r\n  Section: General Logic\r\n  ----------------------------------------------------------------------------\r\n   */\n  _inherits(Hero, _Creature);\n  return _createClass(Hero, [{\n    key: \"play\",\n    value: function play() {\n      _superPropGet(Hero, \"play\", this, 3)([]);\n      this.processIntent();\n      this.processAction();\n      this.doMaxSpeedLimit();\n\n      // Count down invulnerability time\n      if (this.invulnerability > 0) {\n        this.invulnerability = Math.max(this.invulnerability - _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.FRAME_DURATION, 0);\n      }\n\n      // If carrying a Passenger, the Passenger will be attached to the Hero.\n      var passenger = this.passenger;\n      if (passenger) {\n        passenger.x = this.x;\n        passenger.y = this.y + 2;\n      }\n    }\n  }, {\n    key: \"paint\",\n    value: function paint() {\n      var _this$action;\n      var layer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var app = this._app;\n      var c2d = app.canvas2d;\n      if (this.invulnerability > 0) {\n        // If invulnerable, flash!\n        var flash = Math.floor(this.invulnerability / 300) % 2;\n        if (flash === 1) return;\n      }\n      _superPropGet(Hero, \"paint\", this, 3)([layer]);\n      this.paintShadow(layer);\n\n      // Draw the VFX\n      if (layer === _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.LAYERS.MIDDLE && ((_this$action = this.action) === null || _this$action === void 0 ? void 0 : _this$action.name) === 'charging') {\n        var _this$action2;\n        app.applyCameraTransforms();\n        var minRadius = this.size * 0.5;\n        var maxRadius = this.size * 1;\n        var range = maxRadius - minRadius;\n        var ratio = (((_this$action2 = this.action) === null || _this$action2 === void 0 ? void 0 : _this$action2.counter) || 0) / MAX_CHARGING_POWER;\n        var radius = minRadius + range * ratio / 2;\n        c2d.strokeStyle = '#ff3';\n        c2d.lineWidth = (radius - minRadius) * 2;\n        c2d.beginPath();\n        c2d.arc(this.x, this.y, radius, 0, 2 * Math.PI);\n        c2d.stroke();\n        c2d.strokeStyle = '#f33';\n        c2d.lineWidth = 2;\n        c2d.beginPath();\n        c2d.arc(this.x, this.y, maxRadius, 0, 2 * Math.PI);\n        c2d.stroke();\n        app.undoCameraTransforms();\n      }\n\n      // Draw the sprite\n      if (layer === _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.LAYERS.MIDDLE) {\n        this.paintSprite();\n      }\n    }\n\n    /*\r\n    Section: Game Logic\r\n    ----------------------------------------------------------------------------\r\n     */\n  }, {\n    key: \"applyEffect\",\n    value: function applyEffect(effect, source) {\n      _superPropGet(Hero, \"applyEffect\", this, 3)([effect, source]);\n      if (!effect) return;\n      if (effect.name === 'damage') {\n        if (this.invulnerability === 0) {\n          this.health = Math.max(this.health - 1, 0);\n          this.invulnerability = INVULNERABILITY_WINDOW;\n        }\n      }\n    }\n\n    /*\r\n    Section: Intent and Actions\r\n    ----------------------------------------------------------------------------\r\n     */\n\n    /*\r\n    Translate intent into action.\r\n     */\n  }, {\n    key: \"processIntent\",\n    value: function processIntent() {\n      // Failsafe\n      if (!this.action) this.goIdle();\n      var action = this.action;\n      var intent = this.intent;\n      if (!intent) {\n        // Go idle\n        if ((action === null || action === void 0 ? void 0 : action.name) === 'move') this.goIdle();\n      } else {\n        // Perform a new action\n        // Note: every 'move' action is considered a new action\n\n        // \"Skill\" Action:\n        // If the Entity intends to execute its \"skill\", it can only do so after\n        // it's completed (or in the middle of) \"charging up\".\n        if ((intent === null || intent === void 0 ? void 0 : intent.name) === 'skill') {\n          if ((action === null || action === void 0 ? void 0 : action.name) === 'charging') {\n            this.action = _objectSpread(_objectSpread({}, intent), {}, {\n              name: intent.name,\n              counter: 0,\n              state: undefined,\n              power: action.counter\n            });\n          }\n          return;\n        }\n\n        // All other Actions:\n        // If the Entity intends to execute a new action, it can only do so if the\n        // current action can be cancelled. (i.e. it's either \"idle\" or \"moving\".)\n        if ((action === null || action === void 0 ? void 0 : action.name) === 'idle' || (action === null || action === void 0 ? void 0 : action.name) === 'move') {\n          this.action = _objectSpread(_objectSpread({}, intent), {}, {\n            name: intent.name,\n            counter: action.name === intent.name ? action.counter : 0 // If the current action and new intent have the same name, it's just a continuation of the idle or move action, but with other new values (e.g. new directions)\n          });\n          return;\n        }\n      }\n    }\n\n    /*\r\n    Perform the action.\r\n     */\n  }, {\n    key: \"processAction\",\n    value: function processAction() {\n      if (!this.action) return;\n      var action = this.action;\n      if (action.name === 'idle') {\n\n        // Do nothing\n      } else if (action.name === 'move') {\n        var directionX = action.directionX || 0;\n        var directionY = action.directionY || 0;\n        if (!directionX && !directionY) return;\n        var moveAcceleration = this.moveAcceleration || 0;\n        var actionRotation = Math.atan2(directionY, directionX);\n        this.moveX += moveAcceleration * Math.cos(actionRotation);\n        this.moveY += moveAcceleration * Math.sin(actionRotation);\n        this.rotation = actionRotation;\n        action.counter = (action.counter + _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.FRAME_DURATION) % MOVE_ACTION_CYCLE_DURATION;\n      } else if (action.name === 'charging') {\n        action.counter = Math.min(action.counter + _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.FRAME_DURATION, MAX_CHARGING_POWER);\n      } else if (action.name === 'skill') {\n        var WINDUP_DURATION = _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.FRAME_DURATION * 5;\n        var EXECUTION_DURATION = _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.FRAME_DURATION * 2;\n        var WINDDOWN_DURATION = _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.FRAME_DURATION * 10;\n        if (!action.state) {\n          // Trigger only once, at the start of the action\n\n          // Figure out the initial direction of the dash\n          var _directionX = action.directionX || 0;\n          var _directionY = action.directionY || 0;\n          this.rotation = _directionX === 0 && _directionY === 0 ? this.rotation : Math.atan2(_directionY, _directionX);\n          action.rotation = this.rotation; // Records the initial direction of the dash\n\n          action.state = 'windup';\n        }\n        if (action.state === 'windup') {\n          action.counter += _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.FRAME_DURATION;\n          if (action.counter >= WINDUP_DURATION) {\n            action.state = 'execution';\n            action.counter = 0;\n          }\n        } else if (action.state === 'execution') {\n          var pushPower = this.size * 0.5 * ((action.power || 0) / MAX_CHARGING_POWER);\n          this.pushX += pushPower * Math.cos(action.rotation);\n          this.pushY += pushPower * Math.sin(action.rotation);\n          this.z += 4;\n          action.counter += _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.FRAME_DURATION;\n          if (action.counter >= EXECUTION_DURATION) {\n            action.state = 'winddown';\n            action.counter = 0;\n          }\n        } else if (action.state === 'winddown') {\n          action.counter += _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.FRAME_DURATION;\n          if (action.counter >= WINDDOWN_DURATION) {\n            this.goIdle();\n          }\n        }\n      } else {\n        console.error(\"[\".concat(this._type, \"] Unknown action: \").concat(action === null || action === void 0 ? void 0 : action.name));\n        this.goIdle();\n      }\n    }\n  }, {\n    key: \"goIdle\",\n    value: function goIdle() {\n      this.action = {\n        name: 'idle',\n        counter: 0\n      };\n    }\n\n    // Picks up a Passenger.\n  }, {\n    key: \"pickUp\",\n    value: function pickUp(passenger) {\n      var _this$passenger;\n      this.passenger = passenger;\n      (_this$passenger = this.passenger) === null || _this$passenger === void 0 || _this$passenger.onPickUp();\n    }\n\n    // Drops off a Passenger.\n  }, {\n    key: \"dropOff\",\n    value: function dropOff() {\n      var _this$passenger2;\n      var success = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      (_this$passenger2 = this.passenger) === null || _this$passenger2 === void 0 || _this$passenger2.onDrop(success);\n    }\n\n    /*\r\n    Section: Event Handling\r\n    ----------------------------------------------------------------------------\r\n     */\n\n    /*\r\n    Triggers when this entity hits/touches/intersects with another.\r\n     */\n  }, {\n    key: \"onCollision\",\n    value: function onCollision(target, collisionCorrection) {\n      _superPropGet(Hero, \"onCollision\", this, 3)([target, collisionCorrection]);\n      if (!target) return;\n    }\n\n    /*\r\n    Section: Physics/Getters and Setters\r\n    ----------------------------------------------------------------------------\r\n     */\n  }, {\n    key: \"moveDeceleration\",\n    get: function get() {\n      var _this$action3;\n      if (((_this$action3 = this.action) === null || _this$action3 === void 0 ? void 0 : _this$action3.name) === 'move') return 0;\n      return this._moveDeceleration;\n    }\n  }, {\n    key: \"pushDeceleration\",\n    get: function get() {\n      if (this.z > 0) return this._pushDeceleration / 2; // When jumping off the ground, it's harder to slow down \n      return this._pushDeceleration;\n    }\n  }, {\n    key: \"doBounce\",\n    value: function doBounce(target, collisionCorrection) {\n      _superPropGet(Hero, \"doBounce\", this, 3)([target, collisionCorrection]);\n\n      // If this object isn't a movable solid, it can't bounce.\n      if (!(this.movable && this.solid)) return;\n      if (\n      // this object is bouncing off an unmovable object\n      this.movable && this.solid && !target.movable && target.solid) {\n        if (this.shape === _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.SHAPES.CIRCLE && target.shape === _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.SHAPES.CIRCLE) {\n          // For circle + circle collisions, the collision correction already\n          // tells us the bounce direction.\n          var angle = Math.atan2(collisionCorrection.y - this.y, collisionCorrection.x - this.x);\n          var speed = Math.sqrt(this.moveX * this.moveX + this.moveY * this.moveY);\n          this.moveX = Math.cos(angle) * speed;\n          this.moveY = Math.sin(angle) * speed;\n        } else if (this.shape === _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.SHAPES.CIRCLE && (target.shape === _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.SHAPES.SQUARE || target.shape === _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.SHAPES.POLYGON)) {\n          // For circle + polygon collisions, we need to know...\n          // - the original angle this circle was moving towards (or rather, its\n          //   reverse, because we want a bounce)\n          // - the normal vector (of the edge) of the polygon this circle collided\n          //   into (which we can get from the collision correction)\n          // - the angle between them\n          var reverseOriginalAngle = Math.atan2(-this.moveY, -this.moveX);\n          var normalAngle = Math.atan2(collisionCorrection.y - this.y, collisionCorrection.x - this.x);\n          var angleBetween = normalAngle - reverseOriginalAngle;\n          var _angle = reverseOriginalAngle + 2 * angleBetween;\n          var _speed = Math.sqrt(this.moveX * this.moveX + this.moveY * this.moveY);\n          this.moveX = Math.cos(_angle) * _speed;\n          this.moveY = Math.sin(_angle) * _speed;\n        } else {\n          // For the moment, we're not too concerned about polygons bumping into each other\n        }\n      } else if (\n      // this object is bouncing off another movable object\n      target.movable && target.solid && collisionCorrection.moveX !== undefined && collisionCorrection.moveY !== undefined) {\n        this.moveX = collisionCorrection.moveX;\n        this.moveY = collisionCorrection.moveY;\n      }\n    }\n\n    /*\r\n    Section: Animation\r\n    ----------------------------------------------------------------------------\r\n     */\n  }, {\n    key: \"getSpriteCol\",\n    value: function getSpriteCol() {\n      switch (this.getSpriteDirection()) {\n        case _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.DIRECTIONS.NORTH:\n          return 2;\n        case _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.DIRECTIONS.EAST:\n          return 1;\n        case _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.DIRECTIONS.SOUTH:\n          return 0;\n        case _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.DIRECTIONS.WEST:\n          return 1;\n      }\n      return 0;\n    }\n  }, {\n    key: \"getSpriteRow\",\n    value: function getSpriteRow() {\n      var action = this.action;\n      if (!action) return 0;\n      if (action.name === 'move') {\n        var progress = action.counter / MOVE_ACTION_CYCLE_DURATION;\n        if (progress < 0.3) return 1;else if (progress < 0.5) return 0;else if (progress < 0.8) return 2;else if (progress < 1) return 0;\n      } else if (action.name === 'charging') {\n        return 1;\n      } else if (action.name === 'skill') {\n        if (action.state === 'windup') return 1;else if (action.state === 'execution') return 2;else if (action.state === 'winddown') return 2;\n      }\n      return 0;\n    }\n  }]);\n}(_avo_entity_types_creature_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\nfunction transformPixelsFromRedToBlue(_r, _g, _b, _a) {\n  var r = _r,\n    g = _g,\n    b = _b,\n    a = _a;\n  if (_r === 192 && _g === 64 && _b === 64) {\n    r = 64;\n    g = 128;\n    b = 192;\n  } else if (_r === 80 && _g === 64 && _b === 64) {\n    r = 32;\n    g = 32;\n    b = 96;\n  }\n  return {\n    r: r,\n    g: g,\n    b: b,\n    a: a\n  };\n}\n\n//# sourceURL=webpack://cny2026/./src/cny2026/entities/hero.js?");

/***/ }),

/***/ "./src/cny2026/entities/passenger.js":
/*!*******************************************!*\
  !*** ./src/cny2026/entities/passenger.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Passenger)\n/* harmony export */ });\n/* harmony import */ var _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/constants.js */ \"./src/avo/constants.js\");\n/* harmony import */ var _avo_entity_types_creature_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @avo/entity/types/creature.js */ \"./src/avo/entity/types/creature.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && \"function\" == typeof p ? function (t) { return p.apply(e, t); } : p; }\nfunction _get() { return _get = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }\nfunction _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n/*\r\nPassenger\r\nA Passenger is an NPC that can be picked up by the Hero, to be delivered to a\r\ndesignated Drop Off Zone.\r\n\r\nRules:\r\n- When the Hero doesn't already have an attached Passenger, and the Hero comes\r\n  within a certain radius of a Passenger, that Passenger gets attached to the\r\n  Hero.\r\n */\n\n\n\nvar PICKUP_RADIUS = _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE * 2;\nvar Passenger = /*#__PURE__*/function (_Creature) {\n  function Passenger(app) {\n    var _this;\n    var col = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var row = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    _classCallCheck(this, Passenger);\n    _this = _callSuper(this, Passenger, [app]);\n    _this._type = 'passenger';\n    _this.colour = '#c0c040';\n    _this.col = col;\n    _this.row = row;\n    _this.intent = undefined;\n    _this.action = undefined;\n    _this.spriteSheet = undefined;\n    _this.spriteSizeX = 24;\n    _this.spriteSizeY = 24;\n    _this.spriteScale = 2;\n    _this.spriteOffsetX = -12;\n    _this.spriteOffsetY = -18;\n    _this.spriteFlipEastToWest = true;\n    _this.pickedUp = false;\n    return _this;\n  }\n\n  /*\r\n  Section: General Logic\r\n  ----------------------------------------------------------------------------\r\n   */\n  _inherits(Passenger, _Creature);\n  return _createClass(Passenger, [{\n    key: \"play\",\n    value: function play() {\n      _superPropGet(Passenger, \"play\", this, 3)([]);\n      var app = this._app;\n      var hero = app.hero;\n\n      // Pick up this Passenger if Hero is nearby and available.\n      if (hero && !hero.passenger && !this.pickedUp) {\n        var distX = hero.x - this.x;\n        var distY = hero.y - this.y;\n        var dist = Math.sqrt(distY * distY + distX * distX);\n        console.log(dist);\n        if (dist <= PICKUP_RADIUS) {\n          hero.pickUp(this);\n        }\n      }\n    }\n  }, {\n    key: \"paint\",\n    value: function paint() {\n      var layer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      _superPropGet(Passenger, \"paint\", this, 3)([layer]);\n      this.paintShadow(layer);\n    }\n  }, {\n    key: \"onPickUp\",\n    value: function onPickUp(target) {\n      this.solid = false;\n      this.pickedUp = true;\n    }\n  }, {\n    key: \"onDrop\",\n    value: function onDrop() {\n      this.solid = true;\n      this.pickedUp = false;\n    }\n  }]);\n}(_avo_entity_types_creature_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n\n\n//# sourceURL=webpack://cny2026/./src/cny2026/entities/passenger.js?");

/***/ }),

/***/ "./src/cny2026/index.js":
/*!******************************!*\
  !*** ./src/cny2026/index.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _cny2026_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cny2026.js */ \"./src/cny2026/cny2026.js\");\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_cny2026_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n//# sourceURL=webpack://cny2026/./src/cny2026/index.js?");

/***/ }),

/***/ "./src/cny2026/rules/player-controls.js":
/*!**********************************************!*\
  !*** ./src/cny2026/rules/player-controls.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ PlayerControls)\n/* harmony export */ });\n/* harmony import */ var _avo_rule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/rule */ \"./src/avo/rule/index.js\");\n/* harmony import */ var _avo_physics_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @avo/physics.js */ \"./src/avo/physics.js\");\n/* harmony import */ var _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @avo/constants.js */ \"./src/avo/constants.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && \"function\" == typeof p ? function (t) { return p.apply(e, t); } : p; }\nfunction _get() { return _get = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }\nfunction _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n\n\n\n\n/*\r\nStandard player controls for top-down adventure games.\r\n */\nvar PlayerControls = /*#__PURE__*/function (_Rule) {\n  function PlayerControls(app) {\n    var _this;\n    _classCallCheck(this, PlayerControls);\n    _this = _callSuper(this, PlayerControls, [app]);\n    _this._type = 'player-controls';\n    _this.inputTap = false;\n    _this.chargeUpStart = false;\n    _this.chargeUpEnd = false;\n    _this.onKeyDown = _this.onKeyDown.bind(_this);\n    _this.onKeyUp = _this.onKeyUp.bind(_this);\n    app.addEventListener('keydown', _this.onKeyDown);\n    app.addEventListener('keyup', _this.onKeyUp);\n    _this.onPointerTap = _this.onPointerTap.bind(_this);\n    app.addEventListener('pointertap', _this.onPointerTap);\n    return _this;\n  }\n  _inherits(PlayerControls, _Rule);\n  return _createClass(PlayerControls, [{\n    key: \"deconstructor\",\n    value: function deconstructor() {\n      app.removeEventListener('keydown', this.onKeyDown);\n      app.removeEventListener('keyup', this.onKeyUp);\n      app.removeEventListener('pointertap', this.onPointerTap);\n    }\n  }, {\n    key: \"play\",\n    value: function play() {\n      var app = this._app;\n      var hero = app.hero;\n      _superPropGet(PlayerControls, \"play\", this, 3)([]);\n      if (hero) {\n        var _app$playerInput = app.playerInput,\n          keysPressed = _app$playerInput.keysPressed,\n          pointerCurrent = _app$playerInput.pointerCurrent,\n          pointerStart = _app$playerInput.pointerStart,\n          pointerState = _app$playerInput.pointerState;\n        var intent = undefined;\n        var directionX = 0;\n        var directionY = 0;\n        if (pointerState === _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.POINTER_STATES.POINTER_DOWN) {\n          // Get pointer input if there's any.\n\n          var distX = pointerCurrent.x - pointerStart.x;\n          var distY = pointerCurrent.y - pointerStart.y;\n          var pointerDistance = Math.sqrt(distX * distX + distY * distY);\n          // const movementAngle = Math.atan2(distY, distX)\n\n          if (pointerDistance > _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.POINTER_DEADZONE_RADIUS) {\n            directionX = distX / pointerDistance;\n            directionY = distY / pointerDistance;\n          }\n        } else {\n          // Otherwise, check for keyboard input.\n\n          if (keysPressed['ArrowRight']) directionX++;\n          if (keysPressed['ArrowDown']) directionY++;\n          if (keysPressed['ArrowLeft']) directionX--;\n          if (keysPressed['ArrowUp']) directionY--;\n        }\n\n        // Charge Up action\n        if (this.chargeUpStart && !this.chargeUpEnd) {\n          this.chargeUpStart = false;\n          intent = {\n            name: 'charging',\n            directionX: directionX,\n            directionY: directionY\n          };\n        } else if (this.chargeUpEnd) {\n          this.chargeUpStart = false;\n          this.chargeUpEnd = false;\n          intent = {\n            name: 'skill',\n            directionX: directionX,\n            directionY: directionY\n          };\n        }\n\n        // Move action\n        if (!intent && (directionX || directionY)) {\n          intent = {\n            name: 'move',\n            directionX: directionX,\n            directionY: directionY\n          };\n        }\n        hero.intent = intent;\n      }\n    }\n  }, {\n    key: \"paint\",\n    value: function paint() {\n      var layer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var hero = this._app.hero;\n      if (layer === _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.LAYERS.OVERLAY) {\n        this.paintUIData();\n        this.paintPointerInput();\n      } else if (layer === _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.LAYERS.BOTTOM) {\n        this.paintLineOfSight(hero);\n      }\n    }\n\n    /*\r\n    Draw UI data, such as Hero health.\r\n     */\n  }, {\n    key: \"paintUIData\",\n    value: function paintUIData() {\n      var _hero$action, _hero$action2, _hero$action4, _hero$action7;\n      var c2d = this._app.canvas2d;\n      var hero = this._app.hero;\n      var X_OFFSET = _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.TILE_SIZE * 1.5;\n      var Y_OFFSET = _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.TILE_SIZE * -1.0;\n      var LEFT = X_OFFSET;\n      var RIGHT = this._app.canvasWidth - X_OFFSET;\n      var TOP = -Y_OFFSET;\n      var BOTTOM = this._app.canvasHeight + Y_OFFSET;\n      c2d.font = '2em Source Code Pro';\n      c2d.textBaseline = 'bottom';\n      c2d.lineWidth = 8;\n      var health = Math.max(hero === null || hero === void 0 ? void 0 : hero.health, 0) || 0;\n      var text = ''.repeat(health);\n      c2d.textAlign = 'left';\n      c2d.strokeStyle = '#fff';\n      c2d.strokeText(text, LEFT, BOTTOM);\n      c2d.fillStyle = '#c04040';\n      c2d.fillText(text, LEFT, BOTTOM);\n      if ((hero === null || hero === void 0 || (_hero$action = hero.action) === null || _hero$action === void 0 ? void 0 : _hero$action.name) === 'idle' || (hero === null || hero === void 0 || (_hero$action2 = hero.action) === null || _hero$action2 === void 0 ? void 0 : _hero$action2.name) === 'move') {\n        var _hero$action3;\n        text = (hero === null || hero === void 0 || (_hero$action3 = hero.action) === null || _hero$action3 === void 0 ? void 0 : _hero$action3.name) + ' (' + (hero === null || hero === void 0 ? void 0 : hero.moveSpeed.toFixed(2)) + ')';\n      } else if ((hero === null || hero === void 0 || (_hero$action4 = hero.action) === null || _hero$action4 === void 0 ? void 0 : _hero$action4.name) === 'charging') {\n        var _hero$action5, _hero$action6;\n        text = (hero === null || hero === void 0 || (_hero$action5 = hero.action) === null || _hero$action5 === void 0 ? void 0 : _hero$action5.name) + ' (' + (hero === null || hero === void 0 || (_hero$action6 = hero.action) === null || _hero$action6 === void 0 || (_hero$action6 = _hero$action6.counter) === null || _hero$action6 === void 0 ? void 0 : _hero$action6.toFixed(0)) + ')';\n      } else if ((hero === null || hero === void 0 || (_hero$action7 = hero.action) === null || _hero$action7 === void 0 ? void 0 : _hero$action7.name) === 'skill') {\n        var _hero$action8, _hero$action9;\n        text = (hero === null || hero === void 0 || (_hero$action8 = hero.action) === null || _hero$action8 === void 0 ? void 0 : _hero$action8.name) + ' (' + (hero === null || hero === void 0 || (_hero$action9 = hero.action) === null || _hero$action9 === void 0 || (_hero$action9 = _hero$action9.power) === null || _hero$action9 === void 0 ? void 0 : _hero$action9.toFixed(0)) + ')';\n      } else {\n        var _hero$action0;\n        text = hero === null || hero === void 0 || (_hero$action0 = hero.action) === null || _hero$action0 === void 0 ? void 0 : _hero$action0.name;\n      }\n      c2d.textAlign = 'right';\n      c2d.strokeStyle = '#fff';\n      c2d.strokeText(text, RIGHT, BOTTOM);\n      c2d.fillStyle = '#c04040';\n      c2d.fillText(text, RIGHT, BOTTOM);\n    }\n\n    /*\r\n    Draw pointer input, if any. This helps players get visual feedback on their\r\n    touchscreens.\r\n     */\n  }, {\n    key: \"paintPointerInput\",\n    value: function paintPointerInput() {\n      var c2d = this._app.canvas2d;\n      var _this$_app$playerInpu = this._app.playerInput,\n        pointerCurrent = _this$_app$playerInpu.pointerCurrent,\n        pointerStart = _this$_app$playerInpu.pointerStart,\n        pointerState = _this$_app$playerInpu.pointerState;\n      var START_POINT_RADIUS = _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.TILE_SIZE * 1,\n        CURRENT_POINT_RADIUS = _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.TILE_SIZE * 0.5;\n      if (pointerState === _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.POINTER_STATES.POINTER_DOWN) {\n        c2d.lineWidth = Math.floor(Math.min(_avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.TILE_SIZE * 0.125, 2));\n        c2d.fillStyle = '#80808080';\n        c2d.strokeStyle = '#80808080';\n        c2d.beginPath();\n        c2d.arc(pointerStart.x, pointerStart.y, START_POINT_RADIUS, 0, 2 * Math.PI);\n        c2d.stroke();\n        c2d.beginPath();\n        c2d.arc(pointerCurrent.x, pointerCurrent.y, CURRENT_POINT_RADIUS, 0, 2 * Math.PI);\n        c2d.fill();\n        c2d.beginPath();\n        c2d.moveTo(pointerStart.x, pointerStart.y);\n        c2d.lineTo(pointerCurrent.x, pointerCurrent.y);\n        c2d.stroke();\n      }\n    }\n\n    /*\r\n    Draw a line of sight (cast a ray) starting from a specified Entity (usually the\r\n    hero), in the direction they're facing.\r\n     */\n  }, {\n    key: \"paintLineOfSight\",\n    value: function paintLineOfSight(srcEntity) {\n      var losMaxDistance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.TILE_SIZE * 4;\n      if (!srcEntity) return;\n      var c2d = this._app.canvas2d;\n      var entities = this._app.entities;\n      var tiles = this._app.gameMap.tiles;\n      this._app.applyCameraTransforms();\n\n      // Intended line of sight, i.e. a ray starting from the hero/source Entity.\n      var lineOfSight = {\n        start: {\n          x: srcEntity.x,\n          y: srcEntity.y\n        },\n        end: {\n          x: srcEntity.x + losMaxDistance * Math.cos(srcEntity.rotation),\n          y: srcEntity.y + losMaxDistance * Math.sin(srcEntity.rotation)\n        }\n      };\n      var lineOfSightAngle = srcEntity.rotation;\n      var actualLineOfSightEndPoint = undefined;\n\n      // For each other Entity, see if it intersects with the source Entity's LOS\n      entities.forEach(function (entity) {\n        if (entity === srcEntity) return;\n\n        // TODO: check for opaqueness and/or if the entity is visible.\n\n        // We want to cehck if the line intersects with any segment of the\n        // entity's polygonal shape (or polygon-approximated shape).\n        var segments = entity.segments;\n        segments.forEach(function (segment) {\n          // Find the intersection. We want to find the intersection point\n          // closest to the source Entity (the LOS ray's starting point).\n          var intersection = _avo_physics_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getLineIntersection(lineOfSight, segment);\n          if (!actualLineOfSightEndPoint || intersection && intersection.distanceFactor < actualLineOfSightEndPoint.distanceFactor) {\n            actualLineOfSightEndPoint = intersection;\n          }\n        });\n      });\n\n      // Check if the Entity's LOS intersects with any \"wall\" tiles\n      var losMaxDistanceInTiles = Math.ceil(losMaxDistance / _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.TILE_SIZE);\n      for (var i = 0; i <= losMaxDistanceInTiles; i++) {\n        var _tiles$row;\n        // Starting from tile the Entity's standing on, draw a line following the LOS.\n        // Check each tile that line intersects with.\n        var x = srcEntity.x + i * Math.cos(lineOfSightAngle) * _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.TILE_SIZE;\n        var y = srcEntity.y + i * Math.sin(lineOfSightAngle) * _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.TILE_SIZE;\n        var col = Math.floor(x / _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.TILE_SIZE);\n        var row = Math.floor(y / _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.TILE_SIZE);\n        var tile = tiles === null || tiles === void 0 || (_tiles$row = tiles[row]) === null || _tiles$row === void 0 ? void 0 : _tiles$row[col];\n        if (!tile || !tile.solid) continue; // Skip if there's no tile, or if the tile isn't a blocking tile (i.e. not a wall) \n\n        // Perform the same segment check as entities\n        var segments = tile.segments;\n        segments.forEach(function (segment) {\n          // Find the intersection. We want to find the intersection point\n          // closest to the source Entity (the LOS ray's starting point).\n          var intersection = _avo_physics_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getLineIntersection(lineOfSight, segment);\n          if (!actualLineOfSightEndPoint || intersection && intersection.distanceFactor < actualLineOfSightEndPoint.distanceFactor) {\n            actualLineOfSightEndPoint = intersection;\n          }\n        });\n      }\n      if (!actualLineOfSightEndPoint) {\n        actualLineOfSightEndPoint = {\n          x: srcEntity.x + losMaxDistance * Math.cos(srcEntity.rotation),\n          y: srcEntity.y + losMaxDistance * Math.sin(srcEntity.rotation)\n        };\n      }\n\n      // Expected line of sight\n      c2d.beginPath();\n      c2d.moveTo(lineOfSight.start.x, lineOfSight.start.y);\n      c2d.lineTo(lineOfSight.end.x, lineOfSight.end.y);\n      c2d.strokeStyle = '#c08080';\n      c2d.lineWidth = 3;\n      c2d.stroke();\n      c2d.setLineDash([]);\n\n      // Actual line of sight\n      c2d.beginPath();\n      c2d.moveTo(lineOfSight.start.x, lineOfSight.start.y);\n      c2d.lineTo(actualLineOfSightEndPoint.x, actualLineOfSightEndPoint.y);\n      c2d.strokeStyle = '#3399ff';\n      c2d.lineWidth = 3;\n      c2d.stroke();\n\n      // Expected end of line of sight\n      c2d.beginPath();\n      c2d.arc(lineOfSight.end.x, lineOfSight.end.y, 4, 0, 2 * Math.PI);\n      c2d.fillStyle = '#c08080';\n      c2d.fill();\n\n      // Actual end of line of sight\n      c2d.beginPath();\n      c2d.arc(actualLineOfSightEndPoint.x, actualLineOfSightEndPoint.y, 8, 0, 2 * Math.PI);\n      c2d.fillStyle = '#3399ff';\n      c2d.fill();\n      this._app.undoCameraTransforms();\n    }\n  }, {\n    key: \"onPointerTap\",\n    value: function onPointerTap() {\n      this.inputTap = true;\n    }\n  }, {\n    key: \"onKeyDown\",\n    value: function onKeyDown(_ref) {\n      var key = _ref.key;\n      var app = this._app;\n      if (key === 'z' || key === 'Z') {\n        var keyPressed = app.playerInput.keysPressed[key];\n        if (keyPressed && keyPressed.duration === 0) {\n          this.chargeUpStart = key;\n        }\n      }\n      if (key === 'p' || key === 'P') {\n        var _app$gameMap$tiles;\n        // DEBUG\n        console.log('+++ DEBUG');\n        var hero = app.hero;\n        var tile = (_app$gameMap$tiles = app.gameMap.tiles) === null || _app$gameMap$tiles === void 0 || (_app$gameMap$tiles = _app$gameMap$tiles[hero === null || hero === void 0 ? void 0 : hero.row]) === null || _app$gameMap$tiles === void 0 ? void 0 : _app$gameMap$tiles[hero === null || hero === void 0 ? void 0 : hero.col];\n        console.log('+++ tile: \\n', tile === null || tile === void 0 ? void 0 : tile.checkSimilarAdjacencies());\n      }\n    }\n  }, {\n    key: \"onKeyUp\",\n    value: function onKeyUp(_ref2) {\n      var key = _ref2.key;\n      if (key === 'z' || key === 'Z') {\n        this.chargeUpEnd = key;\n      }\n    }\n  }]);\n}(_avo_rule__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n\n//# sourceURL=webpack://cny2026/./src/cny2026/rules/player-controls.js?");

/***/ }),

/***/ "./src/cny2026/tiles/floor-tile.js":
/*!*****************************************!*\
  !*** ./src/cny2026/tiles/floor-tile.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ FloorTile)\n/* harmony export */ });\n/* harmony import */ var _avo_tile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/tile */ \"./src/avo/tile/index.js\");\n/* harmony import */ var _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @avo/constants.js */ \"./src/avo/constants.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n\n\nvar FloorTile = /*#__PURE__*/function (_Tile) {\n  function FloorTile(app) {\n    var _this;\n    var col = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var row = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    _classCallCheck(this, FloorTile);\n    _this = _callSuper(this, FloorTile, [app, col, row]);\n    _this._type = 'floor-tile';\n    _this.colour = '#f0f0f0';\n    _this.solid = false;\n    _this.spriteSheet = app.assets['map'].img;\n    _this.floorSpriteCol = 2;\n    _this.floorSpriteRow = 5;\n    return _this;\n  }\n  _inherits(FloorTile, _Tile);\n  return _createClass(FloorTile, [{\n    key: \"paint\",\n    value: function paint() {\n      var layer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      if (layer === _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.LAYERS.BOTTOM) {\n        this.paintSprite({\n          spriteCol: this.floorSpriteCol,\n          spriteRow: this.floorSpriteRow\n        });\n      }\n    }\n  }]);\n}(_avo_tile__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n\n//# sourceURL=webpack://cny2026/./src/cny2026/tiles/floor-tile.js?");

/***/ }),

/***/ "./src/cny2026/tiles/wall-tile.js":
/*!****************************************!*\
  !*** ./src/cny2026/tiles/wall-tile.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ WallTile)\n/* harmony export */ });\n/* harmony import */ var _avo_tile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/tile */ \"./src/avo/tile/index.js\");\n/* harmony import */ var _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @avo/constants.js */ \"./src/avo/constants.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n\n\nvar WallTile = /*#__PURE__*/function (_Tile) {\n  function WallTile(app) {\n    var _this;\n    var col = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var row = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    _classCallCheck(this, WallTile);\n    _this = _callSuper(this, WallTile, [app, col, row]);\n    _this._type = 'wall-tile';\n    _this.colour = '#808080';\n    _this.solid = true;\n    _this.spriteSheet = app.assets['map'].img;\n    _this.ceilingSpriteCol = 0;\n    _this.ceilingSpriteRow = 0;\n    _this.wallSpriteCol = 0;\n    _this.wallSpriteRow = 4;\n    return _this;\n  }\n  _inherits(WallTile, _Tile);\n  return _createClass(WallTile, [{\n    key: \"paint\",\n    value: function paint() {\n      var layer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      if (layer === _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.LAYERS.BOTTOM) {\n        this.paintSprite({\n          spriteRow: this.wallSpriteRow,\n          spriteCol: this.wallSpriteCol\n        });\n      } else if (layer === _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.LAYERS.TOP) {\n        this.paintSprite({\n          spriteRow: this.ceilingSpriteRow,\n          spriteCol: this.ceilingSpriteCol,\n          spriteOffsetY: -24\n        });\n      }\n    }\n  }]);\n}(_avo_tile__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n\n//# sourceURL=webpack://cny2026/./src/cny2026/tiles/wall-tile.js?");

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _avo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo */ \"./src/avo/index.js\");\n/* harmony import */ var _cny2026__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cny2026 */ \"./src/cny2026/index.js\");\n\n\nwindow.onload = function () {\n  window.avo = new _avo__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n    story: _cny2026__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\n  });\n};\n\n//# sourceURL=webpack://cny2026/./src/main.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/main.js");
/******/ 	
/******/ })()
;