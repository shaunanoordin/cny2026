/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/avo/avo.js":
/*!************************!*\
  !*** ./src/avo/avo.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ AvO)\n/* harmony export */ });\n/* harmony import */ var _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/constants.js */ \"./src/avo/constants.js\");\n/* harmony import */ var _avo_physics_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @avo/physics.js */ \"./src/avo/physics.js\");\n/* harmony import */ var _avo_story_examples_example_story_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @avo/story/examples/example-story.js */ \"./src/avo/story/examples/example-story.js\");\n/* harmony import */ var _avo_interaction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @avo/interaction */ \"./src/avo/interaction/index.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n // TODO: remove, or replace with a simpler version\n\nvar searchParams = new URLSearchParams(window.location.search);\nvar DEBUG = searchParams.get('debug') || false;\nvar AvO = /*#__PURE__*/function () {\n  function AvO() {\n    var _this$story;\n    var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classCallCheck(this, AvO);\n    var _args$story = args.story,\n      story = _args$story === void 0 ? _avo_story_examples_example_story_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"] : _args$story,\n      _args$width = args.width,\n      width = _args$width === void 0 ? 24 * _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE : _args$width,\n      _args$height = args.height,\n      height = _args$height === void 0 ? 16 * _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE : _args$height;\n    this.html = {\n      main: document.getElementById('main'),\n      canvas: document.getElementById('canvas'),\n      homeMenu: document.getElementById('home-menu'),\n      interactionMenu: document.getElementById('interaction-menu'),\n      buttonHome: document.getElementById('button-home'),\n      buttonFullscreen: document.getElementById('button-fullscreen'),\n      buttonReload: document.getElementById('button-reload')\n    };\n    this.homeMenu = false;\n    this.setHomeMenu(false);\n    this.interactionMenu = false;\n    this.setInteractionMenu(false);\n    this.canvas2d = this.html.canvas.getContext('2d');\n    this.canvasWidth = width;\n    this.canvasHeight = height;\n    this._canvasHasCameraTransforms = false; // Safety check\n\n    this.camera = {\n      target: null,\n      // Target entity to follow. If null, camera is static.\n      x: 0,\n      y: 0,\n      zoom: 1\n    };\n    this.setupUI();\n    this.entities = []; // Game objects\n    this.hero = null; // Main player-controlled entity\n    this.gameMap = {\n      // Game map and environment\n      tiles: [],\n      // 2D array of map tiles\n      width: 0,\n      height: 0\n    };\n    this.rules = new Map(); // Game rules, including win/loss conditions and player controls\n\n    this.story = story ? new story(this) : undefined; // Game story, i.e. the \"container\" that describes an adventure or experience, which contains game objects and game rules and etc\n    this.assets = ((_this$story = this.story) === null || _this$story === void 0 ? void 0 : _this$story.assets) || {};\n    this.secretAssets = {};\n    this.eventListeners = {\n      'keydown': [],\n      'keyup': [],\n      'pointerdown': [],\n      'pointermove': [],\n      'pointerup': [],\n      'pointertap': [],\n      'pointerholdend': []\n    };\n    this.playerInput = {};\n    this.resetPlayerInput();\n    this.initialised = false;\n    this.timeAccumulator = 0;\n    this.prevTime = null;\n    this.nextFrame = window.requestAnimationFrame(this.main.bind(this));\n  }\n  return _createClass(AvO, [{\n    key: \"initialisationCheck\",\n    value: function initialisationCheck() {\n      var _this = this;\n      // Assets check\n      var allAssetsReady = true;\n      var numReadyAssets = 0;\n      var numTotalAssets = 0;\n      Object.keys(this.assets).forEach(function (id) {\n        var asset = _this.assets[id];\n        allAssetsReady = allAssetsReady && asset.ready;\n        if (asset.ready) numReadyAssets++;\n        numTotalAssets++;\n      });\n      Object.keys(this.secretAssets).forEach(function (id) {\n        var secretAsset = _this.secretAssets[id];\n        var secretAssetIsReady = secretAsset.ready || secretAsset.error;\n        allAssetsReady = allAssetsReady && secretAssetIsReady;\n        if (secretAssetIsReady) numReadyAssets++;\n        numTotalAssets++;\n      });\n\n      // Paint status\n      this.canvas2d.clearRect(0, 0, this.canvasWidth, this.canvasHeight);\n      this.canvas2d.textAlign = 'start';\n      this.canvas2d.textBaseline = 'top';\n      this.canvas2d.fillStyle = '#ccc';\n      this.canvas2d.font = \"1em monospace\";\n      this.canvas2d.fillText(\"Loading \".concat(numReadyAssets, \" / \").concat(numTotalAssets, \" \"), _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE, _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE);\n      if (allAssetsReady) {\n        var _this$story2;\n        // Clean up secret assets\n        Object.keys(this.secretAssets).forEach(function (id) {\n          if (_this.secretAssets[id].error) delete _this.secretAssets[id];\n        });\n\n        // Let's go!\n        this.initialised = true;\n        this.showUI();\n        (_this$story2 = this.story) === null || _this$story2 === void 0 || _this$story2.start();\n      }\n    }\n\n    /*\r\n    Section: General Logic\r\n    ----------------------------------------------------------------------------\r\n     */\n\n    /*\r\n    The main loop. Run a single frame of gameplay.\r\n    - time: the current/total time (milliseconds) since the game started.\r\n     */\n  }, {\n    key: \"main\",\n    value: function main(time) {\n      var timeStep = this.prevTime ? time - this.prevTime : time;\n      this.prevTime = time;\n      this.timeAccumulator += timeStep;\n\n      // Sanity/safety check: timeStep can be huge\n      // e.g. if player pauses game by switching windows.\n      this.timeAccumulator = Math.min(this.timeAccumulator, _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.FRAME_DURATION * 10);\n      if (this.initialised) {\n        // Keep a consistent \"frame rate\" for logic processing\n        while (this.timeAccumulator >= _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.FRAME_DURATION) {\n          this.play();\n          this.timeAccumulator -= _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.FRAME_DURATION;\n          // TODO: add safety counter to prevent excessively long while() loops.\n        }\n        // Paint whenever possible\n        this.paint();\n      } else {\n        this.initialisationCheck();\n      }\n      this.nextFrame = window.requestAnimationFrame(this.main.bind(this));\n    }\n\n    /*\r\n    Run the gameplay/physics logic for a single frame.\r\n     */\n  }, {\n    key: \"play\",\n    value: function play() {\n      var _this2 = this;\n      // If a menu is open, pause all action gameplay\n      if (this.homeMenu || this.interactionMenu) return;\n\n      // Run the action gameplay\n      // ----------------\n      this.rules.forEach(function (rule) {\n        return rule.play();\n      });\n      this.entities.forEach(function (entity) {\n        return entity.play();\n      });\n      this.checkCollisions();\n\n      // Cleanup: entities\n      this.entities.filter(function (entity) {\n        return entity._expired;\n      }).forEach(function (entity) {\n        return entity.deconstructor();\n      });\n      this.entities = this.entities.filter(function (entity) {\n        return !entity._expired;\n      });\n\n      // Cleanup: rules\n      this.rules.forEach(function (rule, id) {\n        if (rule.expired) {\n          rule.deconstructor();\n          _this2.rules[\"delete\"](id);\n        }\n      });\n\n      // Sort Entities along the y-axis, for paint()/rendering purposes.\n      // WARNING: inefficient\n      this.entities.sort(function (a, b) {\n        return a.y - b.y;\n      });\n      // ----------------\n\n      // Increment the duration of each currently pressed key\n      Object.keys(this.playerInput.keysPressed).forEach(function (key) {\n        if (_this2.playerInput.keysPressed[key]) _this2.playerInput.keysPressed[key].duration += _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.FRAME_DURATION;\n      });\n\n      // Increment the duration of the pointer being active\n      if (this.playerInput.pointerState === _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.POINTER_STATES.POINTER_DOWN) {\n        this.playerInput.pointerDownDuration += _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.FRAME_DURATION;\n      }\n    }\n\n    /*\r\n    Paint/draw the game visuals onto the canvas.\r\n     */\n  }, {\n    key: \"paint\",\n    value: function paint() {\n      var _this3 = this;\n      var c2d = this.canvas2d;\n      var camera = this.camera;\n\n      // Camera Controls: focus the camera on the target entity, if any.\n      // ----------------\n      if (camera.target) {\n        camera.x = this.canvasWidth / 2 - camera.target.x * camera.zoom;\n        camera.y = this.canvasHeight / 2 - camera.target.y * camera.zoom;\n      }\n      c2d.clearRect(0, 0, this.canvasWidth, this.canvasHeight);\n      c2d.resetTransform();\n      c2d.strokeStyle = 'rgba(128, 128, 128, 0.05)';\n      c2d.lineWidth = 2;\n      // ----------------\n\n      // Draw background grid\n      // ----------------\n      var GRID_SIZE = _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE * camera.zoom;\n      var offsetX = this.camera.x % GRID_SIZE - GRID_SIZE;\n      var offsetY = this.camera.y % GRID_SIZE - GRID_SIZE;\n      for (var y = offsetY; y < this.canvasHeight; y += GRID_SIZE) {\n        for (var x = offsetX; x < this.canvasWidth; x += GRID_SIZE) {\n          c2d.beginPath();\n          c2d.rect(x, y, GRID_SIZE, GRID_SIZE);\n          c2d.stroke();\n\n          // Debug Grid\n          if (DEBUG) {\n            c2d.fillStyle = '#ccc';\n            c2d.font = \"\".concat(camera.zoom * 0.5, \"em Source Code Pro\");\n            c2d.textAlign = 'center';\n            c2d.textBaseline = 'middle';\n            var col = Math.floor((x - this.camera.x) / GRID_SIZE);\n            var row = Math.floor((y - this.camera.y) / GRID_SIZE);\n            c2d.fillText(col + ',' + row, x + GRID_SIZE / 2, y + GRID_SIZE / 2); // using template strings here messes up colours in Brackets.\n          }\n        }\n      }\n      // ----------------\n\n      // Draw map tiles, entities, and other elements\n      // ----------------\n      var _loop = function _loop(layer) {\n        // 1. draw map tiles first, as these form the background. \n        for (var _row = 0; _row < _this3.gameMap.height; _row++) {\n          for (var _col = 0; _col < _this3.gameMap.width; _col++) {\n            var _this3$gameMap$tiles;\n            (_this3$gameMap$tiles = _this3.gameMap.tiles) === null || _this3$gameMap$tiles === void 0 || (_this3$gameMap$tiles = _this3$gameMap$tiles[_row]) === null || _this3$gameMap$tiles === void 0 || (_this3$gameMap$tiles = _this3$gameMap$tiles[_col]) === null || _this3$gameMap$tiles === void 0 || _this3$gameMap$tiles.paint(layer);\n          }\n        }\n\n        // 2. draw entities next.\n        _this3.entities.forEach(function (entity) {\n          return entity.paint(layer);\n        });\n\n        // 3. draw rules last, as these usually represent HUD visualisations.\n        _this3.rules.forEach(function (rule) {\n          return rule.paint(layer);\n        });\n      };\n      for (var layer = _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.MIN_LAYER; layer <= _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.MAX_LAYER; layer++) {\n        _loop(layer);\n      }\n      // ----------------\n    }\n\n    /*\r\n    Section: UI\r\n    ----------------------------------------------------------------------------\r\n     */\n  }, {\n    key: \"setupUI\",\n    value: function setupUI() {\n      this.html.canvas.width = this.canvasWidth;\n      this.html.canvas.height = this.canvasHeight;\n      this.canvas2d.imageSmoothingEnabled = false; /* Pixel art: Maintains sprites' pixel sharpness when scaled up via drawImage() */\n\n      if (window.PointerEvent) {\n        this.html.canvas.addEventListener('pointerdown', this.onPointerDown.bind(this));\n        this.html.canvas.addEventListener('pointermove', this.onPointerMove.bind(this));\n        this.html.canvas.addEventListener('pointerup', this.onPointerUp.bind(this));\n        this.html.canvas.addEventListener('pointercancel', this.onPointerUp.bind(this));\n      } else {\n        this.html.canvas.addEventListener('mousedown', this.onPointerDown.bind(this));\n        this.html.canvas.addEventListener('mousemove', this.onPointerMove.bind(this));\n        this.html.canvas.addEventListener('mouseup', this.onPointerUp.bind(this));\n      }\n\n      // Prevent \"touch and hold to open context menu\" menu on touchscreens.\n      this.html.canvas.addEventListener('touchstart', stopEvent);\n      this.html.canvas.addEventListener('touchmove', stopEvent);\n      this.html.canvas.addEventListener('touchend', stopEvent);\n      this.html.canvas.addEventListener('touchcancel', stopEvent);\n      this.html.buttonHome.addEventListener('click', this.buttonHome_onClick.bind(this));\n      this.html.buttonFullscreen.addEventListener('click', this.buttonFullscreen_onClick.bind(this));\n      this.html.buttonReload.addEventListener('click', this.buttonReload_onClick.bind(this));\n      this.html.main.addEventListener('keydown', this.onKeyDown.bind(this));\n      this.html.main.addEventListener('keyup', this.onKeyUp.bind(this));\n      window.addEventListener('resize', this.updateUI.bind(this));\n      this.updateUI();\n      this.hideUI(); // Hide until all assets are ready\n\n      this.html.main.focus();\n    }\n  }, {\n    key: \"hideUI\",\n    value: function hideUI() {\n      this.html.buttonHome.style.visibility = 'hidden';\n      this.html.buttonReload.style.visibility = 'hidden';\n    }\n  }, {\n    key: \"showUI\",\n    value: function showUI() {\n      this.html.buttonHome.style.visibility = 'visible';\n      this.html.buttonReload.style.visibility = 'visible';\n    }\n  }, {\n    key: \"updateUI\",\n    value: function updateUI() {\n      // Fit the interaction layers (menus, etc) to the canvas\n      var mainDivBounds = this.html.main.getBoundingClientRect();\n      var canvasBounds = this.html.canvas.getBoundingClientRect();\n      this.html.homeMenu.style.width = \"\".concat(canvasBounds.width, \"px\");\n      this.html.homeMenu.style.height = \"\".concat(canvasBounds.height, \"px\");\n      this.html.homeMenu.style.top = \"\".concat(canvasBounds.top - mainDivBounds.top, \"px\");\n      this.html.homeMenu.style.left = \"\".concat(canvasBounds.left, \"px\");\n      this.html.interactionMenu.style.width = \"\".concat(canvasBounds.width, \"px\");\n      this.html.interactionMenu.style.height = \"\".concat(canvasBounds.height, \"px\");\n      this.html.interactionMenu.style.top = \"\".concat(canvasBounds.top - mainDivBounds.top, \"px\");\n      this.html.interactionMenu.style.left = \"\".concat(canvasBounds.left, \"px\");\n    }\n  }, {\n    key: \"setHomeMenu\",\n    value: function setHomeMenu(homeMenu) {\n      this.homeMenu = homeMenu;\n      if (homeMenu) {\n        this.html.homeMenu.style.visibility = 'visible';\n        this.html.buttonReload.style.visibility = 'hidden';\n      } else {\n        this.html.homeMenu.style.visibility = 'hidden';\n        this.html.buttonReload.style.visibility = 'visible';\n        this.html.main.focus();\n      }\n    }\n  }, {\n    key: \"setInteractionMenu\",\n    value: function setInteractionMenu(interactionMenu) {\n      var div = this.html.interactionMenu;\n      this.interactionMenu && this.interactionMenu.unload(); // Unload the old menu, if any\n      this.interactionMenu = interactionMenu; // Set the new menu\n\n      if (interactionMenu) {\n        while (div.firstChild) {\n          div.removeChild(div.firstChild);\n        } // Clear div\n        interactionMenu.load(div); // load the new menu\n        div.style.visibility = 'visible';\n      } else {\n        div.style.visibility = 'hidden';\n        this.html.main.focus();\n      }\n    }\n\n    /*\r\n    Section: Event Handling\r\n    ----------------------------------------------------------------------------\r\n     */\n  }, {\n    key: \"addEventListener\",\n    value: function addEventListener(eventName, listener) {\n      var _this$eventListeners;\n      (_this$eventListeners = this.eventListeners) === null || _this$eventListeners === void 0 || (_this$eventListeners = _this$eventListeners[eventName]) === null || _this$eventListeners === void 0 || _this$eventListeners.push(listener);\n    }\n  }, {\n    key: \"removeEventListener\",\n    value: function removeEventListener(eventName, listener) {\n      var _this$eventListeners2, _this$eventListeners3;\n      if (!((_this$eventListeners2 = this.eventListeners) !== null && _this$eventListeners2 !== void 0 && _this$eventListeners2[eventName])) return;\n      this.eventListeners[eventName] = (_this$eventListeners3 = this.eventListeners) === null || _this$eventListeners3 === void 0 ? void 0 : _this$eventListeners3[eventName].filter(function (l) {\n        return l !== listener;\n      });\n    }\n  }, {\n    key: \"broadcastEvent\",\n    value: function broadcastEvent(eventName, args) {\n      var _this$eventListeners4;\n      (_this$eventListeners4 = this.eventListeners) === null || _this$eventListeners4 === void 0 || (_this$eventListeners4 = _this$eventListeners4[eventName]) === null || _this$eventListeners4 === void 0 || _this$eventListeners4.forEach(function (eventHandler) {\n        eventHandler(args);\n      });\n    }\n  }, {\n    key: \"onPointerDown\",\n    value: function onPointerDown(e) {\n      var coords = getEventCoords(e, this.html.canvas);\n\n      // Initialise\n      this.playerInput.pointerState = _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.POINTER_STATES.POINTER_DOWN;\n      this.playerInput.pointerStart = coords;\n      this.playerInput.pointerCurrent = coords;\n      this.playerInput.pointerEnd = undefined;\n      this.playerInput.pointerTapOrHold = true;\n      this.playerInput.pointerDownDuration = 0;\n      this.html.main.focus();\n      this.broadcastEvent('pointerdown', {\n        coords: coords\n      });\n      return stopEvent(e);\n    }\n  }, {\n    key: \"onPointerMove\",\n    value: function onPointerMove(e) {\n      var coords = getEventCoords(e, this.html.canvas);\n      this.playerInput.pointerCurrent = coords;\n\n      // If the pointer never moves far from the initial position, then the\n      // pointer interaction is considered a tap or hold.\n      if (this.playerInput.pointerState === _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.POINTER_STATES.POINTER_DOWN && this.playerInput.pointerTapOrHold) {\n        var distX = this.playerInput.pointerCurrent.x - this.playerInput.pointerStart.x;\n        var distY = this.playerInput.pointerCurrent.y - this.playerInput.pointerStart.y;\n        var pointerDistance = Math.sqrt(distX * distX + distY * distY);\n        if (pointerDistance > _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.POINTER_DEADZONE_RADIUS) {\n          this.playerInput.pointerTapOrHold = false;\n        }\n      }\n      this.broadcastEvent('pointermove', {\n        coords: coords\n      });\n      return stopEvent(e);\n    }\n  }, {\n    key: \"onPointerUp\",\n    value: function onPointerUp(e) {\n      var coords = getEventCoords(e, this.html.canvas);\n      if (this.playerInput.pointerState === _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.POINTER_STATES.POINTER_DOWN) {\n        this.playerInput.pointerEnd = coords;\n        this.playerInput.pointerState = _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.POINTER_STATES.IDLE;\n\n        // Is the pointer action a tap or hold action?\n        if (this.playerInput.pointerTapOrHold) {\n          if (this.playerInput.pointerDownDuration <= _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.POINTER_TAP_DURATION) {\n            this.broadcastEvent('pointertap', {\n              coords: coords\n            });\n          } else {\n            this.broadcastEvent('pointerholdend', {\n              coords: coords,\n              duration: this.playerInput.pointerDownDuration\n            });\n          }\n        }\n      }\n      this.broadcastEvent('pointerup', {\n        coords: coords\n      });\n      return stopEvent(e);\n    }\n  }, {\n    key: \"onKeyDown\",\n    value: function onKeyDown(e) {\n      // Special cases\n      switch (e.key) {\n        // Open home menu\n        case 'Escape':\n          this.setHomeMenu(!this.homeMenu);\n          break;\n\n        // DEBUG\n        case 'x':\n        case 'X':\n          if (!this.interactionMenu) {\n            this.setInteractionMenu(new _avo_interaction__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this));\n          }\n          break;\n        case '-':\n        case '_':\n          this.camera.zoom = Math.max(0.5, this.camera.zoom - 0.5);\n          break;\n        case '+':\n        case '=':\n          this.camera.zoom = Math.min(4, this.camera.zoom + 0.5);\n          break;\n      }\n\n      // General input\n      if (!this.playerInput.keysPressed[e.key]) {\n        this.playerInput.keysPressed[e.key] = {\n          duration: 0,\n          acknowledged: false\n        };\n      }\n      this.broadcastEvent('keydown', {\n        key: e.key\n      });\n    }\n  }, {\n    key: \"onKeyUp\",\n    value: function onKeyUp(e) {\n      var _this$playerInput$key;\n      var duration = ((_this$playerInput$key = this.playerInput.keysPressed[e.key]) === null || _this$playerInput$key === void 0 ? void 0 : _this$playerInput$key.duration) || 0;\n      this.playerInput.keysPressed[e.key] = undefined;\n      this.broadcastEvent('keyup', {\n        key: e.key,\n        duration: duration\n      });\n    }\n  }, {\n    key: \"buttonHome_onClick\",\n    value: function buttonHome_onClick() {\n      this.setHomeMenu(!this.homeMenu);\n    }\n  }, {\n    key: \"buttonFullscreen_onClick\",\n    value: function buttonFullscreen_onClick() {\n      var _this4 = this;\n      var isFullscreen = document.fullscreenElement;\n      if (!isFullscreen) {\n        if (this.html.main.requestFullscreen) {\n          this.html.main.requestFullscreen().then(function () {\n            _this4.html.main.className = 'fullscreen';\n            _this4.updateUI();\n          })[\"catch\"](function (err) {\n            console.error('requestFullscreen() error: ', err);\n          });\n        }\n      } else {\n        var _document$exitFullscr, _document;\n        (_document$exitFullscr = (_document = document).exitFullscreen) === null || _document$exitFullscr === void 0 || _document$exitFullscr.call(_document).then(function () {\n          _this4.html.main.className = '';\n          _this4.updateUI();\n        })[\"catch\"](function (err) {\n          console.error('exitFullscreen() error: ', err);\n        });\n      }\n    }\n  }, {\n    key: \"buttonReload_onClick\",\n    value: function buttonReload_onClick() {\n      var _this$story3;\n      (_this$story3 = this.story) === null || _this$story3 === void 0 || _this$story3.reload();\n    }\n\n    /*\r\n    Section: Gameplay\r\n    ----------------------------------------------------------------------------\r\n     */\n  }, {\n    key: \"addEntity\",\n    value: function addEntity(entity) {\n      if (!entity) return null;\n      if (!this.entities.includes(entity)) this.entities.push(entity);\n      return entity;\n    }\n  }, {\n    key: \"removeEntity\",\n    value: function removeEntity(entityOrMatchingFn) {\n      if (!entityOrMatchingFn) return;\n      if (typeof entityOrMatchingFn === 'function') {\n        this.entities.filter(entityOrMatchingFn).forEach(function (entity) {\n          entity._expired = true;\n        });\n      } else if (this.entities.includes(entityOrMatchingFn)) {\n        entityOrMatchingFn._expired = true;\n      }\n    }\n  }, {\n    key: \"clearEntities\",\n    value: function clearEntities() {\n      this.entities.forEach(function (entity) {\n        return entity.deconstructor();\n      });\n      this.entities = [];\n    }\n  }, {\n    key: \"resetGameMap\",\n    value: function resetGameMap() {\n      // TODO: do tiles need to be deconstructed?\n      this.gameMap = {\n        // Game map and environment\n        tiles: [],\n        // 2D array of map tiles\n        width: 0,\n        height: 0\n      };\n    }\n  }, {\n    key: \"addRule\",\n    value: function addRule(rule) {\n      if (!rule) return;\n      var id = rule._type;\n      this.rules.set(id, rule);\n    }\n  }, {\n    key: \"clearRules\",\n    value: function clearRules() {\n      var _this5 = this;\n      this.rules.forEach(function (rule, id) {\n        rule.deconstructor();\n        _this5.rules[\"delete\"](id);\n      });\n    }\n  }, {\n    key: \"resetCamera\",\n    value: function resetCamera() {\n      this.camera = {\n        target: null,\n        x: 0,\n        y: 0,\n        zoom: 1\n      };\n    }\n\n    /*\r\n    Section: Painting\r\n    ----------------------------------------------------------------------------\r\n     */\n\n    /*\r\n    Applies camera transforms to the canvas.\r\n    Should be run right before drawing an Entity (or etc) so the object is drawn\r\n    relative to the camera's view.\r\n     */\n  }, {\n    key: \"applyCameraTransforms\",\n    value: function applyCameraTransforms() {\n      if (this._canvasHasCameraTransforms) throw new Error('Canvas already has camera transforms.');\n      this._canvasHasCameraTransforms = true;\n      var c2d = this.canvas2d;\n      var camera = this.camera;\n      c2d.save();\n      c2d.translate(camera.x, camera.y);\n      c2d.scale(camera.zoom, camera.zoom);\n    }\n\n    /*\r\n    Removes camera transforms from the canvas.\r\n     */\n  }, {\n    key: \"undoCameraTransforms\",\n    value: function undoCameraTransforms() {\n      if (!this._canvasHasCameraTransforms) throw new Error('Canvas doesn\\'t have camera transforms.');\n      this._canvasHasCameraTransforms = false;\n      this.canvas2d.restore();\n    }\n\n    /*\r\n    Section: Misc\r\n    ----------------------------------------------------------------------------\r\n     */\n  }, {\n    key: \"checkCollisions\",\n    value: function checkCollisions() {\n      for (var a = 0; a < this.entities.length; a++) {\n        var entityA = this.entities[a];\n        for (var b = a + 1; b < this.entities.length; b++) {\n          var entityB = this.entities[b];\n          var collisionCorrection = _avo_physics_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].checkCollision(entityA, entityB);\n          if (collisionCorrection) {\n            entityA.onCollision(entityB, collisionCorrection.a);\n            entityB.onCollision(entityA, collisionCorrection.b);\n          }\n        }\n        var range = Math.ceil(entityA.size / _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE);\n        for (var row = entityA.row - range; row <= entityA.row + range; row++) {\n          for (var col = entityA.col - range; col <= entityA.col + range; col++) {\n            var _this$gameMap$tiles;\n            var tile = (_this$gameMap$tiles = this.gameMap.tiles) === null || _this$gameMap$tiles === void 0 || (_this$gameMap$tiles = _this$gameMap$tiles[row]) === null || _this$gameMap$tiles === void 0 ? void 0 : _this$gameMap$tiles[col];\n            var _collisionCorrection = _avo_physics_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].checkCollision(entityA, tile);\n            if (_collisionCorrection) {\n              entityA.onCollision(tile, _collisionCorrection.a);\n              tile.onCollision(entityA, _collisionCorrection.b);\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: \"resetPlayerInput\",\n    value: function resetPlayerInput() {\n      this.playerInput = {\n        // Pointer (mouse/touchscreen) input\n        // pointerStart/pointerCurrent/pointerEnd = { x, y } \n        pointerState: _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.POINTER_STATES.IDLE,\n        pointerStart: undefined,\n        pointerCurrent: undefined,\n        pointerEnd: undefined,\n        // Pointer metadata\n        pointerTapOrHold: true,\n        // A pointer interaction is a tap or hold if the pointer never travels far from its initial position (i.e. never left the deadzone).\n        pointerDownDuration: 0,\n        // Keyboard input\n        // keysPressed = { key: { duration, acknowledged } }\n        keysPressed: {}\n      };\n    }\n  }]);\n}();\n\nfunction getEventCoords(event, element) {\n  var xRatio = element.width && element.offsetWidth ? element.width / element.offsetWidth : 1;\n  var yRatio = element.height && element.offsetHeight ? element.height / element.offsetHeight : 1;\n  var x = event.offsetX * xRatio;\n  var y = event.offsetY * yRatio;\n  return {\n    x: x,\n    y: y\n  };\n}\nfunction stopEvent(e) {\n  if (!e) return false;\n  e.preventDefault && e.preventDefault();\n  e.stopPropagation && e.stopPropagation();\n  e.returnValue = false;\n  e.cancelBubble = true;\n  return false;\n}\n\n//# sourceURL=webpack://cny2026/./src/avo/avo.js?");

/***/ }),

/***/ "./src/avo/constants.js":
/*!******************************!*\
  !*** ./src/avo/constants.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DIRECTIONS: () => (/* binding */ DIRECTIONS),\n/* harmony export */   FRAMES_PER_SECOND: () => (/* binding */ FRAMES_PER_SECOND),\n/* harmony export */   FRAME_DURATION: () => (/* binding */ FRAME_DURATION),\n/* harmony export */   LAYERS: () => (/* binding */ LAYERS),\n/* harmony export */   MAX_LAYER: () => (/* binding */ MAX_LAYER),\n/* harmony export */   MIN_LAYER: () => (/* binding */ MIN_LAYER),\n/* harmony export */   POINTER_DEADZONE_RADIUS: () => (/* binding */ POINTER_DEADZONE_RADIUS),\n/* harmony export */   POINTER_STATES: () => (/* binding */ POINTER_STATES),\n/* harmony export */   POINTER_TAP_DURATION: () => (/* binding */ POINTER_TAP_DURATION),\n/* harmony export */   ROTATIONS: () => (/* binding */ ROTATIONS),\n/* harmony export */   SHAPES: () => (/* binding */ SHAPES),\n/* harmony export */   TILE_ADJACENCIES: () => (/* binding */ TILE_ADJACENCIES),\n/* harmony export */   TILE_SIZE: () => (/* binding */ TILE_SIZE)\n/* harmony export */ });\n/*\r\nSection: General\r\n--------------------------------------------------------------------------------\r\n */\n\n/*\r\nAs a sprite-based game engine, we think of in-game space in terms of \"tiles\" (or\r\n\"map tiles\"). Each map tile is 32x32 pixels, and standard in-game objects should\r\nmore or less fit exactly one map tile.  \r\n */\nvar TILE_SIZE = 32;\n\n/*\r\nWe use a constant frame rate to make calculations in our game logic much easier.\r\ne.g. we can say that we expect an object with \"movement speed\" of \"2\" to travel\r\n120 pixels in 1 second. (2 pixels per frame * 60 frames per second)\r\n */\nvar FRAMES_PER_SECOND = 60;\nvar FRAME_DURATION = 1000 / FRAMES_PER_SECOND;\n\n/*\r\nSection: In-Game Objects\r\n--------------------------------------------------------------------------------\r\n */\n\n/*\r\nEach Entity has a physical shape.\r\n */\nvar SHAPES = {\n  NONE: 'none',\n  CIRCLE: 'circle',\n  SQUARE: 'square',\n  POLYGON: 'polygon'\n};\n\n/*\r\nEach Entity has a directional orientation, which can be interpreted as either\r\n\"rotation\" (if we want to know the precise angle for physics calculations) or\r\n\"direction\" (if we want to match it with up/down/left/right-facing sprites).\r\n */\nvar ROTATIONS = {\n  EAST: 0,\n  SOUTHEAST: Math.PI * 0.25,\n  SOUTH: Math.PI * 0.5,\n  SOUTHWEST: Math.PI * 0.75,\n  WEST: Math.PI,\n  NORTHWEST: Math.PI * -0.75,\n  NORTH: Math.PI * -0.5,\n  NORTHEAST: Math.PI * -0.25\n};\nvar DIRECTIONS = {\n  EAST: 0,\n  SOUTH: 1,\n  WEST: 2,\n  NORTH: 3\n};\n\n/*\r\nMap Tiles care about its cardinal neighbours. More specifically, they care about\r\nthe combination of the presence of neighbours. For example, if a \"brick wall\"\r\ntile has another brick wall to the north and another to the south, we can\r\nexpress this with the value 5 (= 1 + 4 = NORTH + SOUTH). \r\n */\nvar TILE_ADJACENCIES = {\n  NORTH: 1,\n  EAST: 2,\n  SOUTH: 4,\n  WEST: 8\n};\n\n/*\r\nSection: User Input\r\n--------------------------------------------------------------------------------\r\n */\n\n/*\r\nPointer (mouse or touch) input.\r\n */\nvar POINTER_STATES = {\n  IDLE: 'idle',\n  // Player isn't doing anything\n  POINTER_DOWN: 'pointer down' // Player is actively interacting with the canvas.\n};\n\n// Distance from its starting position that the pointer has to move, before a\n// 'move' command is issued.\nvar POINTER_DEADZONE_RADIUS = 16;\n\n// If the pointer is down and then released after a short time, it's a tap\n// action. Otherwise, it's a hold action.\nvar POINTER_TAP_DURATION = 300;\n\n/*\r\nSection: Painting\r\n--------------------------------------------------------------------------------\r\n */\n\n/*\r\nThe paint() step (of the core engine, each Entity, and each Rule) can paint\r\ninformation in different visual layers.\r\n */\nvar LAYERS = {\n  BOTTOM: 1,\n  MIDDLE: 2,\n  // Main object layer.\n  TOP: 3,\n  OVERLAY: 4\n};\nvar MIN_LAYER = 1;\nvar MAX_LAYER = 4;\n\n//# sourceURL=webpack://cny2026/./src/avo/constants.js?");

/***/ }),

/***/ "./src/avo/entity/entity.js":
/*!**********************************!*\
  !*** ./src/avo/entity/entity.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Entity)\n/* harmony export */ });\n/* harmony import */ var _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/constants.js */ \"./src/avo/constants.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n// Default physics config\n// Adjust to whatever \"feels\" right.\nvar MOVE_MAX_SPEED = 4;\nvar PUSH_MAX_SPEED = 32;\nvar MOVE_ACCELERATION = 0.4;\nvar MOVE_DECELERATION = 0.4;\nvar PUSH_DECELERATION = 0.4;\nvar GRAVITY = -0.4;\n\n// Default visuals config\nvar PAINT_HITBOX_MASS_TO_LINEWIDTH_FACTOR = 0.2;\nvar Entity = /*#__PURE__*/function () {\n  function Entity(app) {\n    _classCallCheck(this, Entity);\n    this._app = app;\n    this._type = 'entity';\n    this.name = ''; // Optional identifier.\n\n    // General entity attributes\n    this.colour = '#c0c0c0';\n    this.flying = false; // If flying, z position isn't affected by gravity.\n\n    // Expired entities are removed at the end of the cycle.\n    this._expired = false;\n\n    // Positional data\n    this.x = 0;\n    this.y = 0;\n    this.z = 0; // Pseudo position on z-axis. Doesn't affect collision. If 0, entity's \"feet\" are touching the ground.\n    this.size = _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE;\n    this._rotation = _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.ROTATIONS.SOUTH; // Rotation in radians.\n    this.shape = _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.SHAPES.CIRCLE;\n    this.shapePolygonPath = null; // Only applicable if shape === SHAPES.POLYGON.\n\n    // Physics (movement): self locomotion and external (pushed) movement\n    this.moveX = 0;\n    this.moveY = 0;\n    this.pushX = 0;\n    this.pushY = 0;\n\n    // Additional physics\n    this.solid = true; // If solid, then can interact with other solid physics entities.\n    this.movable = true; // If movable, then can be moved by external forces, e.g. by being pushed by another solid entity.\n    this.mass = 10; // Only matters if solid && movable.\n\n    // Additional \"dynamic\" physics\n    // Uses getters & setters to adjust values, e.g. in response to actions.\n    this._moveAcceleration = MOVE_ACCELERATION;\n    this._moveDeceleration = MOVE_DECELERATION;\n    this._moveMaxSpeed = MOVE_MAX_SPEED;\n    this._pushDeceleration = PUSH_DECELERATION;\n    this._pushMaxSpeed = PUSH_MAX_SPEED;\n\n    // Animation\n    this.spriteSheet = undefined; // HTML Image object (e.g. app.assets['hero'].img) containing all sprites used by this Entity.\n    this.spriteSizeX = 16; // Size of each sprite on the sprite sheet.\n    this.spriteSizeY = 16;\n    this.spriteScale = 2; // Scale of the sprite when paint()ed.\n    this.spriteOffsetX = -8; // Offset of sprite relative to this Entity's {x,y}, when painted on canvas.\n    this.spriteOffsetY = -8; // This is usually -0.5 * spriteSizeXorY to make sure the sprite is centred on Entity.\n    // Note: an Entity's {x,y} origin is usually its centre, whereas a HTML Image's {x,y} origin is its top-left corner.\n\n    // Advanced Animation\n    this.spriteFlipEastToWest = false; // For 4-directional sprite sheets, we can automatically flip East-facing sprites into West-facing sprites during paintSprite().\n    this.spriteZAddsToOffsetY = true; // If entity has a positive z-position, add that value to offsetY.\n  }\n  return _createClass(Entity, [{\n    key: \"deconstructor\",\n    value: function deconstructor() {}\n\n    /*\r\n    Section: General Logic\r\n    ----------------------------------------------------------------------------\r\n     */\n\n    /*\r\n    Run a single frame of game logic for the entity.\r\n    By default, this just handles physics (positioning and movement). Child\r\n    entities should generally call super.play() to ensure proper physics & etc.\r\n     */\n  }, {\n    key: \"play\",\n    value: function play() {\n      // Update position\n      this.x += this.moveX + this.pushX;\n      this.y += this.moveY + this.pushY;\n\n      // Upkeep: deceleration\n      this.doMoveDeceleration();\n      this.doPushDeceleration();\n\n      // Upkeep: limit speed\n      this.doMaxSpeedLimit();\n\n      // Upkeep: gravity\n      if (this.z > 0) {\n        this.z = Math.max(0, this.z + GRAVITY);\n      }\n    }\n\n    /*\r\n    Paint (render) the entity.\r\n    By default, this just paints the shape (hitbox). Child entities should do\r\n    something more interesting, such as calling this.paintSprite().\r\n     */\n  }, {\n    key: \"paint\",\n    value: function paint() {\n      var layer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var c2d = this._app.canvas2d;\n      this._app.applyCameraTransforms();\n      if (layer === _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.LAYERS.MIDDLE) {\n        c2d.fillStyle = this.colour;\n        c2d.strokeStyle = '#404040';\n        c2d.lineWidth = this.mass * PAINT_HITBOX_MASS_TO_LINEWIDTH_FACTOR;\n\n        // Draw shape outline\n        switch (this.shape) {\n          case _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.SHAPES.CIRCLE:\n            c2d.beginPath();\n            c2d.arc(this.x, this.y, this.size / 2, 0, 2 * Math.PI);\n            c2d.fill();\n            this.solid && c2d.stroke();\n            break;\n          case _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.SHAPES.SQUARE:\n            c2d.beginPath();\n            c2d.rect(this.x - this.size / 2, this.y - this.size / 2, this.size, this.size);\n            c2d.fill();\n            this.solid && c2d.stroke();\n            break;\n          case _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.SHAPES.POLYGON:\n            c2d.beginPath();\n            var coords = this.vertices;\n            if (coords.length >= 1) c2d.moveTo(coords[coords.length - 1].x, coords[coords.length - 1].y);\n            for (var i = 0; i < coords.length; i++) {\n              c2d.lineTo(coords[i].x, coords[i].y);\n            }\n            c2d.closePath();\n            c2d.fill();\n            this.solid && c2d.stroke();\n            break;\n        }\n\n        // Draw anchor point, mostly for debugging\n        c2d.strokeStyle = 'rgba(255, 255, 255, 0.5)';\n        c2d.beginPath();\n        c2d.arc(this.x, this.y, 2, 0, 2 * Math.PI); // Anchor point\n        if (this.shape === _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.SHAPES.CIRCLE) {\n          // Direction line\n          c2d.moveTo(this.x + this.size * 0.1 * Math.cos(this.rotation), this.y + this.size * 0.1 * Math.sin(this.rotation));\n          c2d.lineTo(this.x + this.size * 0.5 * Math.cos(this.rotation), this.y + this.size * 0.5 * Math.sin(this.rotation));\n        }\n        c2d.stroke();\n      }\n      this._app.undoCameraTransforms();\n    }\n\n    /*\r\n    Paint the entity's sprite, at the entity's position.\r\n    Note: args are optional; ONLY specify values for args if you want to override\r\n    the automatic calculations.\r\n     */\n  }, {\n    key: \"paintSprite\",\n    value: function paintSprite() {\n      var _args$spriteSizeX, _args$spriteSizeY, _args$spriteCol, _args$spriteRow, _ref, _args$spriteScaleX, _ref2, _args$spriteScaleY, _args$spriteOffsetX, _args$spriteOffsetY;\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n        // Source values\n        spriteCol: undefined,\n        // Column and row of source sprite on the sprite sheet. \n        spriteRow: undefined,\n        spriteSizeX: undefined,\n        // Size of source sprite on sprite sheet.\n        spriteSizeY: undefined,\n        // Painting target values\n        spriteOffsetX: undefined,\n        // Offset of sprite relative to this Entity's {x,y}, when painted on canvas.\n        spriteOffsetY: undefined,\n        // This is usually -0.5 * spriteSizeXorY to make sure the sprite is centred on Entity.\n        spriteRotation: undefined,\n        // Rotate the sprite.\n        spriteScale: undefined,\n        // Scale of the sprite when paint()ed.\n        spriteScaleX: undefined,\n        // Note: if you specify spriteScaleX/spriteScaleY, then spriteScale will be ignored.\n        spriteScaleY: undefined\n      };\n      var app = this._app;\n      var c2d = app.canvas2d;\n      if (!this.spriteSheet) return;\n      app.applyCameraTransforms();\n\n      // Calculate all the variables\n      var sizeX = (_args$spriteSizeX = args === null || args === void 0 ? void 0 : args.spriteSizeX) !== null && _args$spriteSizeX !== void 0 ? _args$spriteSizeX : this.spriteSizeX;\n      var sizeY = (_args$spriteSizeY = args === null || args === void 0 ? void 0 : args.spriteSizeY) !== null && _args$spriteSizeY !== void 0 ? _args$spriteSizeY : this.spriteSizeY;\n      var srcX = ((_args$spriteCol = args === null || args === void 0 ? void 0 : args.spriteCol) !== null && _args$spriteCol !== void 0 ? _args$spriteCol : this.getSpriteCol()) * sizeX;\n      var srcY = ((_args$spriteRow = args === null || args === void 0 ? void 0 : args.spriteRow) !== null && _args$spriteRow !== void 0 ? _args$spriteRow : this.getSpriteRow()) * sizeY;\n      var scaleX = (_ref = (_args$spriteScaleX = args === null || args === void 0 ? void 0 : args.spriteScaleX) !== null && _args$spriteScaleX !== void 0 ? _args$spriteScaleX : args === null || args === void 0 ? void 0 : args.spriteScale) !== null && _ref !== void 0 ? _ref : this.spriteScale;\n      var scaleY = (_ref2 = (_args$spriteScaleY = args === null || args === void 0 ? void 0 : args.spriteScaleY) !== null && _args$spriteScaleY !== void 0 ? _args$spriteScaleY : args === null || args === void 0 ? void 0 : args.spriteScale) !== null && _ref2 !== void 0 ? _ref2 : this.spriteScale;\n\n      // TODO: flipping sprites should be determined by a more general \"sprite rendering strategy\"\n      var flipX = this.spriteFlipEastToWest && this.getSpriteDirection() === _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.DIRECTIONS.WEST ? -1 : 1;\n      c2d.translate(this.x, this.y); // 1. This moves the 'drawing origin' to match the position of (the centre of) the Entity.\n      c2d.scale(flipX * scaleX, scaleY); // 2. This ensures the sprite scales with the 'drawing origin' as the anchor point.\n      if ((args === null || args === void 0 ? void 0 : args.spriteRotation) !== undefined) {\n        // 3. (OPTIONAL) If we wanted to, we could rotate the sprite around the 'drawing origin'.\n        c2d.rotate(args === null || args === void 0 ? void 0 : args.spriteRotation);\n      }\n\n      // 4. tgtX and tgtY specify where to draw the sprite, relative to the 'drawing origin'.\n      var tgtX = (_args$spriteOffsetX = args === null || args === void 0 ? void 0 : args.spriteOffsetX) !== null && _args$spriteOffsetX !== void 0 ? _args$spriteOffsetX : this.spriteOffsetX; // Usually this is sizeX * -0.5, to centre-align.\n      var tgtY = (_args$spriteOffsetY = args === null || args === void 0 ? void 0 : args.spriteOffsetY) !== null && _args$spriteOffsetY !== void 0 ? _args$spriteOffsetY : this.spriteOffsetY; // Usually this is sizeY * -0.75 to nudge a sprite upwards.\n\n      if (this.spriteZAddsToOffsetY) tgtY -= Math.max(0, this.z);\n      c2d.drawImage(this.spriteSheet, srcX, srcY, sizeX, sizeY, tgtX, tgtY, sizeX, sizeY);\n      app.undoCameraTransforms();\n    }\n\n    /*\r\n    Paint the entity's shadow, at the entity's position.\r\n    Actually very similar to - if not a modified copy of - the default \"paint\r\n    hitbox\" code.\r\n     */\n  }, {\n    key: \"paintShadow\",\n    value: function paintShadow() {\n      var layer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var c2d = this._app.canvas2d;\n      this._app.applyCameraTransforms();\n      if (layer === _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.LAYERS.BOTTOM) {\n        c2d.fillStyle = '#20202080';\n        switch (this.shape) {\n          case _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.SHAPES.CIRCLE:\n            c2d.beginPath();\n            c2d.arc(this.x, this.y, this.size / 2, 0, 2 * Math.PI);\n            c2d.fill();\n            break;\n          case _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.SHAPES.SQUARE:\n            c2d.beginPath();\n            c2d.rect(this.x - this.size / 2, this.y - this.size / 2, this.size, this.size);\n            c2d.fill();\n            break;\n          case _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.SHAPES.POLYGON:\n            c2d.beginPath();\n            var coords = this.vertices;\n            if (coords.length >= 1) c2d.moveTo(coords[coords.length - 1].x, coords[coords.length - 1].y);\n            for (var i = 0; i < coords.length; i++) {\n              c2d.lineTo(coords[i].x, coords[i].y);\n            }\n            c2d.closePath();\n            c2d.fill();\n            break;\n        }\n      }\n      this._app.undoCameraTransforms();\n    }\n\n    /*\r\n    Section: Game Logic\r\n    ----------------------------------------------------------------------------\r\n     */\n\n    /*\r\n    Applies an effect to this entity. Usually called by another antity.\r\n    e.g. a fireball hits this character and applies an \"ON FIRE\" effect.\r\n     */\n  }, {\n    key: \"applyEffect\",\n    value: function applyEffect(effect, source) {}\n\n    /*\r\n    Section: Event Handling\r\n    ----------------------------------------------------------------------------\r\n     */\n\n    /*\r\n    Triggers when this entity hits/touches/intersects with another.\r\n     */\n  }, {\n    key: \"onCollision\",\n    value: function onCollision(target, collisionCorrection) {\n      this.doBounce(target, collisionCorrection);\n      this.x = collisionCorrection.x;\n      this.y = collisionCorrection.y;\n    }\n\n    /*\r\n    Section: Physics\r\n    ----------------------------------------------------------------------------\r\n     */\n\n    /*\r\n    By default, every moving entity decelerates (because we don't exist in a\r\n    perfect vacuum and the game doesn't take place on a slippery ice).\r\n    Entities can intentionally override this logic,\r\n    e.g. \"if a hero is walking, ignore deceleration.\"\r\n     */\n  }, {\n    key: \"doMoveDeceleration\",\n    value: function doMoveDeceleration() {\n      var moveDeceleration = this.moveDeceleration || 0;\n      var curRotation = Math.atan2(this.moveY, this.moveX);\n      var newMoveSpeed = Math.max(0, this.moveSpeed - moveDeceleration);\n      this.moveX = newMoveSpeed * Math.cos(curRotation);\n      this.moveY = newMoveSpeed * Math.sin(curRotation);\n    }\n  }, {\n    key: \"doPushDeceleration\",\n    value: function doPushDeceleration() {\n      var pushDeceleration = this.pushDeceleration || 0;\n      var curRotation = Math.atan2(this.pushY, this.pushX);\n      var newPushSpeed = Math.max(0, this.pushSpeed - pushDeceleration);\n      this.pushX = newPushSpeed * Math.cos(curRotation);\n      this.pushY = newPushSpeed * Math.sin(curRotation);\n    }\n\n    /*\r\n    Every entity has a maximum speed limit. Intentional movement speed and\r\n    external force movement speed are treated separately.\r\n     */\n  }, {\n    key: \"doMaxSpeedLimit\",\n    value: function doMaxSpeedLimit() {\n      // Limit max move speed\n      if (this.moveMaxSpeed >= 0) {\n        var correctedSpeed = Math.min(this.moveMaxSpeed, this.moveSpeed);\n        var moveAngle = this.moveAngle;\n        this.moveX = correctedSpeed * Math.cos(moveAngle);\n        this.moveY = correctedSpeed * Math.sin(moveAngle);\n      }\n\n      // Limit max push speed\n      if (this.pushMaxSpeed >= 0) {\n        var _correctedSpeed = Math.min(this.pushMaxSpeed, this.pushSpeed);\n        var pushAngle = this.pushAngle;\n        this.pushX = _correctedSpeed * Math.cos(pushAngle);\n        this.pushY = _correctedSpeed * Math.sin(pushAngle);\n      }\n    }\n\n    /*\r\n    When a solid pushed entity hits another solid entity, momentum is transferred.\r\n    Usually, this leads to elastic collisions, because that chaos is fun!\r\n     */\n  }, {\n    key: \"doBounce\",\n    value: function doBounce(target, collisionCorrection) {\n      // If this object isn't a movable solid, it can't bounce.\n      if (!(this.movable && this.solid)) return;\n      if (\n      // this object is bouncing off an unmovable object\n      this.movable && this.solid && !target.movable && target.solid) {\n        if (this.shape === _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.SHAPES.CIRCLE && target.shape === _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.SHAPES.CIRCLE) {\n          // For circle + circle collisions, the collision correction already\n          // tells us the bounce direction.\n          var angle = Math.atan2(collisionCorrection.y - this.y, collisionCorrection.x - this.x);\n          var speed = Math.sqrt(this.pushX * this.pushX + this.pushY * this.pushY);\n          this.pushX = Math.cos(angle) * speed;\n          this.pushY = Math.sin(angle) * speed;\n        } else if (this.shape === _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.SHAPES.CIRCLE && (target.shape === _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.SHAPES.SQUARE || target.shape === _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.SHAPES.POLYGON)) {\n          // For circle + polygon collisions, we need to know...\n          // - the original angle this circle was moving towards (or rather, its\n          //   reverse, because we want a bounce)\n          // - the normal vector (of the edge) of the polygon this circle collided\n          //   into (which we can get from the collision correction)\n          // - the angle between them\n          var reverseOriginalAngle = Math.atan2(-this.pushY, -this.pushX);\n          var normalAngle = Math.atan2(collisionCorrection.y - this.y, collisionCorrection.x - this.x);\n          var angleBetween = normalAngle - reverseOriginalAngle;\n          var _angle = reverseOriginalAngle + 2 * angleBetween;\n          var _speed = Math.sqrt(this.pushX * this.pushX + this.pushY * this.pushY);\n          this.pushX = Math.cos(_angle) * _speed;\n          this.pushY = Math.sin(_angle) * _speed;\n        } else {\n          // For the moment, we're not too concerned about polygons bumping into each other\n        }\n      } else if (\n      // this object is bouncing off another movable object\n      target.movable && target.solid && collisionCorrection.pushX !== undefined && collisionCorrection.pushY !== undefined) {\n        this.pushX = collisionCorrection.pushX;\n        this.pushY = collisionCorrection.pushY;\n      }\n    }\n\n    /*\r\n    Section: Animation\r\n    ----------------------------------------------------------------------------\r\n     */\n\n    /*\r\n    NOTE: an Entity usually has one of two styles of sprite sheets:\r\n    1. 4-directional (Zelda-style) sprite sheets, used for characters/actors.\r\n    2. Static sprite sheets, used for environmental objects and etc.\r\n      For 4-directional sprite sheets, each sprite has a variation that faces a\r\n    different cardinal direction. The sprite sheet is usually divided so that each\r\n    row represents a state/action (e.g. idle0, move1, move2) and each column\r\n    represents a direction (South, East, North, West - though the West column can\r\n    be omitted if we just flip the East-facing sprite in-game).\r\n     */\n\n    /*\r\n    Get the directional orientation of the sprite, for a 4-directional\r\n    (Zelda-style) sprite sheet.\r\n     */\n  }, {\n    key: \"getSpriteDirection\",\n    value: function getSpriteDirection() {\n      //Favour East and West when rotation is exactly SW, NW, SE or NE.\n      if (this._rotation <= Math.PI * 0.25 && this._rotation >= Math.PI * -0.25) {\n        return _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.DIRECTIONS.EAST;\n      } else if (this._rotation > Math.PI * 0.25 && this._rotation < Math.PI * 0.75) {\n        return _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.DIRECTIONS.SOUTH;\n      } else if (this._rotation < Math.PI * -0.25 && this._rotation > Math.PI * -0.75) {\n        return _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.DIRECTIONS.NORTH;\n      } else {\n        return _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.DIRECTIONS.WEST;\n      }\n    }\n\n    /*\r\n    Get the column/row of the current sprite on the sprite sheet.\r\n     */\n  }, {\n    key: \"getSpriteCol\",\n    value: function getSpriteCol() {\n      return 0;\n    }\n  }, {\n    key: \"getSpriteRow\",\n    value: function getSpriteRow() {\n      return 0;\n    }\n\n    /*\r\n    Section: Getters and Setters\r\n    ----------------------------------------------------------------------------\r\n     */\n  }, {\n    key: \"left\",\n    get: function get() {\n      return this.x - this.size / 2;\n    },\n    set: function set(val) {\n      this.x = val + this.size / 2;\n    }\n  }, {\n    key: \"right\",\n    get: function get() {\n      return this.x + this.size / 2;\n    },\n    set: function set(val) {\n      this.x = val - this.size / 2;\n    }\n  }, {\n    key: \"top\",\n    get: function get() {\n      return this.y - this.size / 2;\n    },\n    set: function set(val) {\n      this.y = val + this.size / 2;\n    }\n  }, {\n    key: \"bottom\",\n    get: function get() {\n      return this.y + this.size / 2;\n    },\n    set: function set(val) {\n      this.y = val - this.size / 2;\n    }\n  }, {\n    key: \"radius\",\n    get: function get() {\n      return this.size / 2;\n    },\n    set: function set(val) {\n      this.size = val * 2;\n    }\n  }, {\n    key: \"col\",\n    get: function get() {\n      return Math.floor(this.x / _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE);\n    },\n    set: function set(val) {\n      this.x = val * _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE + _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE / 2;\n    }\n  }, {\n    key: \"row\",\n    get: function get() {\n      return Math.floor(this.y / _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE);\n    },\n    set: function set(val) {\n      this.y = val * _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE + _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE / 2;\n    }\n\n    /*\r\n    Rotation tracks the precise angle the entity is facing, in radians, clockwise\r\n    positive. 0 (0 rad) is east/right-facing, 90 (+pi/4 rad) is\r\n    south/down-facing.\r\n     */\n  }, {\n    key: \"rotation\",\n    get: function get() {\n      return this._rotation;\n    },\n    set: function set(val) {\n      this._rotation = val;\n      while (this._rotation > Math.PI) {\n        this._rotation -= Math.PI * 2;\n      }\n      while (this._rotation <= -Math.PI) {\n        this._rotation += Math.PI * 2;\n      }\n    }\n\n    /*\r\n    Every entity has a shape that can be represented by a polygon. (Yes, even\r\n    circles.) Each vertex is a point in the polygon where two segments/lines/edges\r\n    intersect.\r\n     */\n  }, {\n    key: \"vertices\",\n    get: function get() {\n      var _this = this;\n      var v = [];\n      if (this.shape === _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.SHAPES.SQUARE) {\n        v.push({\n          x: this.left,\n          y: this.top\n        });\n        v.push({\n          x: this.right,\n          y: this.top\n        });\n        v.push({\n          x: this.right,\n          y: this.bottom\n        });\n        v.push({\n          x: this.left,\n          y: this.bottom\n        });\n      } else if (this.shape === _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.SHAPES.CIRCLE) {\n        //Approximation\n        CIRCLE_TO_POLYGON_APPROXIMATOR.map(function (approximator) {\n          v.push({\n            x: _this.x + _this.radius * approximator.cosAngle,\n            y: _this.y + _this.radius * approximator.sinAngle\n          });\n        });\n      } else if (this.shape === _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.SHAPES.POLYGON) {\n        if (!this.shapePolygonPath) return [];\n        for (var i = 0; i < this.shapePolygonPath.length; i += 2) {\n          v.push({\n            x: this.x + this.shapePolygonPath[i],\n            y: this.y + this.shapePolygonPath[i + 1]\n          });\n        }\n      }\n      return v;\n    },\n    set: function set(val) {\n      console.error('ERROR: Entity.vertices is read only');\n    }\n\n    /*\r\n    Each segment is a line in the polygonal shape (or polygon-approximated shape)\r\n    of the entity.\r\n     */\n  }, {\n    key: \"segments\",\n    get: function get() {\n      var vertices = this.vertices;\n      if (vertices.length < 2) return [];\n      return vertices.map(function (vertex1, i) {\n        var vertex2 = vertices[(i + 1) % vertices.length];\n        return {\n          start: {\n            x: vertex1.x,\n            y: vertex1.y\n          },\n          end: {\n            x: vertex2.x,\n            y: vertex2.y\n          }\n        };\n      });\n    },\n    set: function set(val) {\n      console.error('ERROR: Entity.segments is read only');\n    }\n  }, {\n    key: \"moveAcceleration\",\n    get: function get() {\n      return this._moveAcceleration;\n    },\n    set: function set(val) {\n      this._moveAcceleration = val;\n    }\n  }, {\n    key: \"moveDeceleration\",\n    get: function get() {\n      return this._moveDeceleration;\n    },\n    set: function set(val) {\n      this._moveDeceleration = val;\n    }\n  }, {\n    key: \"moveMaxSpeed\",\n    get: function get() {\n      return this._moveMaxSpeed;\n    },\n    set: function set(val) {\n      this._moveMaxSpeed = val;\n    }\n  }, {\n    key: \"pushDeceleration\",\n    get: function get() {\n      return this._pushDeceleration;\n    },\n    set: function set(val) {\n      this._pushDeceleration = val;\n    }\n  }, {\n    key: \"pushMaxSpeed\",\n    get: function get() {\n      return this._pushMaxSpeed;\n    },\n    set: function set(val) {\n      this._pushMaxSpeed = val;\n    }\n  }, {\n    key: \"moveSpeed\",\n    get: function get() {\n      return Math.sqrt(this.moveX * this.moveX + this.moveY * this.moveY);\n    },\n    set: function set(val) {\n      console.error('ERROR: Entity.moveSpeed is read only');\n    }\n  }, {\n    key: \"moveAngle\",\n    get: function get() {\n      return Math.atan2(this.moveY, this.moveX);\n    },\n    set: function set(val) {\n      console.error('ERROR: Entity.moveAngle is read only');\n    }\n  }, {\n    key: \"pushSpeed\",\n    get: function get() {\n      return Math.sqrt(this.pushX * this.pushX + this.pushY * this.pushY);\n    },\n    set: function set(val) {\n      console.error('ERROR: Entity.pushSpeed is read only');\n    }\n  }, {\n    key: \"pushAngle\",\n    get: function get() {\n      return Math.atan2(this.pushY, this.pushX);\n    },\n    set: function set(val) {\n      console.error('ERROR: Entity.pushAngle is read only');\n    }\n  }]);\n}();\n\nvar CIRCLE_TO_POLYGON_APPROXIMATOR = [_avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.ROTATIONS.EAST, _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.ROTATIONS.SOUTHEAST, _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.ROTATIONS.SOUTH, _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.ROTATIONS.SOUTHWEST, _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.ROTATIONS.WEST, _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.ROTATIONS.NORTHWEST, _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.ROTATIONS.NORTH, _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.ROTATIONS.NORTHEAST].map(function (angle) {\n  return {\n    cosAngle: Math.cos(angle),\n    sinAngle: Math.sin(angle)\n  };\n});\n\n//# sourceURL=webpack://cny2026/./src/avo/entity/entity.js?");

/***/ }),

/***/ "./src/avo/entity/examples/ball.js":
/*!*****************************************!*\
  !*** ./src/avo/entity/examples/ball.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Ball)\n/* harmony export */ });\n/* harmony import */ var _avo_entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/entity */ \"./src/avo/entity/index.js\");\n/* harmony import */ var _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @avo/constants.js */ \"./src/avo/constants.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n\n\nvar Ball = /*#__PURE__*/function (_Entity) {\n  function Ball(app) {\n    var _this;\n    var col = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var row = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    _classCallCheck(this, Ball);\n    _this = _callSuper(this, Ball, [app]);\n    _this._type = 'ball';\n    _this.colour = '#48c';\n    _this.solid = true;\n    _this.movable = true;\n    _this.x = col * _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE + _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE / 2;\n    _this.y = row * _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE + _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE / 2;\n    return _this;\n  }\n  _inherits(Ball, _Entity);\n  return _createClass(Ball);\n}(_avo_entity__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n\n//# sourceURL=webpack://cny2026/./src/avo/entity/examples/ball.js?");

/***/ }),

/***/ "./src/avo/entity/examples/enemy.js":
/*!******************************************!*\
  !*** ./src/avo/entity/examples/enemy.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Enemy)\n/* harmony export */ });\n/* harmony import */ var _avo_entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/entity */ \"./src/avo/entity/index.js\");\n/* harmony import */ var _avo_entity_examples_shot_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @avo/entity/examples/shot.js */ \"./src/avo/entity/examples/shot.js\");\n/* harmony import */ var _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @avo/constants.js */ \"./src/avo/constants.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && \"function\" == typeof p ? function (t) { return p.apply(e, t); } : p; }\nfunction _get() { return _get = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }\nfunction _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n\n\n\nvar Enemy = /*#__PURE__*/function (_Entity) {\n  function Enemy(app) {\n    var _this;\n    var col = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var row = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    _classCallCheck(this, Enemy);\n    _this = _callSuper(this, Enemy, [app]);\n    _this._type = 'enemy';\n    _this.colour = '#4c4';\n    _this.x = col * _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.TILE_SIZE + _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.TILE_SIZE / 2;\n    _this.y = row * _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.TILE_SIZE + _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.TILE_SIZE / 2;\n    _this.action = {\n      name: 'shoot',\n      counter: 0,\n      acknowledged: false\n    };\n    return _this;\n  }\n  _inherits(Enemy, _Entity);\n  return _createClass(Enemy, [{\n    key: \"play\",\n    value: function play() {\n      _superPropGet(Enemy, \"play\", this, 3)([]);\n      this.processAction();\n    }\n  }, {\n    key: \"processAction\",\n    value: function processAction() {\n      if (!this.action) return;\n      var action = this.action;\n      var app = this._app;\n      if (action.name === 'shoot') {\n        var DURATION = 500;\n        var progress = action.counter / DURATION;\n        if (!action.acknowledged && progress > 0.5) {\n          action.acknowledged = true;\n          app.addEntity(new _avo_entity_examples_shot_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](app, this.x, this.y, this.rotation, this));\n        }\n        action.counter += _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.FRAME_DURATION;\n        if (action.counter >= DURATION) {\n          this.action = {\n            name: 'shoot',\n            counter: 0,\n            acknowledged: false\n          };\n        }\n      }\n    }\n  }]);\n}(_avo_entity__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n\n//# sourceURL=webpack://cny2026/./src/avo/entity/examples/enemy.js?");

/***/ }),

/***/ "./src/avo/entity/examples/hero.js":
/*!*****************************************!*\
  !*** ./src/avo/entity/examples/hero.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Hero)\n/* harmony export */ });\n/* harmony import */ var _avo_entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/entity */ \"./src/avo/entity/index.js\");\n/* harmony import */ var _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @avo/constants.js */ \"./src/avo/constants.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && \"function\" == typeof p ? function (t) { return p.apply(e, t); } : p; }\nfunction _get() { return _get = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }\nfunction _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n\n\nvar INVULNERABILITY_WINDOW = 3000;\nvar MOVE_ACTION_CYCLE_DURATION = 500;\nvar Hero = /*#__PURE__*/function (_Entity) {\n  function Hero(app) {\n    var _this;\n    var col = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var row = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    _classCallCheck(this, Hero);\n    _this = _callSuper(this, Hero, [app]);\n    _this._type = 'hero';\n    _this.colour = '#000';\n    _this.x = col * _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE + _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE / 2;\n    _this.y = row * _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE + _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE / 2;\n    _this.intent = undefined;\n    _this.action = undefined;\n    _this.health = 3;\n    _this.invulnerability = 0; // Invulnerability time\n    return _this;\n  }\n\n  /*\r\n  Section: General Logic\r\n  ----------------------------------------------------------------------------\r\n   */\n  _inherits(Hero, _Entity);\n  return _createClass(Hero, [{\n    key: \"play\",\n    value: function play() {\n      _superPropGet(Hero, \"play\", this, 3)([]);\n      this.processIntent();\n      this.processAction();\n\n      // Count down invulnerability time\n      if (this.invulnerability > 0) {\n        this.invulnerability = Math.max(this.invulnerability - _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.FRAME_DURATION, 0);\n      }\n    }\n  }, {\n    key: \"paint\",\n    value: function paint() {\n      var layer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var app = this._app;\n      if (this.invulnerability > 0) {\n        // If invulnerable, flash!\n        var flash = Math.floor(this.invulnerability / 300) % 2;\n        if (flash === 1) return;\n      }\n      this.colour = app.playerInput.pointerState === _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.POINTER_STATES.POINTER_DOWN ? '#e42' : '#c44';\n      _superPropGet(Hero, \"paint\", this, 3)([layer]);\n      var c2d = app.canvas2d;\n      var animationSpriteSheet = app.assets['hero-4dir'];\n      if (!animationSpriteSheet) return;\n      this._app.applyCameraTransforms();\n      var SPRITE_SIZE = 48;\n      var FLIP_SPRITE = 1;\n      var SPRITE_SCALE = 2 * (Math.min(this.health / 3, 1) * 0.5 + 0.5); // Shrink after taking damage\n\n      // Draw any special vfx\n      var action = this.action;\n      if ((action === null || action === void 0 ? void 0 : action.name) === 'dash' && (action === null || action === void 0 ? void 0 : action.state) === 'execution' && layer === _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.LAYERS.MIDDLE) {\n        // Draw a \"dash line\"\n        var dashLength = this.size * 2;\n        var dashWidth = this.size;\n        var dashTailX = this.x - dashLength * Math.cos(this.rotation);\n        var dashTailY = this.y - dashLength * Math.sin(this.rotation);\n        c2d.beginPath();\n        c2d.moveTo(this.x, this.y);\n        c2d.lineTo(dashTailX, dashTailY);\n        c2d.strokeStyle = 'rgba(255, 255, 0, 0.5)';\n        c2d.lineWidth = dashWidth;\n        c2d.stroke();\n      }\n\n      // Draw the sprite\n      if (layer === _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.LAYERS.MIDDLE) {\n        var srcX = this.getSpriteCol() * SPRITE_SIZE;\n        var srcY = this.getSpriteRow() * SPRITE_SIZE;\n        var sizeX = SPRITE_SIZE;\n        var sizeY = SPRITE_SIZE;\n        c2d.translate(this.x, this.y); // 1. This moves the 'drawing origin' to match the position of (the centre of) the Entity.\n        c2d.scale(SPRITE_SCALE * FLIP_SPRITE, SPRITE_SCALE); // 2. This ensures the sprite scales with the 'drawing origin' as the anchor point.\n        // c2d.rotate(this.rotation)  // 3. If we wanted to, we could rotate the sprite around the 'drawing origin'.\n\n        // 4. tgtX and tgtY specify where to draw the sprite, relative to the 'drawing origin'.\n        var tgtX = -sizeX / 2; // Align centre of sprite to origin\n        var tgtY = -sizeY * 0.75; // Align bottom(-ish) of sprite to origin\n\n        c2d.drawImage(animationSpriteSheet.img, srcX, srcY, sizeX, sizeY, tgtX, tgtY, sizeX, sizeY);\n      }\n      this._app.undoCameraTransforms();\n    }\n\n    /*\r\n    Section: Game Logic\r\n    ----------------------------------------------------------------------------\r\n     */\n  }, {\n    key: \"applyEffect\",\n    value: function applyEffect(effect, source) {\n      _superPropGet(Hero, \"applyEffect\", this, 3)([effect, source]);\n      if (!effect) return;\n      if (effect.name === 'damage') {\n        if (this.invulnerability === 0) {\n          this.health = Math.max(this.health - 1, 0);\n          this.invulnerability = INVULNERABILITY_WINDOW;\n        }\n      }\n    }\n\n    /*\r\n    Section: Intent and Actions\r\n    ----------------------------------------------------------------------------\r\n     */\n\n    /*\r\n    Translate intent into action.\r\n     */\n  }, {\n    key: \"processIntent\",\n    value: function processIntent() {\n      // Failsafe\n      if (!this.action) this.goIdle();\n      var action = this.action;\n      var intent = this.intent;\n      if (!intent) {\n        // Go idle\n        if ((action === null || action === void 0 ? void 0 : action.name) === 'move') this.goIdle();\n      } else {\n        // Perform a new action\n        // Note: every 'move' action is considered a new action\n\n        if ((action === null || action === void 0 ? void 0 : action.name) === 'idle' || (action === null || action === void 0 ? void 0 : action.name) === 'move') {\n          // Can the action be overwritten by a new action? If not, the action must play through to its finish.\n          this.action = _objectSpread(_objectSpread({}, intent), {}, {\n            name: intent.name,\n            counter: action.name === intent.name ? action.counter : 0 // If the current action and new intent have the same name, it's just a continuation of the idle or move action, but with other new values (e.g. new directions)\n          });\n        }\n      }\n    }\n\n    /*\r\n    Perform the action.\r\n     */\n  }, {\n    key: \"processAction\",\n    value: function processAction() {\n      if (!this.action) return;\n      var action = this.action;\n      if (action.name === 'idle') {\n\n        // Do nothing\n      } else if (action.name === 'move') {\n        var moveAcceleration = this.moveAcceleration || 0;\n        var directionX = action.directionX || 0;\n        var directionY = action.directionY || 0;\n        var actionRotation = Math.atan2(directionY, directionX);\n        this.moveX += moveAcceleration * Math.cos(actionRotation);\n        this.moveY += moveAcceleration * Math.sin(actionRotation);\n        this.rotation = actionRotation;\n        action.counter = (action.counter + _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.FRAME_DURATION) % MOVE_ACTION_CYCLE_DURATION;\n      } else if (action.name === 'dash') {\n        var WINDUP_DURATION = _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.FRAME_DURATION * 5;\n        var EXECUTION_DURATION = _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.FRAME_DURATION * 2;\n        var WINDDOWN_DURATION = _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.FRAME_DURATION * 10;\n        var PUSH_POWER = this.size * 0.3;\n        var MAX_PUSH = EXECUTION_DURATION / 1000 * 60 * PUSH_POWER;\n        if (!action.state) {\n          // Trigger only once, at the start of the action\n\n          // Figure out the initial direction of the dash\n          var _directionX = action.directionX || 0;\n          var _directionY = action.directionY || 0;\n          this.rotation = _directionX === 0 && _directionY === 0 ? this.rotation : Math.atan2(_directionY, _directionX);\n          action.rotation = this.rotation; // Records the initial direction of the dash\n\n          action.state = 'windup';\n        }\n        if (action.state === 'windup') {\n          action.counter += _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.FRAME_DURATION;\n          if (action.counter >= WINDUP_DURATION) {\n            action.state = 'execution';\n            action.counter = 0;\n          }\n        } else if (action.state === 'execution') {\n          this.pushX += PUSH_POWER * Math.cos(action.rotation);\n          this.pushY += PUSH_POWER * Math.sin(action.rotation);\n          action.counter += _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.FRAME_DURATION;\n          if (action.counter >= EXECUTION_DURATION) {\n            action.state = 'winddown';\n            action.counter = 0;\n          }\n        } else if (action.state === 'winddown') {\n          action.counter += _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.FRAME_DURATION;\n          if (action.counter >= WINDDOWN_DURATION) {\n            this.goIdle();\n          }\n        }\n      }\n    }\n  }, {\n    key: \"goIdle\",\n    value: function goIdle() {\n      this.action = {\n        name: 'idle',\n        counter: 0\n      };\n    }\n\n    /*\r\n    Section: Event Handling\r\n    ----------------------------------------------------------------------------\r\n     */\n\n    /*\r\n    Triggers when this entity hits/touches/intersects with another.\r\n     */\n  }, {\n    key: \"onCollision\",\n    value: function onCollision(target, collisionCorrection) {\n      _superPropGet(Hero, \"onCollision\", this, 3)([target, collisionCorrection]);\n      if (!target) return;\n    }\n\n    /*\r\n    Section: Physics/Getters and Setters\r\n    ----------------------------------------------------------------------------\r\n     */\n  }, {\n    key: \"moveDeceleration\",\n    get: function get() {\n      var _this$action;\n      if (((_this$action = this.action) === null || _this$action === void 0 ? void 0 : _this$action.name) === 'move') return 0;\n      return this._moveDeceleration;\n    }\n  }, {\n    key: \"pushDeceleration\",\n    get: function get() {\n      var _this$action2, _this$action3;\n      if (((_this$action2 = this.action) === null || _this$action2 === void 0 ? void 0 : _this$action2.name) === 'dash' && ((_this$action3 = this.action) === null || _this$action3 === void 0 ? void 0 : _this$action3.state) === 'execution') return 0;\n      return this._pushDeceleration;\n    }\n\n    /*\r\n    Section: Animation\r\n    ----------------------------------------------------------------------------\r\n     */\n  }, {\n    key: \"getSpriteCol\",\n    value: function getSpriteCol() {\n      switch (this.getSpriteDirection()) {\n        case _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.DIRECTIONS.NORTH:\n          return 1;\n        case _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.DIRECTIONS.EAST:\n          return 2;\n        case _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.DIRECTIONS.SOUTH:\n          return 0;\n        case _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.DIRECTIONS.WEST:\n          return 3;\n      }\n      return 0;\n    }\n  }, {\n    key: \"getSpriteRow\",\n    value: function getSpriteRow() {\n      var action = this.action;\n      if (!action) return 0;\n      if (action.name === 'move') {\n        var progress = action.counter / MOVE_ACTION_CYCLE_DURATION;\n        if (progress < 0.3) return 2;else if (progress < 0.5) return 1;else if (progress < 0.8) return 3;else if (progress < 1) return 1;\n      } else if (action.name === 'dash') {\n        if (action.state === 'windup') return 4;else if (action.state === 'execution') return 1;else if (action.state === 'winddown') return 1;\n      }\n      return 0;\n    }\n  }]);\n}(_avo_entity__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n\n//# sourceURL=webpack://cny2026/./src/avo/entity/examples/hero.js?");

/***/ }),

/***/ "./src/avo/entity/examples/shot.js":
/*!*****************************************!*\
  !*** ./src/avo/entity/examples/shot.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Shot)\n/* harmony export */ });\n/* harmony import */ var _avo_entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/entity */ \"./src/avo/entity/index.js\");\n/* harmony import */ var _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @avo/constants.js */ \"./src/avo/constants.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && \"function\" == typeof p ? function (t) { return p.apply(e, t); } : p; }\nfunction _get() { return _get = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }\nfunction _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n\n\nvar Shot = /*#__PURE__*/function (_Entity) {\n  function Shot(app) {\n    var _this;\n    var x = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var y = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var rotation = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    var source = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : undefined;\n    _classCallCheck(this, Shot);\n    _this = _callSuper(this, Shot, [app]);\n    _this._type = 'shot';\n    _this.source = source; // The entity that this shot came from\n\n    _this.colour = '#cc4';\n    _this.solid = false;\n    _this.movable = true;\n    _this.size = _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE / 2;\n    _this.x = x;\n    _this.y = y;\n    _this.rotation = rotation;\n    _this.moveAcceleration = 1;\n    _this.moveDeceleration = 0;\n    _this.moveMaxSpeed = _this.size * 2;\n    _this.distance = _this.size * 1;\n    return _this;\n  }\n  _inherits(Shot, _Entity);\n  return _createClass(Shot, [{\n    key: \"onCollision\",\n    value: function onCollision(target, collisionCorrection) {\n      _superPropGet(Shot, \"onCollision\", this, 3)([target, collisionCorrection]);\n      if (this.source !== target && target.solid) {\n        target.applyEffect({\n          name: 'damage'\n        }, this);\n        this._expired = true;\n      }\n    }\n  }, {\n    key: \"play\",\n    value: function play() {\n      _superPropGet(Shot, \"play\", this, 3)([]);\n      var moveAcceleration = this.moveAcceleration || 0;\n      this.moveX += moveAcceleration * Math.cos(this.rotation);\n      this.moveY += moveAcceleration * Math.sin(this.rotation);\n      this.distance -= moveAcceleration;\n      if (this.distance <= 0) this._expired = true;\n    }\n  }]);\n}(_avo_entity__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n\n//# sourceURL=webpack://cny2026/./src/avo/entity/examples/shot.js?");

/***/ }),

/***/ "./src/avo/entity/examples/wall.js":
/*!*****************************************!*\
  !*** ./src/avo/entity/examples/wall.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Wall)\n/* harmony export */ });\n/* harmony import */ var _avo_entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/entity */ \"./src/avo/entity/index.js\");\n/* harmony import */ var _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @avo/constants.js */ \"./src/avo/constants.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n\n\nvar Wall = /*#__PURE__*/function (_Entity) {\n  function Wall(app) {\n    var _this;\n    var col = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var row = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var width = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n    var height = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n    var cutCorner = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n    _classCallCheck(this, Wall);\n    _this = _callSuper(this, Wall, [app]);\n    _this._type = 'wall';\n    _this.colour = '#888';\n    _this.solid = true;\n    _this.movable = false;\n    _this.x = col * _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE;\n    _this.y = row * _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE;\n    _this.shape = _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.SHAPES.POLYGON;\n    _this.shapePolygonPath = [];\n    if (cutCorner !== 'nw') _this.shapePolygonPath.push(0, 0);\n    if (cutCorner !== 'ne') _this.shapePolygonPath.push(width * _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE, 0);\n    if (cutCorner !== 'se') _this.shapePolygonPath.push(width * _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE, height * _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE);\n    if (cutCorner !== 'sw') _this.shapePolygonPath.push(0, height * _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE);\n    return _this;\n  }\n  _inherits(Wall, _Entity);\n  return _createClass(Wall);\n}(_avo_entity__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n\n//# sourceURL=webpack://cny2026/./src/avo/entity/examples/wall.js?");

/***/ }),

/***/ "./src/avo/entity/index.js":
/*!*********************************!*\
  !*** ./src/avo/entity/index.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _entity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./entity.js */ \"./src/avo/entity/entity.js\");\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_entity_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n//# sourceURL=webpack://cny2026/./src/avo/entity/index.js?");

/***/ }),

/***/ "./src/avo/entity/types/creature.js":
/*!******************************************!*\
  !*** ./src/avo/entity/types/creature.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Creature)\n/* harmony export */ });\n/* harmony import */ var _entity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../entity.js */ \"./src/avo/entity/entity.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n\nvar Creature = /*#__PURE__*/function (_Entity) {\n  function Creature(app) {\n    var _this;\n    _classCallCheck(this, Creature);\n    _this = _callSuper(this, Creature, [app]);\n    _this._type = 'creature';\n    return _this;\n  }\n  _inherits(Creature, _Entity);\n  return _createClass(Creature);\n}(_entity_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n\n//# sourceURL=webpack://cny2026/./src/avo/entity/types/creature.js?");

/***/ }),

/***/ "./src/avo/game-ai.js":
/*!****************************!*\
  !*** ./src/avo/game-ai.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GameAI: () => (/* binding */ GameAI)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nvar GameAI = {\n  /*\r\n  A* path-finding: Given a grid, finds a path from start to goal.\r\n  Returns an array. Array will be empty if no path could be found.\r\n  Input example:\r\n    start: { x:1,y:0 }\r\n    goal: { x:1,y:2 }\r\n    grid: [[0,0,0],  //0 indicates floor, 1 indicates wall.\r\n            [0,1,0],\r\n            [0,0,0],]\r\n  Output example:\r\n    [{x:1,y:0},{x:0,y:0},{x:0,y:1},{x:0,y:2},{x:1,y:2},]\r\n  Optional 'spiceUpPathing' flag gives slightly different routes every time.\r\n   */\n  findPath: function findPath(start, goal, grid) {\n    var spiceUpPathing = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    // First, let's set up our playing field.\n    // ----------------------------------------------------------------\n    var MIN_X = 0;\n    var MIN_Y = 0;\n    var MAX_X = Math.max(grid.length > 0 ? grid[0].length - 1 : 0, 0);\n    var MAX_Y = Math.max(grid.length - 1, 0);\n    var startCell = null; //start and goal are just x-y coordinates.\n    var goalCell = null; //startCell and goalCell are pointers to the actual locations on the calculated grid; this helpful for calculations.\n\n    // The calculated grid is the grid, but with more variables to keep track of\n    // the A* pathfinding calculations.\n    var calcGrid = grid.map(function (row, y) {\n      return row.map(function (col, x) {\n        var cell = {\n          x: x,\n          y: y,\n          val: col,\n          from: null,\n          // Which cell (starting from startCell) did we come from, to reach this cell?\n          cost: Infinity // What is the cost for reaching this cell, starting from startCell?\n        };\n        if (x === start.x && y === start.y) startCell = cell;\n        return cell;\n      });\n    });\n    // ----------------------------------------------------------------\n\n    // Pathfinding!\n    // ----------------------------------------------------------------\n    var frontier = new ScoredQueue(); // The frontier determines where on the grid still needs to be explored.\n    startCell.cost = 0;\n    frontier.put(startCell, 0);\n\n    // The ScoredQueue ensures that when we call frontier.get(), we'll always\n    // pull the cell with the lowest score/cost. The lowest scored/costed cell\n    // is the one that's most likely to be the \"best\" way to reach the goal.\n\n    while (!frontier.isEmpty()) {\n      // If the frontier is ever empty, we've run out of places to look.\n      var current = frontier.get(); // Get the lowest scored/costed cell and remove it from the queue.\n      if (!current) break; //Safety check\n\n      if (current.x === goal.x && current.y === goal.y) {\n        // Target found!\n        goalCell = current;\n        break; // OK we can stop now.\n      }\n\n      // Get neighbours.\n      var neighbours = [];\n      if (current.x - 1 >= MIN_X) neighbours.push(calcGrid[current.y][current.x - 1]);\n      if (current.x + 1 <= MAX_X) neighbours.push(calcGrid[current.y][current.x + 1]);\n      if (current.y - 1 >= MIN_Y) neighbours.push(calcGrid[current.y - 1][current.x]);\n      if (current.y + 1 <= MAX_Y) neighbours.push(calcGrid[current.y + 1][current.x]);\n\n      // Select only valid neighbours (floors, not walls)\n      neighbours = neighbours.filter(function (n) {\n        return n.val === 0;\n      });\n\n      // The order of neighbours affects which directions the pathfinding\n      // prefers. For example, if the goal is directly SouthEast of the start,\n      // the path might favour going aaalll the way East then aaalll the way\n      // South.\n\n      // The spiceUpPathing option makes the pathfinding preference a little less predictable.\n      if (spiceUpPathing) neighbours = this.shuffleArray(neighbours, neighbours.length);\n      var _iterator = _createForOfIteratorHelper(neighbours),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var next = _step.value;\n          var DEFAULT_COST = 1;\n          var newCost = current.cost + DEFAULT_COST;\n          if (newCost < next.cost) {\n            next.cost = newCost;\n            var priority = newCost + this.heuristics(next, goal);\n            next.from = current;\n            frontier.put(next, priority);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n    // ----------------------------------------------------------------\n\n    // If we have found the goalCell (i.e. the goal coordinates within the\n    // calculated grid), we can trace a path back from the goalCell all the way\n    // back to the startCell.\n    // ----------------------------------------------------------------\n    var path = [];\n    var curPath = goalCell;\n    while (curPath) {\n      path.push({\n        x: curPath.x,\n        y: curPath.y\n      });\n      curPath = curPath.from;\n    }\n    path = path.reverse();\n    return path;\n    // ----------------------------------------------------------------\n  },\n  /*\r\n  Heuristics: used in A* path-finding to \"guess\" how close a cell is to the\r\n  goal. The lower the returned number, the closer it is.\r\n   */\n  heuristics: function heuristics(cell, goal) {\n    return Math.abs(cell.x - goal.x) + Math.abs(cell.y - goal.y);\n  },\n  /*\r\n  Shuffles an array, n times.\r\n   */\n  shuffleArray: function shuffleArray(array, n) {\n    if (!array || array.length <= 1) return array;\n    var out = array.map(function (itm) {\n      return itm;\n    });\n    var cur = n;\n    while (cur > 0) {\n      var i = Math.floor(Math.random() * out.length);\n      var j = Math.floor(Math.random() * out.length);\n      var tmp = out[i];\n      out[i] = out[j];\n      out[j] = tmp;\n      cur--;\n    }\n    return out;\n  }\n};\n\n/*\r\nScoredQueue: a queue that's automatically ordered by each item's score.\r\nput() adds an item to the queue.\r\nget() removes the item with the lowest score from the queue, then returns it.\r\n */\nvar ScoredQueue = /*#__PURE__*/function () {\n  function ScoredQueue() {\n    _classCallCheck(this, ScoredQueue);\n    this.elements = [];\n  }\n  return _createClass(ScoredQueue, [{\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return this.elements.length === 0;\n    }\n  }, {\n    key: \"put\",\n    value: function put(item, score) {\n      var index = 0;\n      for (; index < this.elements.length; index++) {\n        if (score <= this.elements[index].score) break;\n      }\n      this.elements.splice(index, 0, {\n        item: item,\n        score: score\n      });\n\n      //Alternative version:\n      //this.elements.push({ item, score })\n      //this.elements.sort((a, b) => { return a.score - b.score })\n    }\n  }, {\n    key: \"get\",\n    value: function get() {\n      return this.elements.shift().item;\n    }\n  }]);\n}();\n\n//# sourceURL=webpack://cny2026/./src/avo/game-ai.js?");

/***/ }),

/***/ "./src/avo/image-asset.js":
/*!********************************!*\
  !*** ./src/avo/image-asset.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ImageAsset)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nvar ImageAsset = /*#__PURE__*/_createClass(function ImageAsset(url) {\n  _classCallCheck(this, ImageAsset);\n  this.url = url;\n  this.ready = false;\n  this.error = false;\n  this.img = new Image();\n  this.img.onload = function () {\n    this.ready = true;\n    this.error = false;\n  }.bind(this);\n  this.img.onerror = function (err) {\n    console.error('ImageAsset Error (' + this.url + '): ', err);\n    this.ready = false;\n    this.error = true;\n  }.bind(this);\n  this.img.src = this.url;\n});\n\n\n//# sourceURL=webpack://cny2026/./src/avo/image-asset.js?");

/***/ }),

/***/ "./src/avo/index.js":
/*!**************************!*\
  !*** ./src/avo/index.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _avo_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./avo.js */ \"./src/avo/avo.js\");\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_avo_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n//# sourceURL=webpack://cny2026/./src/avo/index.js?");

/***/ }),

/***/ "./src/avo/interaction/index.js":
/*!**************************************!*\
  !*** ./src/avo/interaction/index.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _interaction_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interaction.js */ \"./src/avo/interaction/interaction.js\");\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_interaction_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n//# sourceURL=webpack://cny2026/./src/avo/interaction/index.js?");

/***/ }),

/***/ "./src/avo/interaction/interaction.js":
/*!********************************************!*\
  !*** ./src/avo/interaction/interaction.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Interaction)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar Interaction = /*#__PURE__*/function () {\n  function Interaction(app) {\n    _classCallCheck(this, Interaction);\n    this._app = app;\n    this._type = 'interaction';\n    this.name = ''; // Optional identifier\n  }\n  return _createClass(Interaction, [{\n    key: \"load\",\n    value: function load(div) {\n      var _this = this;\n      var menu = document.createElement('div');\n      menu.innerHTML = \"\\n      <h3>Example Interaction Menu</h3>\\n      <p>Debug Controls:</p>\\n      <ul>\\n        <li><b>[X]</b> Open example interaction menu</li>\\n        <li><b>[Z]</b> Action</li>\\n      </ul>\\n    \";\n      var closeButton = document.createElement('button');\n      closeButton.type = 'button';\n      closeButton.innerText = 'OK!';\n      closeButton.onclick = function () {\n        _this._app.setInteractionMenu(false);\n      };\n      menu.appendChild(closeButton);\n      div.appendChild(menu);\n      setTimeout(function () {\n        closeButton.focus();\n      }, 100);\n    }\n  }, {\n    key: \"unload\",\n    value: function unload() {}\n  }]);\n}();\n\n\n//# sourceURL=webpack://cny2026/./src/avo/interaction/interaction.js?");

/***/ }),

/***/ "./src/avo/misc.js":
/*!*************************!*\
  !*** ./src/avo/misc.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   angleDiff: () => (/* binding */ angleDiff),\n/* harmony export */   isZero: () => (/* binding */ isZero),\n/* harmony export */   transformSpriteSheet: () => (/* binding */ transformSpriteSheet)\n/* harmony export */ });\n/*\r\nChecks if a number is (close enough) to zero.\r\nDue to the imprecise way floating number data can be stored, it's possible for\r\na mathematical 0 to be represented as something incredibly small like\r\n1.4210854715202004e-14. This screws boolean checks like (num === 0)\r\n */\nfunction isZero(num) {\n  return -1e-10 < num && num < 1e-10;\n}\n\n/*\r\nFinds the difference between angle B and angle A, in radians.\r\n */\nfunction angleDiff(angleA, angleB) {\n  var diff = angleB - angleA;\n\n  // Clamp diff value to -180 <= x <= +180\n  while (diff < -Math.PI) diff += Math.PI * 2; // While diff < -180, rotate by +360\n  while (diff > Math.PI) diff -= Math.PI * 2; // While diff > 180, rotate by -360\n\n  return diff;\n}\n\n/*\r\nTransforms a sprite sheet (basically a HTMLImageElement), pixel by pixel.\r\n */\nfunction transformSpriteSheet(image) {\n  var transform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (r, g, b, a) {\n    return {\n      r: r,\n      g: g,\n      b: b,\n      a: a\n    };\n  };\n  if (!image || !(image !== null && image !== void 0 && image.width) || !(image !== null && image !== void 0 && image.height)) return image;\n\n  // Create an OffscreenCanvas and paint the image on it.\n  var width = image.width;\n  var height = image.height;\n  var offscreenCanvas = new OffscreenCanvas(width, height);\n  var c2dOff = offscreenCanvas.getContext('2d');\n  c2dOff.drawImage(image, 0, 0, width, height, 0, 0, width, height);\n\n  // Extract the data from the painted image.\n  var offImage = c2dOff.getImageData(0, 0, width, height);\n  var offData = offImage === null || offImage === void 0 ? void 0 : offImage.data;\n  var dataLength = (offData === null || offData === void 0 ? void 0 : offData.length) || 0;\n\n  // Go through every pixel in the data, and run it through the transformer.\n  for (var i = 0; i < dataLength; i += 4) {\n    var _r = offData[i + 0];\n    var _g = offData[i + 1];\n    var _b = offData[i + 2];\n    var _a = offData[i + 3];\n    var _transform = transform(_r, _g, _b, _a),\n      r = _transform.r,\n      g = _transform.g,\n      b = _transform.b,\n      a = _transform.a;\n    offData[i + 0] = r;\n    offData[i + 1] = g;\n    offData[i + 2] = b;\n    offData[i + 3] = a;\n  }\n\n  // Commit the changes\n  c2dOff.putImageData(offImage, 0, 0);\n\n  // Convert transformed image into an ImageBitmap object.\n  // I *think* this provides better performance than returning an offscreenCanvas, but I'm not 100% sure.\n  var transformedImageBitmap = offscreenCanvas.transferToImageBitmap();\n  // transformedImageBitmap.close()  // DON'T close.\n  return transformedImageBitmap;\n\n  // Alternatively, just return the offscreenCanvas - but this may result in a performance cost.\n  // return offscreenCanvas\n}\n\n//# sourceURL=webpack://cny2026/./src/avo/misc.js?");

/***/ }),

/***/ "./src/avo/physics.js":
/*!****************************!*\
  !*** ./src/avo/physics.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Physics)\n/* harmony export */ });\n/* harmony import */ var _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/constants.js */ \"./src/avo/constants.js\");\n/* harmony import */ var _avo_misc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @avo/misc.js */ \"./src/avo/misc.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\nvar USE_CIRCLE_APPROXIMATION = false;\nvar Physics = /*#__PURE__*/function () {\n  function Physics() {\n    _classCallCheck(this, Physics);\n  }\n  return _createClass(Physics, null, [{\n    key: \"checkCollision\",\n    value:\n    //----------------------------------------------------------------\n\n    /*\r\n    Checks if objA is touching objB.\r\n    - If true, returns the corrected coordinates for objA and objB, in form:\r\n      { a: { x, y },\r\n        b: { x, y } }\r\n    - If false, returns null.\r\n     */\n    function checkCollision(objA, objB) {\n      if (!objA || !objB || objA === objB) return null;\n\n      // Circle + Circle collision\n      if (objA.shape === _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.SHAPES.CIRCLE && objB.shape === _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.SHAPES.CIRCLE) {\n        return Physics.checkCollision_circleCircle(objA, objB);\n      }\n\n      // Polygon + Polygon collision. (Squares are polygons, of course.)\n      else if ((objA.shape === _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.SHAPES.SQUARE || objA.shape === _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.SHAPES.POLYGON) && (objB.shape === _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.SHAPES.SQUARE || objB.shape === _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.SHAPES.POLYGON)) {\n        return Physics.checkCollision_polygonPolygon(objA, objB);\n      }\n\n      // Circle + Polygon collision.\n      else if (objA.shape === _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.SHAPES.CIRCLE && (objB.shape === _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.SHAPES.SQUARE || objB.shape === _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.SHAPES.POLYGON)) {\n        if (USE_CIRCLE_APPROXIMATION) return Physics.checkCollision_polygonPolygon(objA, objB);\n        return Physics.checkCollision_circlePolygon(objA, objB);\n      }\n\n      // Polygon + Circle collision\n      // It's the reverse of the previous scenario.\n      else if ((objA.shape === _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.SHAPES.SQUARE || objA.shape === _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.SHAPES.POLYGON) && objB.shape === _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.SHAPES.CIRCLE) {\n        if (USE_CIRCLE_APPROXIMATION) return Physics.checkCollision_polygonPolygon(objA, objB);\n        var correction = Physics.checkCollision_circlePolygon(objB, objA);\n        if (correction) {\n          correction = {\n            a: correction.b,\n            b: correction.a\n          };\n        }\n        return correction;\n      }\n      return null;\n    }\n    //----------------------------------------------------------------\n  }, {\n    key: \"checkCollision_circleCircle\",\n    value: function checkCollision_circleCircle(objA, objB) {\n      var fractionA = 0;\n      var fractionB = 0;\n      if (!objA.solid || !objB.solid) {\n        //If either object isn't solid, there's no collision correction.\n      } else if (objA.movable && objB.movable) {\n        fractionA = 0.5;\n        fractionB = 0.5;\n      } else if (objA.movable) {\n        fractionA = 1;\n      } else if (objB.movable) {\n        fractionB = 1;\n      }\n      var distX = objB.x - objA.x;\n      var distY = objB.y - objA.y;\n      var dist = Math.sqrt(distX * distX + distY * distY);\n      var minimumDist = objA.radius + objB.radius;\n      if (dist < minimumDist) {\n        var angle = Math.atan2(distY, distX);\n        var correctDist = minimumDist;\n        var cosAngle = Math.cos(angle);\n        var sinAngle = Math.sin(angle);\n        var motion = Physics.getPostCollisionMotion(objA, objB);\n        return {\n          a: {\n            x: objA.x - cosAngle * (correctDist - dist) * fractionA,\n            y: objA.y - sinAngle * (correctDist - dist) * fractionA,\n            pushX: motion && motion.a.pushX,\n            pushY: motion && motion.a.pushY\n          },\n          b: {\n            x: objB.x + cosAngle * (correctDist - dist) * fractionB,\n            y: objB.y + sinAngle * (correctDist - dist) * fractionB,\n            pushX: motion && motion.b.pushX,\n            pushY: motion && motion.b.pushY\n          }\n        };\n      }\n      return null;\n    }\n\n    //----------------------------------------------------------------\n  }, {\n    key: \"checkCollision_polygonPolygon\",\n    value: function checkCollision_polygonPolygon(objA, objB) {\n      var fractionA = 0;\n      var fractionB = 0;\n      if (!objA.solid || !objB.solid) {\n        //If either object isn't solid, there's no collision correction.\n      } else if (objA.movable && objB.movable) {\n        fractionA = 0.5;\n        fractionB = 0.5;\n      } else if (objA.movable) {\n        fractionA = 1;\n      } else if (objB.movable) {\n        fractionB = 1;\n      }\n      var correction = null;\n      var verticesA = objA.vertices;\n      var verticesB = objB.vertices;\n      var projectionAxes = [].concat(_toConsumableArray(Physics.getShapeNormals(objA)), _toConsumableArray(Physics.getShapeNormals(objB)));\n      for (var i = 0; i < projectionAxes.length; i++) {\n        var axis = projectionAxes[i];\n        var projectionA = {\n          min: Infinity,\n          max: -Infinity\n        };\n        var projectionB = {\n          min: Infinity,\n          max: -Infinity\n        };\n        for (var j = 0; j < verticesA.length; j++) {\n          var val = Physics.dotProduct(axis, verticesA[j]);\n          projectionA.min = Math.min(projectionA.min, val);\n          projectionA.max = Math.max(projectionA.max, val);\n        }\n        for (var _j = 0; _j < verticesB.length; _j++) {\n          var _val = Physics.dotProduct(axis, verticesB[_j]);\n          projectionB.min = Math.min(projectionB.min, _val);\n          projectionB.max = Math.max(projectionB.max, _val);\n        }\n        var overlap = Math.max(0, Math.min(projectionA.max, projectionB.max) - Math.max(projectionA.min, projectionB.min));\n        if (!correction || overlap < correction.magnitude) {\n          var sign = Math.sign(projectionB.min + projectionB.max - (projectionA.min + projectionA.max));\n          correction = {\n            magnitude: overlap,\n            x: axis.x * overlap * sign,\n            y: axis.y * overlap * sign\n          };\n        }\n      }\n      if (correction && correction.magnitude > 0) {\n        return {\n          a: {\n            x: objA.x - correction.x * fractionA,\n            y: objA.y - correction.y * fractionA\n          },\n          b: {\n            x: objB.x + correction.x * fractionB,\n            y: objB.y + correction.y * fractionB\n          }\n        };\n      }\n      return null;\n    }\n\n    //----------------------------------------------------------------\n  }, {\n    key: \"checkCollision_circlePolygon\",\n    value: function checkCollision_circlePolygon(objA, objB) {\n      var fractionA = 0;\n      var fractionB = 0;\n      if (!objA.solid || !objB.solid) {\n        //If either object isn't solid, there's no collision correction.\n      } else if (objA.movable && objB.movable) {\n        fractionA = 0.5;\n        fractionB = 0.5;\n      } else if (objA.movable) {\n        fractionA = 1;\n      } else if (objB.movable) {\n        fractionB = 1;\n      }\n      var distX = objB.x - objA.x;\n      var distY = objB.y - objA.y;\n      var dist = Math.sqrt(distX * distX + distY * distY);\n      var centreToCentreAxis = dist !== 0 ? {\n        x: distX / dist,\n        y: distY / dist\n      } : {\n        x: 0,\n        y: 0\n      };\n      var correction = null;\n      var verticesB = objB.vertices;\n      var projectionAxes = [centreToCentreAxis].concat(_toConsumableArray(Physics.getShapeNormals(objB)));\n      for (var i = 0; i < projectionAxes.length; i++) {\n        var axis = projectionAxes[i];\n        var scalarA = Physics.dotProduct(axis, {\n          x: objA.x,\n          y: objA.y\n        });\n        var projectionA = {\n          min: scalarA - objA.radius,\n          max: scalarA + objA.radius\n        };\n        var projectionB = {\n          min: Infinity,\n          max: -Infinity\n        };\n        for (var j = 0; j < verticesB.length; j++) {\n          var val = Physics.dotProduct(axis, verticesB[j]);\n          projectionB.min = Math.min(projectionB.min, val);\n          projectionB.max = Math.max(projectionB.max, val);\n        }\n        var overlap = Math.max(0, Math.min(projectionA.max, projectionB.max) - Math.max(projectionA.min, projectionB.min));\n        if (!correction || overlap < correction.magnitude) {\n          var sign = Math.sign(projectionB.min + projectionB.max - (projectionA.min + projectionA.max));\n          correction = {\n            magnitude: overlap,\n            x: axis.x * overlap * sign,\n            y: axis.y * overlap * sign\n          };\n        }\n      }\n      if (correction && correction.magnitude > 0) {\n        return {\n          a: {\n            x: objA.x - correction.x * fractionA,\n            y: objA.y - correction.y * fractionA\n          },\n          b: {\n            x: objB.x + correction.x * fractionB,\n            y: objB.y + correction.y * fractionB\n          }\n        };\n      }\n    }\n\n    //----------------------------------------------------------------\n\n    /*  Gets the NORMALISED normals for each edge of the object's shape. Assumes the object has the 'vertices' property.\r\n     */\n  }, {\n    key: \"getShapeNormals\",\n    value: function getShapeNormals(obj) {\n      var vertices = obj.vertices;\n      if (!vertices) return null;\n      if (vertices.length < 2) return []; //Look, you need to have at least three vertices to be a shape.\n\n      //First, calculate the edges connecting each vertice.\n      //--------------------------------\n      var edges = [];\n      for (var i = 0; i < vertices.length; i++) {\n        var p1 = vertices[i];\n        var p2 = vertices[(i + 1) % vertices.length];\n        edges.push({\n          x: p2.x - p1.x,\n          y: p2.y - p1.y\n        });\n      }\n      //--------------------------------\n\n      //Calculate the NORMALISED normals for each edge.\n      //--------------------------------\n      return edges.map(function (edge) {\n        var dist = Math.sqrt(edge.x * edge.x + edge.y * edge.y);\n        if (dist === 0) return {\n          x: 0,\n          y: 0\n        };\n        return {\n          x: -edge.y / dist,\n          y: edge.x / dist\n        };\n      });\n      //--------------------------------\n    }\n\n    //----------------------------------------------------------------\n  }, {\n    key: \"getPostCollisionMotion\",\n    value: function getPostCollisionMotion(objA, objB) {\n      if (!objA || !objB) return null;\n      if (!objA.movable || !objA.solid || objA.mass === 0 || !objB.movable || !objB.solid || objB.mass === 0 || objA.mass + objB.mass === 0) return null;\n      var collisionAngle = Math.atan2(objB.y - objA.y, objB.x - objA.x);\n      var ANGLE_90 = Math.PI / 2;\n      var totalMass = objA.mass + objB.mass;\n      var aSpd = objA.pushSpeed;\n      var bSpd = objB.pushSpeed;\n      var aAng = objA.pushAngle;\n      var bAng = objB.pushAngle;\n      var aMass = objA.mass;\n      var bMass = objB.mass;\n      var aGroup = (aSpd * Math.cos(aAng - collisionAngle) * (aMass - bMass) + 2 * bMass * bSpd * Math.cos(bAng - collisionAngle)) / totalMass;\n      var bGroup = (bSpd * Math.cos(bAng - collisionAngle) * (bMass - aMass) + 2 * aMass * aSpd * Math.cos(aAng - collisionAngle)) / totalMass;\n      var objA_pushX = aGroup * Math.cos(collisionAngle) + aSpd * Math.sin(aAng - collisionAngle) * Math.cos(collisionAngle + ANGLE_90);\n      var objA_pushY = aGroup * Math.sin(collisionAngle) + aSpd * Math.sin(aAng - collisionAngle) * Math.sin(collisionAngle + ANGLE_90);\n      var objB_pushX = bGroup * Math.cos(collisionAngle) + bSpd * Math.sin(bAng - collisionAngle) * Math.cos(collisionAngle + ANGLE_90);\n      var objB_pushY = bGroup * Math.sin(collisionAngle) + bSpd * Math.sin(bAng - collisionAngle) * Math.sin(collisionAngle + ANGLE_90);\n      return {\n        a: {\n          pushX: objA_pushX,\n          pushY: objA_pushY\n        },\n        b: {\n          pushX: objB_pushX,\n          pushY: objB_pushY\n        }\n      };\n    }\n\n    //----------------------------------------------------------------\n  }, {\n    key: \"dotProduct\",\n    value: function dotProduct(vectorA, vectorB) {\n      if (!vectorA || !vectorB) return null;\n      return vectorA.x * vectorB.x + vectorA.y * vectorB.y;\n    }\n\n    //----------------------------------------------------------------\n\n    /*\r\n    Calculate intersection between two lines (a ray and a segment of a polygon).\r\n    Useful for determining valids line of sight.\r\n      - Each line is in the format { start: { x, y }, end: { x, y } }\r\n    - Returns null if there's no intersection.\r\n    - Returns { x, y, distanceFactor } if there's an intersection.\r\n      x, y are the coordinates of the intersection point.\r\n      distanceFactor is how far from the ray's origin point the intersection\r\n      occurs. If 1, intersection occurs at the ray's end point. If 0.5,\r\n      intersection occurs halfway between the ray's origin point and end point.\r\n      Original code from https://ncase.me/sight-and-light/\r\n     */\n  }, {\n    key: \"getLineIntersection\",\n    value: function getLineIntersection(ray, segment) {\n      // Each line is represented in the format:\n      // line = originPoint + directionVector * distanceFactor\n      // Or a bit more simply:\n      // line = origin (o) + direction (d) * factor (f)\n\n      // Ray\n      var r_ox = ray.start.x;\n      var r_oy = ray.start.y;\n      var r_dx = ray.end.x - ray.start.x;\n      var r_dy = ray.end.y - ray.start.y;\n\n      // Segment\n      var s_ox = segment.start.x;\n      var s_oy = segment.start.y;\n      var s_dx = segment.end.x - segment.start.x;\n      var s_dy = segment.end.y - segment.start.y;\n\n      // The intersection occurs where ray.x === segment.x and ray.y === segment.y\n      // So, we need to solve for r_factor and s_factor in...\n      // r_ox + r_dx * r_factor = s_ox + s_dx * s_factor && r_oy + r_dy * r_factor = s_oy + s_dy * s_factor\n      var r_factor = null;\n      var s_factor = null;\n      if (!(0,_avo_misc_js__WEBPACK_IMPORTED_MODULE_1__.isZero)(s_dx * r_dy - s_dy * r_dx)) {\n        // Solve for s_factor.\n        s_factor = (r_dx * (s_oy - r_oy) + r_dy * (r_ox - s_ox)) / (s_dx * r_dy - s_dy * r_dx);\n\n        // There are two ways to solve for r_factor; one works when the ray\n        // isn't perfectly horizontal, the other works when the ray isn't\n        // perfectly vertical.\n        if (!(0,_avo_misc_js__WEBPACK_IMPORTED_MODULE_1__.isZero)(r_dx)) {\n          r_factor = (s_ox + s_dx * s_factor - r_ox) / r_dx;\n        } else if (!(0,_avo_misc_js__WEBPACK_IMPORTED_MODULE_1__.isZero)(r_dy)) {\n          r_factor = (s_oy + s_dy * s_factor - r_oy) / r_dy;\n        }\n      }\n\n      // Check if the intersection occurs within the length of both lines.\n      // (The maths above calculates for infinitely long lines.)\n      if (r_factor === null || s_factor === null || r_factor < 0 || r_factor > 1 || s_factor < 0 || s_factor > 1) return null;\n\n      // Point of intersection\n      return {\n        x: r_ox + r_dx * r_factor,\n        y: r_oy + r_dy * r_factor,\n        distanceFactor: r_factor\n      };\n    }\n\n    //----------------------------------------------------------------\n  }]);\n}();\n\n\n//# sourceURL=webpack://cny2026/./src/avo/physics.js?");

/***/ }),

/***/ "./src/avo/rule/examples/zelda-controls.js":
/*!*************************************************!*\
  !*** ./src/avo/rule/examples/zelda-controls.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ZeldaControls)\n/* harmony export */ });\n/* harmony import */ var _avo_rule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/rule */ \"./src/avo/rule/index.js\");\n/* harmony import */ var _avo_physics_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @avo/physics.js */ \"./src/avo/physics.js\");\n/* harmony import */ var _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @avo/constants.js */ \"./src/avo/constants.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && \"function\" == typeof p ? function (t) { return p.apply(e, t); } : p; }\nfunction _get() { return _get = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }\nfunction _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n\n\n\n\n/*\r\nStandard player controls for top-down adventure games.\r\n */\nvar ZeldaControls = /*#__PURE__*/function (_Rule) {\n  function ZeldaControls(app) {\n    var _this;\n    _classCallCheck(this, ZeldaControls);\n    _this = _callSuper(this, ZeldaControls, [app]);\n    _this._type = 'zelda-controls';\n    _this.inputTap = false;\n    _this.onPointerTap = _this.onPointerTap.bind(_this);\n    app.addEventListener('pointertap', _this.onPointerTap);\n    return _this;\n  }\n  _inherits(ZeldaControls, _Rule);\n  return _createClass(ZeldaControls, [{\n    key: \"deconstructor\",\n    value: function deconstructor() {\n      app.removeEventListener('pointertap', this.onPointerTap);\n    }\n  }, {\n    key: \"play\",\n    value: function play() {\n      var app = this._app;\n      var hero = app.hero;\n      _superPropGet(ZeldaControls, \"play\", this, 3)([]);\n      if (hero) {\n        var _app$playerInput = app.playerInput,\n          keysPressed = _app$playerInput.keysPressed,\n          pointerCurrent = _app$playerInput.pointerCurrent,\n          pointerStart = _app$playerInput.pointerStart,\n          pointerState = _app$playerInput.pointerState;\n        var intent = undefined;\n        var directionX = 0;\n        var directionY = 0;\n        if (pointerState === _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.POINTER_STATES.POINTER_DOWN) {\n          // Get pointer input if there's any.\n\n          var distX = pointerCurrent.x - pointerStart.x;\n          var distY = pointerCurrent.y - pointerStart.y;\n          var pointerDistance = Math.sqrt(distX * distX + distY * distY);\n          // const movementAngle = Math.atan2(distY, distX)\n\n          if (pointerDistance > _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.POINTER_DEADZONE_RADIUS) {\n            directionX = distX / pointerDistance;\n            directionY = distY / pointerDistance;\n          }\n        } else {\n          // Otherwise, check for keyboard input.\n\n          if (keysPressed['ArrowRight']) directionX++;\n          if (keysPressed['ArrowDown']) directionY++;\n          if (keysPressed['ArrowLeft']) directionX--;\n          if (keysPressed['ArrowUp']) directionY--;\n        }\n        if (keysPressed['z'] && !keysPressed['z'].acknowledged || keysPressed['Z'] && !keysPressed['Z'].acknowledged || this.inputTap) {\n          intent = {\n            name: 'dash',\n            directionX: directionX,\n            directionY: directionY\n          };\n          if (keysPressed['z']) keysPressed['z'].acknowledged = true;\n          if (keysPressed['Z']) keysPressed['Z'].acknowledged = true;\n          this.inputTap = false;\n        } else if (directionX || directionY) {\n          intent = {\n            name: 'move',\n            directionX: directionX,\n            directionY: directionY\n          };\n        }\n        hero.intent = intent;\n      }\n    }\n  }, {\n    key: \"paint\",\n    value: function paint() {\n      var layer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var hero = this._app.hero;\n      if (layer === _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.LAYERS.OVERLAY) {\n        this.paintUIData();\n        this.paintPointerInput();\n      } else if (layer === _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.LAYERS.BOTTOM) {\n        this.paintLineOfSight(hero);\n      }\n    }\n\n    /*\r\n    Draw UI data, such as Hero health.\r\n     */\n  }, {\n    key: \"paintUIData\",\n    value: function paintUIData() {\n      var _hero$action;\n      var c2d = this._app.canvas2d;\n      var hero = this._app.hero;\n      var X_OFFSET = _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.TILE_SIZE * 1.5;\n      var Y_OFFSET = _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.TILE_SIZE * -1.0;\n      var LEFT = X_OFFSET;\n      var RIGHT = this._app.canvasWidth - X_OFFSET;\n      var BOTTOM = this._app.canvasHeight + Y_OFFSET;\n      c2d.font = '2em Source Code Pro';\n      c2d.textBaseline = 'bottom';\n      c2d.lineWidth = 8;\n      var health = Math.max(hero === null || hero === void 0 ? void 0 : hero.health, 0) || 0;\n      var text = ''.repeat(health);\n      c2d.textAlign = 'left';\n      c2d.strokeStyle = '#fff';\n      c2d.strokeText(text, LEFT, BOTTOM);\n      c2d.fillStyle = '#c44';\n      c2d.fillText(text, LEFT, BOTTOM);\n      text = (hero === null || hero === void 0 || (_hero$action = hero.action) === null || _hero$action === void 0 ? void 0 : _hero$action.name) + ' (' + (hero === null || hero === void 0 ? void 0 : hero.moveSpeed.toFixed(2)) + ')';\n      c2d.textAlign = 'right';\n      c2d.strokeStyle = '#fff';\n      c2d.strokeText(text, RIGHT, BOTTOM);\n      c2d.fillStyle = '#c44';\n      c2d.fillText(text, RIGHT, BOTTOM);\n    }\n\n    /*\r\n    Draw pointer input, if any. This helps players get visual feedback on their\r\n    touchscreens.\r\n     */\n  }, {\n    key: \"paintPointerInput\",\n    value: function paintPointerInput() {\n      var c2d = this._app.canvas2d;\n      var _this$_app$playerInpu = this._app.playerInput,\n        pointerCurrent = _this$_app$playerInpu.pointerCurrent,\n        pointerStart = _this$_app$playerInpu.pointerStart,\n        pointerState = _this$_app$playerInpu.pointerState;\n      var START_POINT_RADIUS = _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.TILE_SIZE * 1,\n        CURRENT_POINT_RADIUS = _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.TILE_SIZE * 0.5;\n      if (pointerState === _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.POINTER_STATES.POINTER_DOWN) {\n        c2d.lineWidth = Math.floor(Math.min(_avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.TILE_SIZE * 0.125, 2));\n        c2d.fillStyle = '#80808080';\n        c2d.strokeStyle = '#80808080';\n        c2d.beginPath();\n        c2d.arc(pointerStart.x, pointerStart.y, START_POINT_RADIUS, 0, 2 * Math.PI);\n        c2d.stroke();\n        c2d.beginPath();\n        c2d.arc(pointerCurrent.x, pointerCurrent.y, CURRENT_POINT_RADIUS, 0, 2 * Math.PI);\n        c2d.fill();\n        c2d.beginPath();\n        c2d.moveTo(pointerStart.x, pointerStart.y);\n        c2d.lineTo(pointerCurrent.x, pointerCurrent.y);\n        c2d.stroke();\n      }\n    }\n\n    /*\r\n    Draw a line of sight (cast a ray) starting from a specified Entity (usually the\r\n    hero), in the direction they're facing.\r\n     */\n  }, {\n    key: \"paintLineOfSight\",\n    value: function paintLineOfSight(srcEntity) {\n      if (!srcEntity) return;\n      var c2d = this._app.canvas2d;\n      var camera = this._app.camera;\n      var entities = this._app.entities;\n      var MAX_LINE_OF_SIGHT_DISTANCE = _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.TILE_SIZE * 5;\n      this._app.applyCameraTransforms();\n\n      // Intended line of sight, i.e. a ray starting from the hero/source Entity.\n      var lineOfSight = {\n        start: {\n          x: srcEntity.x,\n          y: srcEntity.y\n        },\n        end: {\n          x: srcEntity.x + MAX_LINE_OF_SIGHT_DISTANCE * Math.cos(srcEntity.rotation),\n          y: srcEntity.y + MAX_LINE_OF_SIGHT_DISTANCE * Math.sin(srcEntity.rotation)\n        }\n      };\n      var actualLineOfSightEndPoint = undefined;\n\n      // For each other Entity, see if it intersects with the source Entity's LOS\n      entities.forEach(function (entity) {\n        if (entity === srcEntity) return;\n\n        // TODO: check for opaqueness and/or if the entity is visible.\n\n        var vertices = entity.vertices;\n        if (vertices.length < 2) return;\n\n        // Every entity has a \"shape\" that can be represented by a polygon.\n        // (Yes, even circles.) Check each segment (aka edge aka side) of the\n        // polygon.\n        for (var i = 0; i < vertices.length; i++) {\n          var segment = {\n            start: {\n              x: vertices[i].x,\n              y: vertices[i].y\n            },\n            end: {\n              x: vertices[(i + 1) % vertices.length].x,\n              y: vertices[(i + 1) % vertices.length].y\n            }\n          };\n\n          // Find the intersection. We want to find the intersection point\n          // closest to the source Entity (the LOS ray's starting point).\n          var intersection = _avo_physics_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getLineIntersection(lineOfSight, segment);\n          if (!actualLineOfSightEndPoint || intersection && intersection.distanceFactor < actualLineOfSightEndPoint.distanceFactor) {\n            actualLineOfSightEndPoint = intersection;\n          }\n        }\n      });\n      if (!actualLineOfSightEndPoint) {\n        actualLineOfSightEndPoint = {\n          x: srcEntity.x + MAX_LINE_OF_SIGHT_DISTANCE * Math.cos(srcEntity.rotation),\n          y: srcEntity.y + MAX_LINE_OF_SIGHT_DISTANCE * Math.sin(srcEntity.rotation)\n        };\n      }\n\n      // Expected line of sight\n      c2d.beginPath();\n      c2d.moveTo(lineOfSight.start.x, lineOfSight.start.y);\n      c2d.lineTo(lineOfSight.end.x, lineOfSight.end.y);\n      c2d.strokeStyle = '#c08080';\n      c2d.lineWidth = 3;\n      c2d.stroke();\n      c2d.setLineDash([]);\n\n      // Actual line of sight\n      c2d.beginPath();\n      c2d.moveTo(lineOfSight.start.x, lineOfSight.start.y);\n      c2d.lineTo(actualLineOfSightEndPoint.x, actualLineOfSightEndPoint.y);\n      c2d.strokeStyle = '#3399ff';\n      c2d.lineWidth = 3;\n      c2d.stroke();\n\n      // Expected end of line of sight\n      c2d.beginPath();\n      c2d.arc(lineOfSight.end.x, lineOfSight.end.y, 4, 0, 2 * Math.PI);\n      c2d.fillStyle = '#c08080';\n      c2d.fill();\n\n      // Actual end of line of sight\n      c2d.beginPath();\n      c2d.arc(actualLineOfSightEndPoint.x, actualLineOfSightEndPoint.y, 8, 0, 2 * Math.PI);\n      c2d.fillStyle = '#3399ff';\n      c2d.fill();\n      this._app.undoCameraTransforms();\n    }\n  }, {\n    key: \"onPointerTap\",\n    value: function onPointerTap() {\n      this.inputTap = true;\n    }\n  }]);\n}(_avo_rule__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n\n//# sourceURL=webpack://cny2026/./src/avo/rule/examples/zelda-controls.js?");

/***/ }),

/***/ "./src/avo/rule/index.js":
/*!*******************************!*\
  !*** ./src/avo/rule/index.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _rule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rule.js */ \"./src/avo/rule/rule.js\");\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_rule_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n//# sourceURL=webpack://cny2026/./src/avo/rule/index.js?");

/***/ }),

/***/ "./src/avo/rule/rule.js":
/*!******************************!*\
  !*** ./src/avo/rule/rule.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Rule)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar Rule = /*#__PURE__*/function () {\n  function Rule(app) {\n    _classCallCheck(this, Rule);\n    this._app = app;\n    this._type = 'rule';\n    this.name = ''; // Optional identifier\n\n    // Expired rules are removed at the end of the cycle.\n    this._expired = false;\n  }\n  return _createClass(Rule, [{\n    key: \"deconstructor\",\n    value: function deconstructor() {}\n\n    /*\r\n    Section: General Logic\r\n    ----------------------------------------------------------------------------\r\n     */\n  }, {\n    key: \"play\",\n    value: function play() {}\n  }, {\n    key: \"paint\",\n    value: function paint() {\n      var layer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    }\n  }]);\n}();\n\n\n//# sourceURL=webpack://cny2026/./src/avo/rule/rule.js?");

/***/ }),

/***/ "./src/avo/story/examples/example-story.js":
/*!*************************************************!*\
  !*** ./src/avo/story/examples/example-story.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ExampleStory)\n/* harmony export */ });\n/* harmony import */ var _story__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../story */ \"./src/avo/story/story.js\");\n/* harmony import */ var _avo_image_asset_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @avo/image-asset.js */ \"./src/avo/image-asset.js\");\n/* harmony import */ var _avo_entity_examples_hero_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @avo/entity/examples/hero.js */ \"./src/avo/entity/examples/hero.js\");\n/* harmony import */ var _avo_entity_examples_wall_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @avo/entity/examples/wall.js */ \"./src/avo/entity/examples/wall.js\");\n/* harmony import */ var _avo_entity_examples_ball_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @avo/entity/examples/ball.js */ \"./src/avo/entity/examples/ball.js\");\n/* harmony import */ var _avo_entity_examples_enemy_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @avo/entity/examples/enemy.js */ \"./src/avo/entity/examples/enemy.js\");\n/* harmony import */ var _avo_rule_examples_zelda_controls_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @avo/rule/examples/zelda-controls.js */ \"./src/avo/rule/examples/zelda-controls.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && \"function\" == typeof p ? function (t) { return p.apply(e, t); } : p; }\nfunction _get() { return _get = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }\nfunction _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n\n\n\n\n\n\n\nvar ExampleStory = /*#__PURE__*/function (_Story) {\n  function ExampleStory(app) {\n    var _this;\n    _classCallCheck(this, ExampleStory);\n    _this = _callSuper(this, ExampleStory, [app]);\n    _this.assets = {\n      \"hero-4dir\": new _avo_image_asset_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]('assets/avo-sprites-2022-05-samiel.png')\n    };\n    return _this;\n  }\n  _inherits(ExampleStory, _Story);\n  return _createClass(ExampleStory, [{\n    key: \"start\",\n    value: function start() {\n      _superPropGet(ExampleStory, \"start\", this, 3)([]);\n      this.generate_zelda_default();\n    }\n\n    /*\r\n    Default top-down adventure level.\r\n     */\n  }, {\n    key: \"generate_zelda_default\",\n    value: function generate_zelda_default() {\n      var app = this._app;\n      app.hero = app.addEntity(new _avo_entity_examples_hero_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](app, 11, 1));\n      app.camera.target = app.hero;\n      app.addRule(new _avo_rule_examples_zelda_controls_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](app));\n      app.addEntity(new _avo_entity_examples_wall_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](app, 0, 0, 1, 23)); // West Wall\n      app.addEntity(new _avo_entity_examples_wall_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](app, 22, 0, 1, 23)); // East Wall\n      app.addEntity(new _avo_entity_examples_wall_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](app, 1, 0, 21, 1)); // North Wall\n      app.addEntity(new _avo_entity_examples_wall_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](app, 1, 22, 21, 1)); // South Wall\n      app.addEntity(new _avo_entity_examples_wall_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](app, 3, 2, 3, 1));\n      app.addEntity(new _avo_entity_examples_wall_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](app, 3, 4, 3, 1));\n      app.addEntity(new _avo_entity_examples_ball_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"](app, 8, 6));\n      var enemy = app.addEntity(new _avo_entity_examples_enemy_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"](app, 4, 8));\n      enemy.rotation = -45 / 180 * Math.PI;\n    }\n  }]);\n}(_story__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n\n//# sourceURL=webpack://cny2026/./src/avo/story/examples/example-story.js?");

/***/ }),

/***/ "./src/avo/story/index.js":
/*!********************************!*\
  !*** ./src/avo/story/index.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _story_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./story.js */ \"./src/avo/story/story.js\");\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_story_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n//# sourceURL=webpack://cny2026/./src/avo/story/index.js?");

/***/ }),

/***/ "./src/avo/story/story.js":
/*!********************************!*\
  !*** ./src/avo/story/story.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Story)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar Story = /*#__PURE__*/function () {\n  function Story(app) {\n    _classCallCheck(this, Story);\n    this._app = app;\n    this.assets = {};\n  }\n\n  /*\r\n  Section: Main Scripts\r\n  ----------------------------------------------------------------------------\r\n   */\n  return _createClass(Story, [{\n    key: \"start\",\n    value: function start() {\n      this.reset();\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      var app = this._app;\n      app.hero = undefined;\n      app.clearEntities();\n      app.resetGameMap();\n      app.clearRules();\n      app.resetCamera();\n      app.resetPlayerInput();\n      app.setInteractionMenu(false);\n    }\n  }, {\n    key: \"reload\",\n    value: function reload() {\n      this.start();\n    }\n  }]);\n}();\n\n\n//# sourceURL=webpack://cny2026/./src/avo/story/story.js?");

/***/ }),

/***/ "./src/avo/tile/index.js":
/*!*******************************!*\
  !*** ./src/avo/tile/index.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _tile_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tile.js */ \"./src/avo/tile/tile.js\");\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_tile_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n//# sourceURL=webpack://cny2026/./src/avo/tile/index.js?");

/***/ }),

/***/ "./src/avo/tile/tile.js":
/*!******************************!*\
  !*** ./src/avo/tile/tile.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Tile)\n/* harmony export */ });\n/* harmony import */ var _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/constants.js */ \"./src/avo/constants.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar Tile = /*#__PURE__*/function () {\n  function Tile(app) {\n    var col = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var row = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    _classCallCheck(this, Tile);\n    this._app = app;\n    this._type = 'tile';\n    this.colour = '#f0f0f0';\n    this.solid = false;\n    this.movable = false;\n    this.mass = 100;\n    this.x = 0; // This will be set by col\n    this.y = 0; // This will be set by row\n    this.col = col;\n    this.row = row;\n    this.size = _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE;\n    this.shape = _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.SHAPES.SQUARE;\n\n    // Animation\n    this.spriteSheet = undefined; // // Image object (e.g. app.assets['map'].img)\n    this.spriteSizeX = 16; // Size of each sprite on the sprite sheet\n    this.spriteSizeY = 16;\n    this.spriteScale = 2; // Scale of the sprite when paint()ed\n    this.spriteOffsetX = -8; // Offset of the sprite when paint()ed\n    this.spriteOffsetY = -8;\n  }\n  return _createClass(Tile, [{\n    key: \"play\",\n    value: function play() {\n      console.error('Tile.play() should never be called.');\n    }\n  }, {\n    key: \"paint\",\n    value: function paint(layer) {\n      var c2d = this._app.canvas2d;\n      this._app.applyCameraTransforms();\n      if (layer === _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.LAYERS.BOTTOM) {\n        c2d.fillStyle = this.colour;\n        c2d.strokeStyle = '#ffffff';\n        c2d.lineWidth = 1;\n        c2d.beginPath();\n        c2d.rect(Math.floor(this.x - this.size / 2), Math.floor(this.y - this.size / 2), this.size, this.size);\n        c2d.fill();\n        c2d.stroke();\n      }\n      this._app.undoCameraTransforms();\n    }\n\n    /*\r\n    Paint the tiles's sprite, at the tile's position.\r\n    Note: only specify values for args if you want to override the automatic\r\n    calculations.\r\n     */\n  }, {\n    key: \"paintSprite\",\n    value: function paintSprite() {\n      var _args$spriteCol, _args$spriteRow, _args$spriteScale, _args$spriteOffsetX, _args$spriteOffsetY;\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n        spriteCol: undefined,\n        spriteRow: undefined,\n        spriteOffsetX: undefined,\n        spriteOffsetY: undefined,\n        spriteScale: undefined\n      };\n      var app = this._app;\n      var c2d = app.canvas2d;\n      if (!this.spriteSheet) return;\n      app.applyCameraTransforms();\n      var srcX = ((_args$spriteCol = args === null || args === void 0 ? void 0 : args.spriteCol) !== null && _args$spriteCol !== void 0 ? _args$spriteCol : this.getSpriteCol()) * this.spriteSizeX;\n      var srcY = ((_args$spriteRow = args === null || args === void 0 ? void 0 : args.spriteRow) !== null && _args$spriteRow !== void 0 ? _args$spriteRow : this.getSpriteRow()) * this.spriteSizeY;\n      var sizeX = this.spriteSizeX;\n      var sizeY = this.spriteSizeY;\n      var scale = (_args$spriteScale = args === null || args === void 0 ? void 0 : args.spriteScale) !== null && _args$spriteScale !== void 0 ? _args$spriteScale : this.spriteScale;\n      c2d.translate(this.x, this.y);\n      c2d.scale(scale, scale);\n      var tgtX = (_args$spriteOffsetX = args === null || args === void 0 ? void 0 : args.spriteOffsetX) !== null && _args$spriteOffsetX !== void 0 ? _args$spriteOffsetX : this.spriteOffsetX;\n      var tgtY = (_args$spriteOffsetY = args === null || args === void 0 ? void 0 : args.spriteOffsetY) !== null && _args$spriteOffsetY !== void 0 ? _args$spriteOffsetY : this.spriteOffsetY;\n      c2d.drawImage(this.spriteSheet, srcX, srcY, sizeX, sizeY, tgtX, tgtY, sizeX, sizeY);\n      app.undoCameraTransforms();\n    }\n\n    /*\r\n    Section: Event Handling\r\n    ----------------------------------------------------------------------------\r\n     */\n  }, {\n    key: \"onCollision\",\n    value: function onCollision(target, collisionCorrection) {}\n\n    /*\r\n    Section: Animation\r\n    ----------------------------------------------------------------------------\r\n     */\n  }, {\n    key: \"getSpriteCol\",\n    value: function getSpriteCol() {\n      return 0;\n    }\n  }, {\n    key: \"getSpriteRow\",\n    value: function getSpriteRow() {\n      return 0;\n    }\n\n    /*\r\n    Section: Map Logic\r\n    ----------------------------------------------------------------------------\r\n     */\n\n    /*\r\n    Checks if this tile has similar neighbour tiles. Returns an integer from 0 to\r\n    15, that indicates on which directions (NESW) that there's a similar tile.\r\n    (e.g. a return value of 3 indicates there's a tile similar to this tile on the\r\n    NORTH, and another one on the EAST. the See TILE_ADJACENCIES for details.)\r\n    This function is usually used to see if a map tile should be \"contiguous\" with\r\n    its neighbours.\r\n     */\n  }, {\n    key: \"checkSimilarAdjacencies\",\n    value: function checkSimilarAdjacencies() {\n      var _this$getAdjacentTile, _this$getAdjacentTile2, _this$getAdjacentTile3, _this$getAdjacentTile4;\n      var gameMap = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n      var adjacencies = 0;\n      if (((_this$getAdjacentTile = this.getAdjacentTile(_avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_ADJACENCIES.NORTH, gameMap)) === null || _this$getAdjacentTile === void 0 ? void 0 : _this$getAdjacentTile._type) === this._type) adjacencies += _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_ADJACENCIES.NORTH;\n      if (((_this$getAdjacentTile2 = this.getAdjacentTile(_avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_ADJACENCIES.EAST, gameMap)) === null || _this$getAdjacentTile2 === void 0 ? void 0 : _this$getAdjacentTile2._type) === this._type) adjacencies += _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_ADJACENCIES.EAST;\n      if (((_this$getAdjacentTile3 = this.getAdjacentTile(_avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_ADJACENCIES.SOUTH, gameMap)) === null || _this$getAdjacentTile3 === void 0 ? void 0 : _this$getAdjacentTile3._type) === this._type) adjacencies += _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_ADJACENCIES.SOUTH;\n      if (((_this$getAdjacentTile4 = this.getAdjacentTile(_avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_ADJACENCIES.WEST, gameMap)) === null || _this$getAdjacentTile4 === void 0 ? void 0 : _this$getAdjacentTile4._type) === this._type) adjacencies += _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_ADJACENCIES.WEST;\n      return adjacencies;\n    }\n  }, {\n    key: \"getAdjacentTile\",\n    value: function getAdjacentTile(adjacencyDirection) {\n      var _gameMap$tiles;\n      var gameMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      if (!adjacencyDirection) return null;\n      var _gameMap = gameMap || this._app.gameMap;\n      var colOffset = 0,\n        rowOffset = 0;\n      switch (adjacencyDirection) {\n        case _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_ADJACENCIES.NORTH:\n          rowOffset--;\n          break;\n        case _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_ADJACENCIES.EAST:\n          colOffset++;\n          break;\n        case _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_ADJACENCIES.SOUTH:\n          rowOffset++;\n          break;\n        case _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_ADJACENCIES.WEST:\n          colOffset--;\n          break;\n      }\n      if (rowOffset === 0 && colOffset === 0) return null;\n      return _gameMap === null || _gameMap === void 0 || (_gameMap$tiles = _gameMap.tiles) === null || _gameMap$tiles === void 0 || (_gameMap$tiles = _gameMap$tiles[this.row + rowOffset]) === null || _gameMap$tiles === void 0 ? void 0 : _gameMap$tiles[this.col + colOffset];\n    }\n\n    /*\r\n    Section: Getters and Setters\r\n    ----------------------------------------------------------------------------\r\n     */\n  }, {\n    key: \"left\",\n    get: function get() {\n      return this.x - this.size / 2;\n    },\n    set: function set(val) {\n      this.x = val + this.size / 2;\n    }\n  }, {\n    key: \"right\",\n    get: function get() {\n      return this.x + this.size / 2;\n    },\n    set: function set(val) {\n      this.x = val - this.size / 2;\n    }\n  }, {\n    key: \"top\",\n    get: function get() {\n      return this.y - this.size / 2;\n    },\n    set: function set(val) {\n      this.y = val + this.size / 2;\n    }\n  }, {\n    key: \"bottom\",\n    get: function get() {\n      return this.y + this.size / 2;\n    },\n    set: function set(val) {\n      this.y = val - this.size / 2;\n    }\n  }, {\n    key: \"col\",\n    get: function get() {\n      return Math.floor(this.x / _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE);\n    },\n    set: function set(val) {\n      this.x = val * _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE + _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE / 2;\n    }\n  }, {\n    key: \"row\",\n    get: function get() {\n      return Math.floor(this.y / _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE);\n    },\n    set: function set(val) {\n      this.y = val * _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE + _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE / 2;\n    }\n  }, {\n    key: \"vertices\",\n    get: function get() {\n      return [{\n        x: this.left,\n        y: this.top\n      }, {\n        x: this.right,\n        y: this.top\n      }, {\n        x: this.right,\n        y: this.bottom\n      }, {\n        x: this.left,\n        y: this.bottom\n      }];\n    },\n    set: function set(val) {\n      console.error('ERROR: Tile.vertices is read only');\n    }\n  }, {\n    key: \"segments\",\n    get: function get() {\n      var vertices = this.vertices;\n      if (vertices.length < 2) return [];\n      return vertices.map(function (vertex1, i) {\n        var vertex2 = vertices[(i + 1) % vertices.length];\n        return {\n          start: {\n            x: vertex1.x,\n            y: vertex1.y\n          },\n          end: {\n            x: vertex2.x,\n            y: vertex2.y\n          }\n        };\n      });\n    },\n    set: function set(val) {\n      console.error('ERROR: Tile.segments is read only');\n    }\n  }]);\n}();\n\n\n//# sourceURL=webpack://cny2026/./src/avo/tile/tile.js?");

/***/ }),

/***/ "./src/cny2026/cny2026.js":
/*!********************************!*\
  !*** ./src/cny2026/cny2026.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ CNY2026)\n/* harmony export */ });\n/* harmony import */ var _avo_story__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/story */ \"./src/avo/story/index.js\");\n/* harmony import */ var _avo_image_asset_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @avo/image-asset.js */ \"./src/avo/image-asset.js\");\n/* harmony import */ var _entities_passenger_spawn_zone_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./entities/passenger-spawn-zone.js */ \"./src/cny2026/entities/passenger-spawn-zone.js\");\n/* harmony import */ var _rules_cny2026_game_manager_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rules/cny2026-game-manager.js */ \"./src/cny2026/rules/cny2026-game-manager.js\");\n/* harmony import */ var _rules_cny2026_start_up_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./rules/cny2026-start-up.js */ \"./src/cny2026/rules/cny2026-start-up.js\");\n/* harmony import */ var _rules_passenger_guidance_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./rules/passenger-guidance.js */ \"./src/cny2026/rules/passenger-guidance.js\");\n/* harmony import */ var _rules_player_bounds_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./rules/player-bounds.js */ \"./src/cny2026/rules/player-bounds.js\");\n/* harmony import */ var _rules_player_controls_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./rules/player-controls.js */ \"./src/cny2026/rules/player-controls.js\");\n/* harmony import */ var _rules_sound_manager_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./rules/sound-manager.js */ \"./src/cny2026/rules/sound-manager.js\");\n/* harmony import */ var _misc_highScore_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./misc/highScore.js */ \"./src/cny2026/misc/highScore.js\");\n/* harmony import */ var _misc_generateGameMapFromImage_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./misc/generateGameMapFromImage.js */ \"./src/cny2026/misc/generateGameMapFromImage.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && \"function\" == typeof p ? function (t) { return p.apply(e, t); } : p; }\nfunction _get() { return _get = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }\nfunction _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n\n\n\n\n\n\n\n\n\n\n\nvar CNY2026 = /*#__PURE__*/function (_Story) {\n  function CNY2026(app) {\n    var _this;\n    _classCallCheck(this, CNY2026);\n    _this = _callSuper(this, CNY2026, [app]);\n    _this.assets = {\n      // 'hero': new ImageAsset('assets/avo-sprites-2024-08-samiel.png'),\n      'horse': new _avo_image_asset_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]('assets/cny2026-horse.png'),\n      'passengers': new _avo_image_asset_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]('assets/cny2026-passengers.png'),\n      'cars': new _avo_image_asset_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]('assets/cny2026-cars.png'),\n      'zones': new _avo_image_asset_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]('assets/cny2026-zones.png'),\n      'misc': new _avo_image_asset_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]('assets/cny2026-misc.png'),\n      'map': new _avo_image_asset_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]('assets/cny2026-map-tiles.png'),\n      'map-layout-00': new _avo_image_asset_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]('assets/cny2026-map-00-debug.png'),\n      'map-layout-01': new _avo_image_asset_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]('assets/cny2026-map-01-city.png')\n    };\n\n    // Add event listeners\n    _this.startButton_onClick = _this.startButton_onClick.bind(_this);\n    document.getElementById('cny2026-start-button').addEventListener('click', _this.startButton_onClick);\n    //  NOTE: since the Story doesn't ever unload/deconstruct, there's no corresponding .removeEventListener()\n\n    // Open home menu when the game starts\n    app.setHomeMenu(true);\n\n    // Update the high score.\n    (0,_misc_highScore_js__WEBPACK_IMPORTED_MODULE_9__.updateHighScoreHtml)();\n    return _this;\n  }\n  _inherits(CNY2026, _Story);\n  return _createClass(CNY2026, [{\n    key: \"start\",\n    value: function start() {\n      _superPropGet(CNY2026, \"start\", this, 3)([]);\n      // this.load_debug_scene()\n      this.load_city_scene();\n    }\n  }, {\n    key: \"addStandardRules\",\n    value: function addStandardRules() {\n      var app = this._app;\n      app.addRule(new _rules_cny2026_game_manager_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](app));\n      app.addRule(new _rules_cny2026_start_up_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"](app));\n      app.addRule(new _rules_passenger_guidance_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"](app));\n      app.addRule(new _rules_player_controls_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](app));\n      app.addRule(new _rules_player_bounds_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](app));\n      app.addRule(new _rules_sound_manager_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"](app));\n    }\n  }, {\n    key: \"load_debug_scene\",\n    value: function load_debug_scene() {\n      _superPropGet(CNY2026, \"reset\", this, 3)([]);\n      var app = this._app;\n\n      // Setup rules\n      this.addStandardRules();\n\n      // Setup map\n      (0,_misc_generateGameMapFromImage_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"])(app, app.assets['map-layout-00'].img);\n      app.rules.get('cny2026-game-manager').populatePassengers();\n    }\n  }, {\n    key: \"load_city_scene\",\n    value: function load_city_scene() {\n      _superPropGet(CNY2026, \"reset\", this, 3)([]);\n      var app = this._app;\n\n      // Setup rules\n      this.addStandardRules();\n\n      // Setup map\n      (0,_misc_generateGameMapFromImage_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"])(app, app.assets['map-layout-01'].img);\n      app.rules.get('cny2026-game-manager').populatePassengers();\n\n      // Setup map: add easy starting spawn. \n      var startingZoneSpawn = app.addEntity(new _entities_passenger_spawn_zone_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](app, app.hero.col, app.hero.row + 5));\n      startingZoneSpawn.spawnPassenger();\n    }\n  }, {\n    key: \"startButton_onClick\",\n    value: function startButton_onClick() {\n      this._app.setHomeMenu(false);\n      this.start();\n    }\n  }]);\n}(_avo_story__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n\n//# sourceURL=webpack://cny2026/./src/cny2026/cny2026.js?");

/***/ }),

/***/ "./src/cny2026/entities/car-spawn-zone.js":
/*!************************************************!*\
  !*** ./src/cny2026/entities/car-spawn-zone.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ CarSpawnZone)\n/* harmony export */ });\n/* harmony import */ var _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/constants.js */ \"./src/avo/constants.js\");\n/* harmony import */ var _avo_entity_entity_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @avo/entity/entity.js */ \"./src/avo/entity/entity.js\");\n/* harmony import */ var _car_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./car.js */ \"./src/cny2026/entities/car.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n/*\r\nCar Spawn Zone\r\nA Spawn Zone will periodically spawn Cars.\r\n\r\nRules:\r\n- A Car Spawn Zone has a direction where it sends its cars towards.\r\n- A Spawn Zone doesn't actually trigger its own spawnCar() action, but\r\n  it's instead triggered by a CNY 2026 Game Manager.\r\n */\n\n\n\n\nvar CarSpawnZone = /*#__PURE__*/function (_Entity) {\n  function CarSpawnZone(app) {\n    var _this;\n    var col = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var row = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var direction = arguments.length > 3 ? arguments[3] : undefined;\n    _classCallCheck(this, CarSpawnZone);\n    _this = _callSuper(this, CarSpawnZone, [app]);\n    _this._type = 'car-spawn-zone';\n    _this.colour = '#e080e0';\n    _this.col = col;\n    _this.row = row;\n    _this.size = _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE * 2;\n    _this.solid = false;\n    _this.movable = false;\n\n    // Dynamically determine the ID and label of this CarSpawnZone.\n    _this.id = 0;\n    app.entities.filter(function (entity) {\n      return entity._type === _this._type;\n    }).forEach(function (entity) {\n      _this.id = Math.max(_this.id, entity.id + 1);\n    });\n    _this.label = 'abcdefghijklmnopqrstuvwxyz'[_this.id] || '?';\n    _this.direction = direction;\n    switch (direction) {\n      case _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.DIRECTIONS.NORTH:\n        _this.rotation = _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.ROTATIONS.NORTH;\n        break;\n      case _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.DIRECTIONS.EAST:\n        _this.rotation = _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.ROTATIONS.EAST;\n        break;\n      case _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.DIRECTIONS.SOUTH:\n        _this.rotation = _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.ROTATIONS.SOUTH;\n        break;\n      case _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.DIRECTIONS.WEST:\n        _this.rotation = _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.ROTATIONS.WEST;\n        break;\n    }\n    return _this;\n  }\n  _inherits(CarSpawnZone, _Entity);\n  return _createClass(CarSpawnZone, [{\n    key: \"paint\",\n    value: function paint() {\n      // Do nothing\n    }\n\n    /*\r\n    Section: General Logic\r\n    ----------------------------------------------------------------------------\r\n     */\n\n    // Create a Car at this CarSpawnZone.\n  }, {\n    key: \"spawnCar\",\n    value: function spawnCar() {\n      var app = this._app;\n      app.addEntity(new _car_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](app, this.col, this.row, this.direction));\n    }\n  }]);\n}(_avo_entity_entity_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n\n\n//# sourceURL=webpack://cny2026/./src/cny2026/entities/car-spawn-zone.js?");

/***/ }),

/***/ "./src/cny2026/entities/car.js":
/*!*************************************!*\
  !*** ./src/cny2026/entities/car.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Car)\n/* harmony export */ });\n/* harmony import */ var _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/constants.js */ \"./src/avo/constants.js\");\n/* harmony import */ var _avo_entity_types_creature_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @avo/entity/types/creature.js */ \"./src/avo/entity/types/creature.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && \"function\" == typeof p ? function (t) { return p.apply(e, t); } : p; }\nfunction _get() { return _get = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }\nfunction _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n/*\r\nCar\r\nA Car is an NPC and obstacle (an enemy, you might say) that goes zoom zoom\r\nacross the city.\r\n\r\nRules:\r\n- A Car attempts to go from one side of the city to another. It should at one\r\n  end of a spawn at of a North-South street or an East-West street, and proceed\r\n  to travel to the other side.\r\n- A Car is assigned one the cardinal directions.\r\n- A Car continuously accelerates in that direction until it reaches top speed.\r\n- If a Car exceeds the bounds of the map IN THE DIRECTION IT'S TRAVELLING then\r\n  it has reached its destination and disappears.\r\n- If a Car exists for too long on the map it harmlessly explodes. This is to\r\n  prevent too many cars getting accidentally caught on houses and etc.\r\n */\n\n\n\nvar MAX_LIFE_TIMER = 10 * _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.FRAMES_PER_SECOND;\nvar EXPLOSION_DURATION = 2 * _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.FRAMES_PER_SECOND;\nvar STATES = {\n  ACTIVE: 0,\n  EXPLODING: 1\n};\nvar Car = /*#__PURE__*/function (_Creature) {\n  function Car(app) {\n    var _this;\n    var col = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var row = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var direction = arguments.length > 3 ? arguments[3] : undefined;\n    _classCallCheck(this, Car);\n    _this = _callSuper(this, Car, [app]);\n    _this._type = 'car';\n    _this.colour = '#a040a0';\n    _this.col = col;\n    _this.row = row;\n    _this.intent = undefined;\n    _this.action = undefined;\n    _this.spriteSheet = app.assets['cars'].img;\n    _this.spriteSizeX = 32;\n    _this.spriteSizeY = 32;\n    _this.spriteScale = 2;\n    _this.spriteOffsetX = -16;\n    _this.spriteOffsetY = -24;\n    _this.spriteFlipEastToWest = true;\n\n    // Physics: make the car go zoom zoom.\n    _this.size = _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE * 1.5;\n    _this.mass = 20;\n    _this._moveAcceleration = 0.6;\n    _this._pushDeceleration = 0.2;\n    _this._pushMaxSpeed = 16;\n    switch (direction) {\n      case _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.DIRECTIONS.NORTH:\n        _this.rotation = _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.ROTATIONS.NORTH;\n        break;\n      case _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.DIRECTIONS.EAST:\n        _this.rotation = _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.ROTATIONS.EAST;\n        break;\n      case _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.DIRECTIONS.SOUTH:\n        _this.rotation = _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.ROTATIONS.SOUTH;\n        break;\n      case _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.DIRECTIONS.WEST:\n        _this.rotation = _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.ROTATIONS.WEST;\n        break;\n    }\n    _this.state = STATES.ACTIVE;\n    _this.lifeTimer = 0;\n    return _this;\n  }\n\n  /*\r\n  Section: General Logic\r\n  ----------------------------------------------------------------------------\r\n   */\n  _inherits(Car, _Creature);\n  return _createClass(Car, [{\n    key: \"play\",\n    value: function play() {\n      _superPropGet(Car, \"play\", this, 3)([]);\n      if (this.state === STATES.ACTIVE) {\n        this.pushX += this.moveAcceleration * Math.cos(this.rotation);\n        this.pushY += this.moveAcceleration * Math.sin(this.rotation);\n        if (this.lifeTimer >= MAX_LIFE_TIMER) {\n          this.state = STATES.EXPLODING;\n          this.solid = false;\n          this.lifeTimer = 0;\n        }\n        this.lifeTimer++;\n      } else if (this.state === STATES.EXPLODING) {\n        if (this.lifeTimer >= EXPLOSION_DURATION) {\n          this._expired = true;\n        }\n        this.lifeTimer++;\n      }\n    }\n  }, {\n    key: \"paint\",\n    value: function paint() {\n      var layer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      // Draw shadow on bottom layer\n      this.paintShadow(layer);\n\n      // Draw the sprite\n      if (layer === _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.LAYERS.MIDDLE) {\n        this.paintSprite();\n      }\n    }\n\n    /*\r\n    Section: Animation\r\n    ----------------------------------------------------------------------------\r\n      */\n  }, {\n    key: \"getSpriteCol\",\n    value: function getSpriteCol() {\n      switch (this.getSpriteDirection()) {\n        case _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.DIRECTIONS.NORTH:\n          return 2;\n        case _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.DIRECTIONS.EAST:\n          return 1;\n        case _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.DIRECTIONS.SOUTH:\n          return 0;\n        case _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.DIRECTIONS.WEST:\n          return 1;\n      }\n      return 0;\n    }\n  }, {\n    key: \"getSpriteRow\",\n    value: function getSpriteRow() {\n      if (this.state === STATES.EXPLODING) {\n        var progress = this.lifeTimer / EXPLOSION_DURATION;\n        if (progress < 0.6) {\n          return 0;\n        } else if (progress < 0.7) {\n          return 1;\n        } else if (progress < 0.8) {\n          return 2;\n        } else if (progress < 0.9) {\n          return 3;\n        } else {\n          return 4;\n        }\n      }\n      return 0;\n    }\n  }]);\n}(_avo_entity_types_creature_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n\n\n//# sourceURL=webpack://cny2026/./src/cny2026/entities/car.js?");

/***/ }),

/***/ "./src/cny2026/entities/drop-off-zone.js":
/*!***********************************************!*\
  !*** ./src/cny2026/entities/drop-off-zone.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ DropOffZone)\n/* harmony export */ });\n/* harmony import */ var _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/constants.js */ \"./src/avo/constants.js\");\n/* harmony import */ var _avo_entity_entity_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @avo/entity/entity.js */ \"./src/avo/entity/entity.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && \"function\" == typeof p ? function (t) { return p.apply(e, t); } : p; }\nfunction _get() { return _get = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }\nfunction _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n/*\r\nDrop Off Zone\r\nA Drop Off Zone is the destination of a passenger.\r\n\r\nRules:\r\n- When a Hero is carrying a matching Passenger (a matching Passenger is one\r\n  whose destination is this Drop Off Zone), that Passenger is dropped off\r\n  (detached from the Hero).\r\n- When a matching, non-carried Passenger touches the Drop Off Zone, that\r\n  Passenger is successfully added to the score.\r\n- The first rule will trigger the second rule on the next frame. However,\r\n  the second rule doesn't necessarily require the first rule - it's possible\r\n  to knock a passenger to their destination.\r\n- A Drop Off Zone has an ID, which is used to match Passengers to their\r\n  destinations.\r\n */\n\n\n\nvar ANIMATION_DURATION = 0.5 * _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.FRAMES_PER_SECOND;\nvar DropOffZone = /*#__PURE__*/function (_Entity) {\n  function DropOffZone(app) {\n    var _this;\n    var col = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var row = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    _classCallCheck(this, DropOffZone);\n    _this = _callSuper(this, DropOffZone, [app]);\n    _this._type = 'drop-off-zone';\n    _this.colour = '#e0e080';\n    _this.col = col;\n    _this.row = row;\n    _this.size = _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE * 2;\n    _this.solid = false;\n    _this.movable = false;\n\n    // Dynamically determine the ID and label of this DropOffZone.\n    _this.id = 0;\n    app.entities.filter(function (entity) {\n      return entity._type === _this._type;\n    }).forEach(function (entity) {\n      _this.id = Math.max(_this.id, entity.id + 1);\n    });\n    _this.label = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'[_this.id] || '?';\n    _this.spriteSheet = app.assets['zones'].img;\n    _this.spriteSizeX = 32;\n    _this.spriteSizeY = 32;\n    _this.spriteScale = 2;\n    _this.spriteOffsetX = -16;\n    _this.spriteOffsetY = -16;\n    _this.animationCounter = 0;\n    return _this;\n  }\n\n  /*\r\n  Section: General Logic\r\n  ----------------------------------------------------------------------------\r\n   */\n  _inherits(DropOffZone, _Entity);\n  return _createClass(DropOffZone, [{\n    key: \"play\",\n    value: function play() {\n      this.animationCounter = (this.animationCounter + 1) % ANIMATION_DURATION;\n    }\n  }, {\n    key: \"paint\",\n    value: function paint() {\n      var layer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      if (layer === _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.LAYERS.BOTTOM) {\n        this.paintSprite();\n      }\n\n      /*\r\n      const app = this._app\r\n      const c2d = app.canvas2d\r\n        // Debug\r\n      if (layer === LAYERS.BOTTOM) {\r\n        app.applyCameraTransforms()\r\n          // Paint zone\r\n        c2d.fillStyle = this.colour\r\n        c2d.beginPath()\r\n        c2d.arc(this.x, this.y, this.size / 2, 0, 2 * Math.PI)\r\n        c2d.fill()\r\n          // Paint label\r\n        c2d.font = `32px monospace`\r\n        c2d.fillStyle = '#ffffff'\r\n        c2d.textBaseline = 'middle'\r\n        c2d.textAlign = 'center'\r\n        c2d.fillText(this.label, this.x, this.y)\r\n          app.undoCameraTransforms()\r\n      }\r\n      */\n    }\n  }, {\n    key: \"onCollision\",\n    value: function onCollision(target, collisionCorrection) {\n      _superPropGet(DropOffZone, \"onCollision\", this, 3)([target, collisionCorrection]);\n      var app = this._app;\n      var hero = this._app.hero;\n      if (target === hero && hero !== null && hero !== void 0 && hero.passenger && (hero === null || hero === void 0 ? void 0 : hero.passenger.destination) === this.id) {\n        hero.passenger.x = this.x;\n        hero.passenger.y = this.y;\n        hero.dropOff();\n      } else if (target._type === 'passenger' && !target.pickedUp && !target.destinationReached && target.destination === this.id) {\n        target.x = this.x;\n        target.y = this.y;\n        target.onDestinationReached();\n        app.rules.get('cny2026-game-manager').increaseScore();\n      }\n    }\n\n    /*\r\n    Section: Animation\r\n    ----------------------------------------------------------------------------\r\n      */\n  }, {\n    key: \"getSpriteCol\",\n    value: function getSpriteCol() {\n      return this.id + 1;\n    }\n  }, {\n    key: \"getSpriteRow\",\n    value: function getSpriteRow() {\n      var _hero$passenger;\n      var hero = this._app.hero;\n      if ((hero === null || hero === void 0 || (_hero$passenger = hero.passenger) === null || _hero$passenger === void 0 ? void 0 : _hero$passenger.destination) === this.id) {\n        var progress = this.animationCounter / ANIMATION_DURATION;\n        if (progress <= 0.3333) {\n          return 1;\n        } else if (progress <= 0.6667) {\n          return 2;\n        } else {\n          return 3;\n        }\n      }\n      return 0;\n    }\n  }]);\n}(_avo_entity_entity_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n\n\n//# sourceURL=webpack://cny2026/./src/cny2026/entities/drop-off-zone.js?");

/***/ }),

/***/ "./src/cny2026/entities/hero.js":
/*!**************************************!*\
  !*** ./src/cny2026/entities/hero.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Hero)\n/* harmony export */ });\n/* harmony import */ var _avo_entity_types_creature_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/entity/types/creature.js */ \"./src/avo/entity/types/creature.js\");\n/* harmony import */ var _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @avo/constants.js */ \"./src/avo/constants.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && \"function\" == typeof p ? function (t) { return p.apply(e, t); } : p; }\nfunction _get() { return _get = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }\nfunction _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n/*\r\nHero\r\nThe Hero is a horse that goes around picking up Passengers and dropping them off\r\nat their destination Drop Off Zones.\r\n */\n\n\n\nvar INVULNERABILITY_WINDOW = 3000;\nvar MOVE_ACTION_CYCLE_DURATION = 500;\nvar MAX_CHARGING_POWER = 1000;\nvar Hero = /*#__PURE__*/function (_Creature) {\n  function Hero(app) {\n    var _this;\n    var col = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var row = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    _classCallCheck(this, Hero);\n    _this = _callSuper(this, Hero, [app]);\n    _this._type = 'hero';\n    _this.colour = '#c04040';\n    _this.col = col;\n    _this.row = row;\n    _this.intent = undefined;\n    _this.action = undefined;\n    _this.spriteSheet = app.assets['horse'].img;\n    _this.spriteSizeX = 32;\n    _this.spriteSizeY = 32;\n    _this.spriteScale = 3;\n    _this.spriteOffsetX = -16;\n    _this.spriteOffsetY = -20;\n    _this.spriteFlipEastToWest = true;\n\n    // Physics: make the horse really fast and a bit hard to control.\n    _this.mass = 10;\n    _this._moveAcceleration = 0.6;\n    _this._moveDeceleration = 0.8;\n    _this._moveMaxSpeed = 12;\n    _this._pushDeceleration = 0.2;\n    _this._pushMaxSpeed = 16;\n\n    // Gameplay\n    _this.passenger = undefined;\n    return _this;\n  }\n\n  /*\r\n  Section: General Logic\r\n  ----------------------------------------------------------------------------\r\n   */\n  _inherits(Hero, _Creature);\n  return _createClass(Hero, [{\n    key: \"play\",\n    value: function play() {\n      _superPropGet(Hero, \"play\", this, 3)([]);\n      this.processIntent();\n      this.processAction();\n      this.doMaxSpeedLimit();\n\n      // Count down invulnerability time\n      if (this.invulnerability > 0) {\n        this.invulnerability = Math.max(this.invulnerability - _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.FRAME_DURATION, 0);\n      }\n\n      // If carrying a Passenger, the Passenger will be attached to the Hero.\n      var passenger = this.passenger;\n      if (passenger) {\n        passenger.x = this.x;\n        passenger.y = this.y + 1; // Render it one pixel south of the Hero so the sprites are rendered AFTER (i.e. on top of) the Hero.\n      }\n    }\n  }, {\n    key: \"paint\",\n    value: function paint() {\n      var layer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      // Draw shadow on bottom layer\n      this.paintShadow(layer);\n\n      // Draw the sprite\n      if (layer === _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.LAYERS.MIDDLE) {\n        this.paintSprite();\n      }\n    }\n\n    /*\r\n    Section: Game Logic\r\n    ----------------------------------------------------------------------------\r\n     */\n  }, {\n    key: \"applyEffect\",\n    value: function applyEffect(effect, source) {\n      _superPropGet(Hero, \"applyEffect\", this, 3)([effect, source]);\n      if (!effect) return;\n      if (effect.name === 'damage') {\n        if (this.invulnerability === 0) {\n          this.health = Math.max(this.health - 1, 0);\n          this.invulnerability = INVULNERABILITY_WINDOW;\n        }\n      }\n    }\n\n    /*\r\n    Section: Intent and Actions\r\n    ----------------------------------------------------------------------------\r\n     */\n\n    /*\r\n    Translate intent into action.\r\n     */\n  }, {\n    key: \"processIntent\",\n    value: function processIntent() {\n      // Failsafe\n      if (!this.action) this.goIdle();\n      var action = this.action;\n      var intent = this.intent;\n      if (!intent) {\n        // Go idle\n        if ((action === null || action === void 0 ? void 0 : action.name) === 'move') this.goIdle();\n      } else {\n        // Perform a new action\n        // Note: every 'move' action is considered a new action\n\n        // \"Skill\" Action:\n        // If the Entity intends to execute its \"skill\", it can only do so after\n        // it's completed (or in the middle of) \"charging up\".\n        if ((intent === null || intent === void 0 ? void 0 : intent.name) === 'skill') {\n          if ((action === null || action === void 0 ? void 0 : action.name) === 'charging') {\n            this.action = _objectSpread(_objectSpread({}, intent), {}, {\n              name: intent.name,\n              counter: 0,\n              state: undefined,\n              power: action.counter\n            });\n          }\n          return;\n        }\n\n        // All other Actions:\n        // If the Entity intends to execute a new action, it can only do so if the\n        // current action can be cancelled. (i.e. it's either \"idle\" or \"moving\".)\n        if ((action === null || action === void 0 ? void 0 : action.name) === 'idle' || (action === null || action === void 0 ? void 0 : action.name) === 'move') {\n          this.action = _objectSpread(_objectSpread({}, intent), {}, {\n            name: intent.name,\n            counter: action.name === intent.name ? action.counter : 0 // If the current action and new intent have the same name, it's just a continuation of the idle or move action, but with other new values (e.g. new directions)\n          });\n          return;\n        }\n      }\n    }\n\n    /*\r\n    Perform the action.\r\n     */\n  }, {\n    key: \"processAction\",\n    value: function processAction() {\n      if (!this.action) return;\n      var action = this.action;\n      if (action.name === 'idle') {\n\n        // Do nothing\n      } else if (action.name === 'move') {\n        var directionX = action.directionX || 0;\n        var directionY = action.directionY || 0;\n        if (!directionX && !directionY) return;\n        var moveAcceleration = this.moveAcceleration || 0;\n        var actionRotation = Math.atan2(directionY, directionX);\n        this.moveX += moveAcceleration * Math.cos(actionRotation);\n        this.moveY += moveAcceleration * Math.sin(actionRotation);\n        this.rotation = actionRotation;\n        action.counter = (action.counter + _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.FRAME_DURATION) % MOVE_ACTION_CYCLE_DURATION;\n      } else if (action.name === 'charging') {\n        action.counter = Math.min(action.counter + _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.FRAME_DURATION, MAX_CHARGING_POWER);\n      } else if (action.name === 'skill') {\n        var WINDUP_DURATION = _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.FRAME_DURATION * 5;\n        var EXECUTION_DURATION = _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.FRAME_DURATION * 2;\n        var WINDDOWN_DURATION = _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.FRAME_DURATION * 10;\n        if (!action.state) {\n          // Trigger only once, at the start of the action\n\n          // Figure out the initial direction of the dash\n          var _directionX = action.directionX || 0;\n          var _directionY = action.directionY || 0;\n          this.rotation = _directionX === 0 && _directionY === 0 ? this.rotation : Math.atan2(_directionY, _directionX);\n          action.rotation = this.rotation; // Records the initial direction of the dash\n\n          action.state = 'windup';\n        }\n        if (action.state === 'windup') {\n          action.counter += _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.FRAME_DURATION;\n          if (action.counter >= WINDUP_DURATION) {\n            action.state = 'execution';\n            action.counter = 0;\n          }\n        } else if (action.state === 'execution') {\n          var pushPower = this.size * 0.5 * ((action.power || 0) / MAX_CHARGING_POWER);\n          this.pushX += pushPower * Math.cos(action.rotation);\n          this.pushY += pushPower * Math.sin(action.rotation);\n          this.z += 4;\n          action.counter += _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.FRAME_DURATION;\n          if (action.counter >= EXECUTION_DURATION) {\n            action.state = 'winddown';\n            action.counter = 0;\n          }\n        } else if (action.state === 'winddown') {\n          action.counter += _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.FRAME_DURATION;\n          if (action.counter >= WINDDOWN_DURATION) {\n            this.goIdle();\n          }\n        }\n      } else {\n        console.error(\"[\".concat(this._type, \"] Unknown action: \").concat(action === null || action === void 0 ? void 0 : action.name));\n        this.goIdle();\n      }\n    }\n  }, {\n    key: \"goIdle\",\n    value: function goIdle() {\n      this.action = {\n        name: 'idle',\n        counter: 0\n      };\n    }\n\n    // Picks up a Passenger.\n    // Triggered by nearby Passengers, not by the Hero.\n  }, {\n    key: \"pickUp\",\n    value: function pickUp(passenger) {\n      var _this$passenger;\n      this.passenger = passenger;\n      (_this$passenger = this.passenger) === null || _this$passenger === void 0 || _this$passenger.onPickUp();\n    }\n\n    // Drops off a Passenger.\n    // Triggered by DropOffZones, not by the Hero.\n  }, {\n    key: \"dropOff\",\n    value: function dropOff() {\n      var _this$passenger2;\n      (_this$passenger2 = this.passenger) === null || _this$passenger2 === void 0 || _this$passenger2.onDropOff();\n      this.passenger = undefined;\n    }\n\n    /*\r\n    Section: Event Handling\r\n    ----------------------------------------------------------------------------\r\n     */\n\n    /*\r\n    Triggers when this entity hits/touches/intersects with another.\r\n     */\n  }, {\n    key: \"onCollision\",\n    value: function onCollision(target, collisionCorrection) {\n      _superPropGet(Hero, \"onCollision\", this, 3)([target, collisionCorrection]);\n      if (!target) return;\n    }\n\n    /*\r\n    Section: Physics/Getters and Setters\r\n    ----------------------------------------------------------------------------\r\n     */\n  }, {\n    key: \"moveDeceleration\",\n    get: function get() {\n      var _this$action;\n      if (((_this$action = this.action) === null || _this$action === void 0 ? void 0 : _this$action.name) === 'move') return 0;\n      return this._moveDeceleration;\n    }\n  }, {\n    key: \"pushDeceleration\",\n    get: function get() {\n      if (this.z > 0) return this._pushDeceleration / 2; // When jumping off the ground, it's harder to slow down \n      return this._pushDeceleration;\n    }\n  }, {\n    key: \"doBounce\",\n    value: function doBounce(target, collisionCorrection) {\n      _superPropGet(Hero, \"doBounce\", this, 3)([target, collisionCorrection]);\n\n      // If this object isn't a movable solid, it can't bounce.\n      if (!(this.movable && this.solid)) return;\n      if (\n      // this object is bouncing off an unmovable object\n      this.movable && this.solid && !target.movable && target.solid) {\n        if (this.shape === _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.SHAPES.CIRCLE && target.shape === _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.SHAPES.CIRCLE) {\n          // For circle + circle collisions, the collision correction already\n          // tells us the bounce direction.\n          var angle = Math.atan2(collisionCorrection.y - this.y, collisionCorrection.x - this.x);\n          var speed = Math.sqrt(this.moveX * this.moveX + this.moveY * this.moveY);\n          this.moveX = Math.cos(angle) * speed;\n          this.moveY = Math.sin(angle) * speed;\n        } else if (this.shape === _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.SHAPES.CIRCLE && (target.shape === _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.SHAPES.SQUARE || target.shape === _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.SHAPES.POLYGON)) {\n          // For circle + polygon collisions, we need to know...\n          // - the original angle this circle was moving towards (or rather, its\n          //   reverse, because we want a bounce)\n          // - the normal vector (of the edge) of the polygon this circle collided\n          //   into (which we can get from the collision correction)\n          // - the angle between them\n          var reverseOriginalAngle = Math.atan2(-this.moveY, -this.moveX);\n          var normalAngle = Math.atan2(collisionCorrection.y - this.y, collisionCorrection.x - this.x);\n          var angleBetween = normalAngle - reverseOriginalAngle;\n          var _angle = reverseOriginalAngle + 2 * angleBetween;\n          var _speed = Math.sqrt(this.moveX * this.moveX + this.moveY * this.moveY);\n          this.moveX = Math.cos(_angle) * _speed;\n          this.moveY = Math.sin(_angle) * _speed;\n        } else {\n          // For the moment, we're not too concerned about polygons bumping into each other\n        }\n      } else if (\n      // this object is bouncing off another movable object\n      target.movable && target.solid && collisionCorrection.moveX !== undefined && collisionCorrection.moveY !== undefined) {\n        this.moveX = collisionCorrection.moveX;\n        this.moveY = collisionCorrection.moveY;\n      }\n    }\n\n    /*\r\n    Section: Animation\r\n    ----------------------------------------------------------------------------\r\n     */\n  }, {\n    key: \"getSpriteCol\",\n    value: function getSpriteCol() {\n      switch (this.getSpriteDirection()) {\n        case _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.DIRECTIONS.NORTH:\n          return 2;\n        case _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.DIRECTIONS.EAST:\n          return 1;\n        case _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.DIRECTIONS.SOUTH:\n          return 0;\n        case _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.DIRECTIONS.WEST:\n          return 1;\n      }\n      return 0;\n    }\n  }, {\n    key: \"getSpriteRow\",\n    value: function getSpriteRow() {\n      var action = this.action;\n      if (!action) return 0;\n      if (action.name === 'move') {\n        var progress = action.counter / MOVE_ACTION_CYCLE_DURATION;\n        if (progress < 0.5) return 1;else if (progress < 1) return 2;\n      }\n      return 0;\n    }\n  }]);\n}(_avo_entity_types_creature_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\nfunction transformPixelsFromRedToBlue(_r, _g, _b, _a) {\n  var r = _r,\n    g = _g,\n    b = _b,\n    a = _a;\n  if (_r === 192 && _g === 64 && _b === 64) {\n    r = 64;\n    g = 128;\n    b = 192;\n  } else if (_r === 80 && _g === 64 && _b === 64) {\n    r = 32;\n    g = 32;\n    b = 96;\n  }\n  return {\n    r: r,\n    g: g,\n    b: b,\n    a: a\n  };\n}\n\n//# sourceURL=webpack://cny2026/./src/cny2026/entities/hero.js?");

/***/ }),

/***/ "./src/cny2026/entities/passenger-spawn-zone.js":
/*!******************************************************!*\
  !*** ./src/cny2026/entities/passenger-spawn-zone.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ PassengerSpawnZone)\n/* harmony export */ });\n/* harmony import */ var _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/constants.js */ \"./src/avo/constants.js\");\n/* harmony import */ var _avo_entity_entity_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @avo/entity/entity.js */ \"./src/avo/entity/entity.js\");\n/* harmony import */ var _passenger_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./passenger.js */ \"./src/cny2026/entities/passenger.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n/*\r\nSpawn Zone\r\nA Spawn Zone will periodically spawn Passengers.\r\n\r\nRules:\r\n- A Spawn Zone doesn't actually trigger its own spawnPassenger() action, but\r\n  it's instead triggered by a CNY 2026 Game Manager.\r\n */\n\n\n\n\nvar NEARBY_DISTANCE = _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE * 2;\nvar PassengerSpawnZone = /*#__PURE__*/function (_Entity) {\n  function PassengerSpawnZone(app) {\n    var _this;\n    var col = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var row = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    _classCallCheck(this, PassengerSpawnZone);\n    _this = _callSuper(this, PassengerSpawnZone, [app]);\n    _this._type = 'passenger-spawn-zone';\n    _this.colour = '#80e0e0';\n    _this.col = col;\n    _this.row = row;\n    _this.size = _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE * 2;\n    _this.solid = false;\n    _this.movable = false;\n\n    // Dynamically determine the ID and label of this PassengerSpawnZone.\n    _this.id = 0;\n    app.entities.filter(function (entity) {\n      return entity._type === _this._type;\n    }).forEach(function (entity) {\n      _this.id = Math.max(_this.id, entity.id + 1);\n    });\n    _this.label = 'abcdefghijklmnopqrstuvwxyz'[_this.id] || '?';\n    _this.spriteSheet = app.assets['zones'].img;\n    _this.spriteSizeX = 32;\n    _this.spriteSizeY = 32;\n    _this.spriteScale = 2;\n    _this.spriteOffsetX = -16;\n    _this.spriteOffsetY = -16;\n    // this.animationCounter = 0\n    return _this;\n  }\n\n  /*\r\n  Section: General Logic\r\n  ----------------------------------------------------------------------------\r\n   */\n  _inherits(PassengerSpawnZone, _Entity);\n  return _createClass(PassengerSpawnZone, [{\n    key: \"paint\",\n    value: function paint() {\n      var layer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      if (layer === _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.LAYERS.BOTTOM) {\n        this.paintSprite();\n      }\n\n      /*\r\n      // Debug\r\n      if (layer === LAYERS.BOTTOM) {\r\n        app.applyCameraTransforms()\r\n          // Paint zone\r\n        c2d.fillStyle = this.colour\r\n        c2d.beginPath()\r\n        c2d.arc(this.x, this.y, this.size / 2, 0, 2 * Math.PI)\r\n        c2d.fill()\r\n          // Paint label\r\n        c2d.font = `32px monospace`\r\n        c2d.fillStyle = '#ffffff'\r\n        c2d.textBaseline = 'middle'\r\n        c2d.textAlign = 'center'\r\n        c2d.fillText(this.label, this.x, this.y)\r\n          app.undoCameraTransforms()\r\n      }\r\n        */\n    }\n\n    // Create a Passenger at this PassengerSpawnZone.\n  }, {\n    key: \"spawnPassenger\",\n    value: function spawnPassenger() {\n      var app = this._app;\n      app.addEntity(new _passenger_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](app, this.col, this.row));\n    }\n\n    // Check for Passengers near this PassengerSpawnZone.\n  }, {\n    key: \"getNearbyPassengers\",\n    value: function getNearbyPassengers() {\n      var _this2 = this;\n      var app = this._app;\n      return app.entities.filter(function (entity) {\n        if (entity._type !== 'passenger') return false;\n        var distX = entity.x - _this2.x;\n        var distY = entity.y - _this2.y;\n        var distSq = distX * distX + distY * distY;\n        return distSq <= NEARBY_DISTANCE * NEARBY_DISTANCE;\n      });\n    }\n\n    /*\r\n    Section: Animation\r\n    ----------------------------------------------------------------------------\r\n      */\n  }, {\n    key: \"getSpriteCol\",\n    value: function getSpriteCol() {\n      return 0;\n    }\n  }, {\n    key: \"getSpriteRow\",\n    value: function getSpriteRow() {\n      return 0;\n    }\n  }]);\n}(_avo_entity_entity_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n\n\n//# sourceURL=webpack://cny2026/./src/cny2026/entities/passenger-spawn-zone.js?");

/***/ }),

/***/ "./src/cny2026/entities/passenger.js":
/*!*******************************************!*\
  !*** ./src/cny2026/entities/passenger.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Passenger)\n/* harmony export */ });\n/* harmony import */ var _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/constants.js */ \"./src/avo/constants.js\");\n/* harmony import */ var _avo_entity_types_creature_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @avo/entity/types/creature.js */ \"./src/avo/entity/types/creature.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && \"function\" == typeof p ? function (t) { return p.apply(e, t); } : p; }\nfunction _get() { return _get = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }\nfunction _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n/*\r\nPassenger\r\nA Passenger is an NPC that can be picked up by the Hero, to be delivered to a\r\ndesignated Drop Off Zone.\r\n\r\nRules:\r\n- When the Hero doesn't already have an attached Passenger, and the Hero comes\r\n  within a certain radius of a Passenger, that Passenger gets attached to the\r\n  Hero.\r\n- A Passenger has a destination Drop Off Zone.\r\n- A Passenger that has reached their destination is marked as \"successfully\r\n  dropped off\", and will disappear after a short while.\r\n- If a Passenger somehow moves outside of the game map, it disappears.\r\n */\n\n\n\nvar PICKUP_RADIUS = _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE * 2;\nvar PICKUP_COOLDOWN_DURATION = 60;\nvar EXPIRY_DURATION = 60;\nvar NUMBER_OF_SPRITE_VARIATIONS = 4;\nvar Passenger = /*#__PURE__*/function (_Creature) {\n  function Passenger(app) {\n    var _this;\n    var col = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var row = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    _classCallCheck(this, Passenger);\n    _this = _callSuper(this, Passenger, [app]);\n    _this._type = 'passenger';\n    _this.colour = '#c0c040';\n    _this.col = col;\n    _this.row = row;\n    _this.intent = undefined;\n    _this.action = undefined;\n    _this.spriteSheet = app.assets['passengers'].img;\n    _this.spriteSizeX = 24;\n    _this.spriteSizeY = 24;\n    _this.spriteScale = 2;\n    _this.spriteOffsetX = -12;\n    _this.spriteOffsetY = -18;\n    _this.spriteFlipEastToWest = true;\n    _this.pickedUp = false; // Indicates if a passenger is picked up by the hero.\n    _this.pickUpCooldown = 0; // Once a passenger is dropped, it can't be picked up for a while.\n    _this.destinationReached = false; // Once the destination has been reached, \n    _this.expiryCountdown = 0;\n\n    // Dynamically determine the destination DropOffZone of this passenger.\n    _this.destination = 0;\n    _this.label = '';\n    var dropOffZones = app.entities.filter(function (entity) {\n      return entity._type === 'drop-off-zone';\n    });\n    if (dropOffZones.length >= 1) {\n      var randomIndex = Math.floor(Math.random() * dropOffZones.length);\n      _this.destination = dropOffZones[randomIndex].id;\n      _this.label = dropOffZones[randomIndex].label;\n    }\n    return _this;\n  }\n\n  /*\r\n  Section: General Logic\r\n  ----------------------------------------------------------------------------\r\n   */\n  _inherits(Passenger, _Creature);\n  return _createClass(Passenger, [{\n    key: \"play\",\n    value: function play() {\n      _superPropGet(Passenger, \"play\", this, 3)([]);\n      var app = this._app;\n      var hero = app.hero;\n\n      // If Passenger has reached their destination, they're free to disappear.\n      if (this.destinationReached) {\n        this.expiryCountdown--;\n        if (this.expiryCountdown <= 0) {\n          this._expired = true;\n        }\n        return;\n      }\n\n      // Pick up this Passenger if Hero is nearby and available.\n      if (this.pickUpCooldown > 0) {\n        this.pickUpCooldown--;\n      } else if (hero && !hero.passenger && !this.pickedUp) {\n        var distX = hero.x - this.x;\n        var distY = hero.y - this.y;\n        var dist = Math.sqrt(distY * distY + distX * distX);\n        if (dist <= PICKUP_RADIUS) {\n          hero.pickUp(this);\n        }\n      }\n\n      // If Passenger is outside of the game map area, it goes poof!\n      this.checkGameMapBounds();\n    }\n  }, {\n    key: \"paint\",\n    value: function paint() {\n      var layer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      // Draw shadow on bottom layer\n      if (!this.pickedUp) {\n        this.paintShadow(layer);\n      }\n\n      // Draw the sprite\n      if (layer === _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.LAYERS.MIDDLE) {\n        var spriteOffsetY = this.spriteOffsetY;\n        if (this.pickedUp) {\n          var hero = this._app.hero;\n          switch (hero === null || hero === void 0 ? void 0 : hero.getSpriteDirection()) {\n            case _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.DIRECTIONS.NORTH:\n              spriteOffsetY -= 4;\n              break;\n            case _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.DIRECTIONS.SOUTH:\n              spriteOffsetY -= 12;\n              break;\n            default:\n              spriteOffsetY -= 8;\n          }\n        }\n        this.paintSprite({\n          spriteOffsetY: spriteOffsetY\n        });\n      }\n\n      /*\r\n      // Debug\r\n      if (\r\n        (!this.pickedUp && layer === LAYERS.MIDDLE)\r\n        || (this.pickedUp && layer === LAYERS.TOP)\r\n      ) {\r\n        app.applyCameraTransforms()\r\n          // Paint shape\r\n        c2d.fillStyle = this.colour\r\n        c2d.strokeStyle = '#404040'\r\n        c2d.lineWidth = 2\r\n        c2d.beginPath()\r\n        c2d.arc(this.x, this.y, this.size / 2, 0, 2 * Math.PI)\r\n        c2d.fill()\r\n        this.solid && c2d.stroke()\r\n          // Paint label\r\n        c2d.font = `24px monospace`\r\n        c2d.fillStyle = '#ffffff'\r\n        c2d.textBaseline = 'middle'\r\n        c2d.textAlign = 'center'\r\n        c2d.fillText(this.label, this.x, this.y)\r\n          app.undoCameraTransforms()\r\n      }\r\n      */\n    }\n  }, {\n    key: \"onPickUp\",\n    value: function onPickUp() {\n      if (this.destinationReached) return;\n      this.solid = false;\n      this.pickedUp = true;\n      this.size = _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE - 4;\n      this._app.rules.get('sound-manager').playPickUp();\n    }\n  }, {\n    key: \"onDropOff\",\n    value: function onDropOff() {\n      if (this.destinationReached) return;\n      // this.solid = false  // Keep Passenger un-solid to prevent additional collisions.\n      this.pickedUp = false;\n      this.size = _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE;\n      this.pickUpCooldown = PICKUP_COOLDOWN_DURATION;\n      this._app.rules.get('sound-manager').playDropOff();\n    }\n  }, {\n    key: \"onDestinationReached\",\n    value: function onDestinationReached() {\n      if (this.destinationReached) return;\n      this.solid = false;\n      this.destinationReached = true;\n      this.expiryCountdown = EXPIRY_DURATION;\n      this._app.rules.get('sound-manager').playDestinationReached();\n    }\n\n    /*\r\n    If Passenger is outside of the game map area, it goes poof!\r\n     */\n  }, {\n    key: \"checkGameMapBounds\",\n    value: function checkGameMapBounds() {\n      var gameMap = this._app.gameMap;\n      if (this.pickedUp || this.destinationReached) return;\n      if (!gameMap || !gameMap.width || !gameMap.height) return;\n      var MIN_X = 0;\n      var MIN_Y = 0;\n      var MAX_X = gameMap.width * _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE - 1;\n      var MAX_Y = gameMap.height * _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_SIZE - 1;\n      if (this.x < MIN_X || this.x > MAX_X || this.y < MIN_Y || this.y > MAX_Y) {\n        this._expired = true;\n      }\n    }\n  }, {\n    key: \"getSpriteCol\",\n    value: function getSpriteCol() {\n      return Math.floor(this.destination % NUMBER_OF_SPRITE_VARIATIONS);\n    }\n  }, {\n    key: \"getSpriteRow\",\n    value: function getSpriteRow() {\n      if (this.pickedUp) return 1;\n      if (this.destinationReached) return 2;\n      return 0;\n    }\n  }]);\n}(_avo_entity_types_creature_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n\n\n//# sourceURL=webpack://cny2026/./src/cny2026/entities/passenger.js?");

/***/ }),

/***/ "./src/cny2026/index.js":
/*!******************************!*\
  !*** ./src/cny2026/index.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _cny2026_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cny2026.js */ \"./src/cny2026/cny2026.js\");\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_cny2026_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n//# sourceURL=webpack://cny2026/./src/cny2026/index.js?");

/***/ }),

/***/ "./src/cny2026/misc/generateGameMapFromImage.js":
/*!******************************************************!*\
  !*** ./src/cny2026/misc/generateGameMapFromImage.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ generateGameMapFromImage)\n/* harmony export */ });\n/* harmony import */ var _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/constants.js */ \"./src/avo/constants.js\");\n/* harmony import */ var _prettifyMapTiles_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./prettifyMapTiles.js */ \"./src/cny2026/misc/prettifyMapTiles.js\");\n/* harmony import */ var _entities_hero_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../entities/hero.js */ \"./src/cny2026/entities/hero.js\");\n/* harmony import */ var _entities_drop_off_zone_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../entities/drop-off-zone.js */ \"./src/cny2026/entities/drop-off-zone.js\");\n/* harmony import */ var _entities_passenger_spawn_zone_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../entities/passenger-spawn-zone.js */ \"./src/cny2026/entities/passenger-spawn-zone.js\");\n/* harmony import */ var _entities_car_spawn_zone_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../entities/car-spawn-zone.js */ \"./src/cny2026/entities/car-spawn-zone.js\");\n/* harmony import */ var _tiles_floor_tile__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../tiles/floor-tile */ \"./src/cny2026/tiles/floor-tile.js\");\n/* harmony import */ var _tiles_wall_tile_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../tiles/wall-tile.js */ \"./src/cny2026/tiles/wall-tile.js\");\n/* harmony import */ var _tiles_street_tile_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../tiles/street-tile.js */ \"./src/cny2026/tiles/street-tile.js\");\n/*\r\nConvert Image to Game Map\r\nReads an image an transforms it into a compatible game map. This is our\r\nalternative to making a dedicated map editor.\r\n\r\n- Input:\r\n  - AvO app\r\n  - image: e.g. from imageAsset.img \r\n- Output:\r\n  - Returns true if successful, false on failure.\r\n  - Modifies AvO app's map-related values.\r\n\r\n- Each pixel in the image corresponds to a tile space in the map.\r\n- The colour of the pixel determines the specific Tile (Floor/Wall) OR Entity at\r\n  that tile space.\r\n- The image's height and width determines the width and height of the map.\r\n- The conversion/transformation from pixel to Tile/Entity is hardcoded for now.\r\n */\n\n\n\n\n\n\n\n\n\n\nfunction generateGameMapFromImage(app, image) {\n  if (!app || !image) {\n    console.error('generateGameMapFromImage(): missing inputs');\n    return false;\n  }\n  try {\n    var gameMap = {\n      // Game map and environment\n      tiles: [],\n      // 2D array of map tiles\n      width: 0,\n      height: 0\n    };\n\n    // Create an OffscreenCanvas and paint the image on it.\n    var width = image.width;\n    var height = image.height;\n    var offscreenCanvas = new OffscreenCanvas(width, height);\n    var c2dOff = offscreenCanvas.getContext('2d');\n    c2dOff.drawImage(image, 0, 0, width, height, 0, 0, width, height);\n\n    // Extract the data from the painted image.\n    var offImage = c2dOff.getImageData(0, 0, width, height);\n    var offData = offImage === null || offImage === void 0 ? void 0 : offImage.data;\n    var dataLength = (offData === null || offData === void 0 ? void 0 : offData.length) || 0;\n\n    // Go through every pixel in the data, and run it through the transformer.\n    for (var i = 0; i < dataLength; i += 4) {\n      // Get pixel colour.\n      var r = offData[i + 0];\n      var g = offData[i + 1];\n      var b = offData[i + 2];\n      var a = offData[i + 3];\n\n      // Get map tile coordinates\n      var index = i / 4;\n      var col = index % width; // Column, not colour. Uh, hope that's not too confusing.\n      var row = Math.floor(index / width);\n      if (!gameMap.tiles[row]) {\n        gameMap.tiles.push([]);\n      }\n\n      // Translate pixel colour to map tile. \n      var tile = void 0;\n      if (r === 0 && g === 0 && b === 0) {\n        tile = new _tiles_wall_tile_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](app, col, row);\n      } else if (r === 230 && g === 230 && b === 230 || r === 255 && g === 0 && b === 255) {\n        tile = new _tiles_street_tile_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"](app, col, row);\n      } else {\n        tile = new _tiles_floor_tile__WEBPACK_IMPORTED_MODULE_6__[\"default\"](app, col, row);\n      }\n      gameMap.tiles[row].push(tile);\n\n      // Are there any Entities on this map tile?\n      // Note: entities are always placed on a FloorTile.\n      if (r === 255 && g === 0 && b === 0) {\n        // Entity: Hero\n        app.hero = app.addEntity(new _entities_hero_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](app, col, row));\n        app.hero.rotation = _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.ROTATIONS.EAST;\n        app.camera.target = app.hero;\n      } else if (r === 0 && g === 255 && b === 0) {\n        // Entity: Passenger Spawn Zone\n        app.addEntity(new _entities_passenger_spawn_zone_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"](app, col, row));\n      } else if (r === 0 && g === 0 && b === 255) {\n        // Entity: Drop Off Zone\n        app.addEntity(new _entities_drop_off_zone_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](app, col, row));\n      } else if (r === 255 && g === 0 && b === 255) {\n        // Entity: Car Spawn Zone\n        var direction = _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.DIRECTIONS.EAST;\n        if (col === 0) {\n          direction = _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.DIRECTIONS.EAST;\n        } else if (row === 0) {\n          direction = _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.DIRECTIONS.SOUTH;\n        } else if (col === width - 1) {\n          direction = _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.DIRECTIONS.WEST;\n        } else if (row === height - 1) {\n          direction = _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.DIRECTIONS.NORTH;\n        }\n        app.addEntity(new _entities_car_spawn_zone_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"](app, col, row, direction));\n      }\n    }\n\n    // Update the game map data.\n    gameMap.width = width;\n    gameMap.height = height;\n    (0,_prettifyMapTiles_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(gameMap);\n    app.gameMap = gameMap;\n  } catch (err) {\n    console.error('generateGameMapFromImage(): ', err);\n    return false;\n  }\n  return true;\n}\n\n//# sourceURL=webpack://cny2026/./src/cny2026/misc/generateGameMapFromImage.js?");

/***/ }),

/***/ "./src/cny2026/misc/highScore.js":
/*!***************************************!*\
  !*** ./src/cny2026/misc/highScore.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   loadHighScore: () => (/* binding */ loadHighScore),\n/* harmony export */   saveHighScore: () => (/* binding */ saveHighScore),\n/* harmony export */   updateHighScoreHtml: () => (/* binding */ updateHighScoreHtml)\n/* harmony export */ });\n/*\r\nHigh Score System\r\nFunctions for saving & loading the player's high score from local storage.\r\n\r\n- saveHighScore(score) saves an integer to local storage.\r\n  - The new score has to be more than 0.\r\n  - The new score will be saved only if it's higher than the older score. \r\n- loadHighScore() returns the saved integer, OR undefined (if no high score\r\n  exists).\r\n- updateHighScoreHtml() updates the HTML element displaying the high score.\r\n  - If there's no high score, the element is hidden.\r\n  - If there is a high score, the element becomes visible with that value.\r\n */\n\nvar CNY2026_HIGHSCORE_HTML_ID = '#cny2026-high-score';\nvar CNY2026_HIGHSCORE_STORAGE_KEY = 'cny2026.highscore';\nfunction saveHighScore(score) {\n  var _window;\n  var storage = (_window = window) === null || _window === void 0 ? void 0 : _window.localStorage;\n  if (!storage) return;\n  try {\n    var oldScore = loadHighScore();\n    var newScore = parseInt(score);\n    if (!(newScore > 0)) return;\n    if (oldScore === undefined) {\n      storage.setItem(CNY2026_HIGHSCORE_STORAGE_KEY, newScore);\n    } else {\n      storage.setItem(CNY2026_HIGHSCORE_STORAGE_KEY, Math.max(oldScore, newScore));\n    }\n    updateHighScoreHtml();\n  } catch (err) {}\n}\nfunction loadHighScore() {\n  var _window2;\n  var storage = (_window2 = window) === null || _window2 === void 0 ? void 0 : _window2.localStorage;\n  if (!storage) return;\n  try {\n    var score = parseInt(storage.getItem(CNY2026_HIGHSCORE_STORAGE_KEY));\n    if (isNaN(score)) return undefined;\n    return score;\n  } catch (err) {\n    return undefined;\n  }\n}\nfunction updateHighScoreHtml() {\n  var html = document.querySelector(CNY2026_HIGHSCORE_HTML_ID);\n  var score = loadHighScore();\n  if (!html) return;\n  if (Number.isInteger(score)) {\n    html.style.display = 'block';\n    html.innerText = \"High score: \".concat(score);\n  } else {\n    html.style.display = 'none';\n    html.innerText = '';\n  }\n}\n\n//# sourceURL=webpack://cny2026/./src/cny2026/misc/highScore.js?");

/***/ }),

/***/ "./src/cny2026/misc/howManyCarsToSpawn.js":
/*!************************************************!*\
  !*** ./src/cny2026/misc/howManyCarsToSpawn.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ howManyCarsToSpawn)\n/* harmony export */ });\n/*\r\nHow Many Cars to Spawn?\r\nDetermines how many cars to spawn every second.\r\n\r\n- The higher your score, the more cars are spawned.\r\n  - When score is 0, no cars are spawned.\r\n- Used by CNY2026GameManager.\r\n */\n\nfunction howManyCarsToSpawn() {\n  var score = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  if (score >= 1500) return 5;\n  if (score >= 1200) return 4;\n  if (score >= 900) return 3;\n  if (score >= 600) return 2;\n  if (score >= 300) return 1;\n  return 0;\n}\n\n//# sourceURL=webpack://cny2026/./src/cny2026/misc/howManyCarsToSpawn.js?");

/***/ }),

/***/ "./src/cny2026/misc/prettifyMapTiles.js":
/*!**********************************************!*\
  !*** ./src/cny2026/misc/prettifyMapTiles.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ prettifyMapTiles)\n/* harmony export */ });\n/* harmony import */ var _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/constants.js */ \"./src/avo/constants.js\");\n/*\r\nPrettify Map Tiles\r\nGoes through every map tile in a game map, and attempts to \"visually connect\"\r\nsimilar neighbouring tiles.\r\n\r\nInput:\r\n- gameMap: corresponds to the AvO app's .gameMap object.\r\n\r\nOutput:\r\n- Returns true on success, false on failure.\r\n- Modifies the tiles in the gameMap object.\r\n\r\n- The prettify logic works on the idea that the map tile sprites have visual\r\n  variants that factor in when there's a similar tile in an adjacent space.\r\n- For example, a South-facing wall tile has 4 variants: a connecting wall tile\r\n  to the West, a connecting wall tile to the East, a connecting wall tile on\r\n  both East & West, and no connecting wall tiles. \r\n- A floor tile or ceiling tile would have 16 variants.\r\n-  A LOT of this depends on map tile sprites being designed and laid out\r\n  correctly on the sprite sheet. A lot of those locations are hard-coded, too!\r\n */\n\n\nfunction prettifyMapTiles(gameMap) {\n  if (!gameMap) {\n    console.error('prettifyMapTiles(): missing input');\n  }\n  try {\n    // For each wall tile, check adjacencies, then make walls look contiguous.\n    for (var row = 0; row < gameMap.height; row++) {\n      for (var col = 0; col < gameMap.width; col++) {\n        var tile = gameMap.tiles[row][col];\n        if ((tile === null || tile === void 0 ? void 0 : tile._type) === 'wall-tile') {\n          var similarAdjacencies = tile.checkSimilarAdjacencies(gameMap);\n\n          // On our avo-sprites-2025-03-map-tiles.png sprite sheet, the ceiling\n          // tiles are laid out in a 4x4 pattern.\n          tile.ceilingSpriteCol = similarAdjacencies % 4;\n          tile.ceilingSpriteRow = Math.floor(similarAdjacencies / 4);\n\n          // On our avo-sprites-2025-03-map-tiles.png sprite sheet, the wall\n          // tiles are laid out in a 1x4 pattern. btw, we're using bitwise\n          // operators here! (&, not &&)\n          tile.wallSpriteCol = 0;\n          if (similarAdjacencies & _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_ADJACENCIES.EAST) tile.wallSpriteCol += 1;\n          if (similarAdjacencies & _avo_constants_js__WEBPACK_IMPORTED_MODULE_0__.TILE_ADJACENCIES.WEST) tile.wallSpriteCol += 2;\n        }\n      }\n    }\n\n    // CNY2026 hardcoded custom styles!\n    for (var _row = 0; _row < gameMap.height; _row++) {\n      var _loop = function _loop() {\n        var tile = gameMap.tiles[_row][_col];\n        var tileType = tile === null || tile === void 0 ? void 0 : tile._type;\n        if (!tile) return 1; // continue\n\n        // \"Passenger Spawn Zone\" buildings\n        if (tileType === 'wall-tile' && (1 <= _col && _col <= 15 || 41 <= _col && _col <= 55) && (1 <= _row && _row <= 15 || 41 <= _row && _row <= 55)) {\n          tile.ceilingSpriteCol += 4;\n          tile.wallSpriteCol += 4;\n          if (_col === 8 || _col === 48) {\n            tile.wallSpriteCol -= 3;\n          }\n        }\n\n        // \"Drop Off Zone\" building: yellow\n        if (tileType === 'wall-tile' && 25 <= _col && _col <= 31 && 5 <= _row && _row <= 10) {\n          tile.ceilingSpriteCol += 8;\n          tile.wallSpriteCol += 8;\n          if (_col === 28 && _row === 10) {\n            tile.wallSpriteCol -= 3;\n            tile.ceilingSpriteCol -= 3;\n            tile.ceilingSpriteRow -= 2;\n          }\n        }\n\n        // \"Drop Off Zone\" building: blue\n        if (tileType === 'wall-tile' && 5 <= _col && _col <= 11 && 25 <= _row && _row <= 30) {\n          tile.ceilingSpriteCol += 12;\n          tile.wallSpriteCol += 12;\n          if (_col === 8 && _row === 30) {\n            tile.wallSpriteCol -= 3;\n            tile.ceilingSpriteCol -= 3;\n            tile.ceilingSpriteRow -= 2;\n          }\n        }\n\n        // \"Drop Off Zone\" building: green\n        if (tileType === 'wall-tile' && 45 <= _col && _col <= 51 && 25 <= _row && _row <= 30) {\n          tile.ceilingSpriteCol += 8;\n          tile.wallSpriteCol += 8;\n          if (_col === 48 && _row === 30) {\n            tile.wallSpriteCol -= 3;\n            tile.ceilingSpriteCol -= 3;\n            tile.ceilingSpriteRow -= 2;\n          }\n          tile.ceilingSpriteRow += 5;\n          tile.wallSpriteRow += 5;\n        }\n\n        // \"Drop Off Zone\" building: pink\n        if (tileType === 'wall-tile' && 25 <= _col && _col <= 31 && 45 <= _row && _row <= 51) {\n          tile.ceilingSpriteCol += 12;\n          tile.wallSpriteCol += 12;\n          if (_col === 28 && _row === 50) {\n            tile.wallSpriteCol -= 3;\n            tile.ceilingSpriteCol -= 3;\n            tile.ceilingSpriteRow -= 2;\n          }\n          tile.ceilingSpriteRow += 5;\n          tile.wallSpriteRow += 5;\n        }\n\n        // Street Tiles\n        if (tileType === 'street-tile') {\n          var _gameMap$tiles, _gameMap$tiles2, _gameMap$tiles3, _gameMap$tiles4, _gameMap$tiles5, _gameMap$tiles6, _gameMap$tiles7, _gameMap$tiles8;\n          var isNeighbourDifferent = function isNeighbourDifferent(neigbourTile) {\n            return !!['wall-tile', 'floor-tile'].includes(neigbourTile === null || neigbourTile === void 0 ? void 0 : neigbourTile._type);\n          };\n          var sTile = (_gameMap$tiles = gameMap.tiles) === null || _gameMap$tiles === void 0 || (_gameMap$tiles = _gameMap$tiles[_row + 1]) === null || _gameMap$tiles === void 0 ? void 0 : _gameMap$tiles[_col + 0];\n          var nTile = (_gameMap$tiles2 = gameMap.tiles) === null || _gameMap$tiles2 === void 0 || (_gameMap$tiles2 = _gameMap$tiles2[_row - 1]) === null || _gameMap$tiles2 === void 0 ? void 0 : _gameMap$tiles2[_col + 0];\n          var eTile = (_gameMap$tiles3 = gameMap.tiles) === null || _gameMap$tiles3 === void 0 || (_gameMap$tiles3 = _gameMap$tiles3[_row + 0]) === null || _gameMap$tiles3 === void 0 ? void 0 : _gameMap$tiles3[_col + 1];\n          var wTile = (_gameMap$tiles4 = gameMap.tiles) === null || _gameMap$tiles4 === void 0 || (_gameMap$tiles4 = _gameMap$tiles4[_row + 0]) === null || _gameMap$tiles4 === void 0 ? void 0 : _gameMap$tiles4[_col - 1];\n          var seTile = (_gameMap$tiles5 = gameMap.tiles) === null || _gameMap$tiles5 === void 0 || (_gameMap$tiles5 = _gameMap$tiles5[_row + 1]) === null || _gameMap$tiles5 === void 0 ? void 0 : _gameMap$tiles5[_col + 1];\n          var neTile = (_gameMap$tiles6 = gameMap.tiles) === null || _gameMap$tiles6 === void 0 || (_gameMap$tiles6 = _gameMap$tiles6[_row - 1]) === null || _gameMap$tiles6 === void 0 ? void 0 : _gameMap$tiles6[_col + 1];\n          var swTile = (_gameMap$tiles7 = gameMap.tiles) === null || _gameMap$tiles7 === void 0 || (_gameMap$tiles7 = _gameMap$tiles7[_row + 1]) === null || _gameMap$tiles7 === void 0 ? void 0 : _gameMap$tiles7[_col - 1];\n          var nwTile = (_gameMap$tiles8 = gameMap.tiles) === null || _gameMap$tiles8 === void 0 || (_gameMap$tiles8 = _gameMap$tiles8[_row - 1]) === null || _gameMap$tiles8 === void 0 ? void 0 : _gameMap$tiles8[_col - 1];\n          if (isNeighbourDifferent(seTile) && !isNeighbourDifferent(sTile) && !isNeighbourDifferent(eTile)) {\n            tile.floorSpriteRow += 1;\n            tile.floorSpriteCol += 1;\n          } else if (isNeighbourDifferent(neTile) && !isNeighbourDifferent(nTile) && !isNeighbourDifferent(eTile)) {\n            tile.floorSpriteRow -= 1;\n            tile.floorSpriteCol += 1;\n          } else if (isNeighbourDifferent(swTile) && !isNeighbourDifferent(sTile) && !isNeighbourDifferent(wTile)) {\n            tile.floorSpriteRow += 1;\n            tile.floorSpriteCol -= 1;\n          } else if (isNeighbourDifferent(nwTile) && !isNeighbourDifferent(nTile) && !isNeighbourDifferent(wTile)) {\n            tile.floorSpriteRow -= 1;\n            tile.floorSpriteCol -= 1;\n          } else if (isNeighbourDifferent(sTile)) {\n            tile.floorSpriteRow += 1;\n          } else if (isNeighbourDifferent(nTile)) {\n            tile.floorSpriteRow -= 1;\n          } else if (isNeighbourDifferent(eTile)) {\n            tile.floorSpriteCol += 1;\n          } else if (isNeighbourDifferent(wTile)) {\n            tile.floorSpriteCol -= 1;\n          }\n        }\n      };\n      for (var _col = 0; _col < gameMap.width; _col++) {\n        if (_loop()) continue;\n      }\n    }\n  } catch (err) {\n    console.error('prettifyMapTiles(): ', err);\n    return false;\n  }\n  return true;\n}\n\n//# sourceURL=webpack://cny2026/./src/cny2026/misc/prettifyMapTiles.js?");

/***/ }),

/***/ "./src/cny2026/rules/cny2026-game-manager.js":
/*!***************************************************!*\
  !*** ./src/cny2026/rules/cny2026-game-manager.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GAME_STATES: () => (/* binding */ GAME_STATES),\n/* harmony export */   \"default\": () => (/* binding */ CNY2026GameManager)\n/* harmony export */ });\n/* harmony import */ var _avo_rule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/rule */ \"./src/avo/rule/index.js\");\n/* harmony import */ var _avo_game_ai_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @avo/game-ai.js */ \"./src/avo/game-ai.js\");\n/* harmony import */ var _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @avo/constants.js */ \"./src/avo/constants.js\");\n/* harmony import */ var _misc_highScore_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../misc/highScore.js */ \"./src/cny2026/misc/highScore.js\");\n/* harmony import */ var _misc_howManyCarsToSpawn_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../misc/howManyCarsToSpawn.js */ \"./src/cny2026/misc/howManyCarsToSpawn.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n/*\r\nCNY2026 Game Manager\r\nManages a single round of gameplay. Keeps track of time, scoring, and the\r\nfinish (\"victory\"/\"game over\") conditions. Spawns Passengers and Cars to keep\r\nthings interesting.\r\n\r\nRules:\r\n- Timed Score Game: this game is about accumulating as high a score as possible\r\n  in a limited time. \r\n  - The game timer (in the Active state) only starts after the player has\r\n    delivered at least one Passenger.\r\n- States: the Game Manager starts the game in an 'active' state, then switches\r\n  to a 'finished' state when time is up.\r\n  - Active: player can move the Hero around, and passengers and cars will spawn.\r\n  - Game Over (Finished): when time runs out, the game shows a \"Finished Screen\"\r\n    with the player's score.\r\n- Create Passengers: every 1 second, the Game Manager checks if there are\r\n  enough Passengers in the game.\r\n  - \"Enough\" is determined by targetNumberOfPassengers\r\n  - If there aren't enough Passengers, the game manager will select a random\r\n    PassengerSpawnZone, which doesn't have any nearby Passengers, and attempt to create\r\n    a new Passenger there.\r\n- Create Cars: every 1 second, the Game will spawn Cars that zoom across the\r\n  city.\r\n- Scoring: when a Passenger is successfully dropped off at their Destination\r\n  DropOffZone, the score is incremented. This is triggered by the DropOffZone.\r\n */\n\n\n\n\n\n\nvar SHUFFLE = 10;\nvar DEFAULT_TARGET_NUMBER_OF_PASSENGERS = 3;\nvar TIME_TO_SPAWN = 1 * 60;\nvar ACTIVE_GAME_TIME = 1.5 * 60 * _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.FRAMES_PER_SECOND;\nvar FINISHED_SCREEN_ANIMATION_TIME = 0.5 * _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.FRAMES_PER_SECOND;\nvar FINISHED_SCREEN_TIME = 10 * _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.FRAMES_PER_SECOND;\nvar SCORE_PER_PICKUP = 100;\nvar MAX_DURATION_OF_ESCALATION_MUSIC = 50 * _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.FRAMES_PER_SECOND;\nvar SCORE_THRESHOLD_FOR_ESCALATION_MUSIC = 300;\nvar GAME_STATES = {\n  STARTING_UP: 'init',\n  // Show startup screen. \n  ACTIVE: 'active',\n  // Gameplay!\n  FINISHED: 'finished' // Show finished screen\n};\nvar CNY2026GameManager = /*#__PURE__*/function (_Rule) {\n  function CNY2026GameManager(app) {\n    var _this;\n    _classCallCheck(this, CNY2026GameManager);\n    _this = _callSuper(this, CNY2026GameManager, [app]);\n    _this._type = 'cny2026-game-manager';\n    _this.targetNumberOfPassengers = DEFAULT_TARGET_NUMBER_OF_PASSENGERS;\n    _this.gameTimer = 0;\n    _this.spawnTimer = 0;\n    _this.state = GAME_STATES.STARTING_UP;\n    _this.score = 0;\n    return _this;\n  }\n  _inherits(CNY2026GameManager, _Rule);\n  return _createClass(CNY2026GameManager, [{\n    key: \"deconstructor\",\n    value: function deconstructor() {}\n  }, {\n    key: \"play\",\n    value: function play() {\n      if (this.state === GAME_STATES.ACTIVE) {\n        // In the active game state, we keep track of two timers:\n        // - the game timer limits how long a round of gameplay lasts\n        // - the spawn timer causes new passengers and new enemies to spawn at a\n        //   regular rate.\n\n        // Don't start the game timer until the player has delivered at least one passenger.\n        if (this.score > 0) {\n          this.gameTimer++;\n        }\n        this.spawnTimer++;\n\n        // Spawn Passengers and Cars every second.\n        if (this.spawnTimer >= TIME_TO_SPAWN) {\n          this.populatePassengers();\n          this.populateCars();\n          this.spawnTimer = 0;\n        }\n\n        // Is it time to escalate the music?\n        if (this.gameTimer === ACTIVE_GAME_TIME - MAX_DURATION_OF_ESCALATION_MUSIC && this.score >= SCORE_THRESHOLD_FOR_ESCALATION_MUSIC) {\n          this._app.rules.get('sound-manager').playEscalationMusic();\n        }\n\n        // Is the game round over?\n        if (this.gameTimer >= ACTIVE_GAME_TIME) {\n          this.gameTimer = 0;\n          this.state = GAME_STATES.FINISHED;\n          (0,_misc_highScore_js__WEBPACK_IMPORTED_MODULE_3__.saveHighScore)(this.score);\n          this._app.rules.get('sound-manager').playFinishingMusic();\n        }\n      } else if (this.state === GAME_STATES.FINISHED) {\n        // In the finished game state\n        // - the \"Finished Screen\" will appear and animate for a short while.\n        //   (see FINISHED_SCREEN_ANIMATE_TIME and paintFinishedScreen())\n        // - the \"Finished Screen\" will linger for the duration of\n        //   FINISHED_SCREEN_TIME. After that, the main menu will open again.\n        // - we're still using the game timer to keep track of time.\n\n        if (this.gameTimer < FINISHED_SCREEN_TIME) {\n          this.gameTimer++;\n          if (this.gameTimer >= FINISHED_SCREEN_TIME) {\n            this._app.setHomeMenu(true);\n            this._app.rules.get('sound-manager').fadeOutMusic();\n          }\n        }\n      }\n    }\n  }, {\n    key: \"paint\",\n    value: function paint() {\n      var layer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      if (layer === _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.LAYERS.OVERLAY) {\n        if (this.state === GAME_STATES.ACTIVE) {\n          this.paintActiveGameUI();\n        }\n        if (this.state === GAME_STATES.FINISHED) {\n          this.paintFinishedScreen();\n        }\n      }\n    }\n\n    /*\r\n    Draw UI for when the game is active, such as timer and score.\r\n      */\n  }, {\n    key: \"paintActiveGameUI\",\n    value: function paintActiveGameUI() {\n      var c2d = this._app.canvas2d;\n      var X_OFFSET = _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.TILE_SIZE * 1.5;\n      var Y_OFFSET = _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.TILE_SIZE * -1.0;\n      var MID_X = this._app.canvasWidth / 2;\n      var MID_Y = this._app.canvasHeight / 2;\n      var LEFT = X_OFFSET;\n      var RIGHT = this._app.canvasWidth - X_OFFSET;\n      var TOP = -Y_OFFSET;\n      var BOTTOM = this._app.canvasHeight + Y_OFFSET;\n      var CLOCK_RADIUS = 24;\n      c2d.font = 'bold 2em Source Code Pro, monospace';\n      c2d.textBaseline = 'middle';\n      c2d.lineWidth = 8;\n\n      // The game timer (in Active mode) doesn't start until the player has\n      // delivered at least one passenger.\n      if (this.score > 0) {\n        // Paint clock\n        var gameTimeLeft = this.gameTimer / ACTIVE_GAME_TIME;\n        c2d.fillStyle = 'hsl(30, 80%, 60%)';\n        c2d.strokeStyle = '#fff';\n        c2d.lineWidth = 2;\n        c2d.beginPath();\n        c2d.lineTo(MID_X, TOP - CLOCK_RADIUS);\n        c2d.moveTo(MID_X, TOP);\n        c2d.arc(MID_X, TOP, CLOCK_RADIUS, -0.5 * Math.PI + gameTimeLeft * 2 * Math.PI, -0.5 * Math.PI);\n        c2d.lineTo(MID_X, TOP);\n        c2d.fill();\n        c2d.stroke();\n\n        // Paint timer\n        var currentTime = ACTIVE_GAME_TIME - this.gameTimer;\n        var timeInMilliseconds = Math.floor(currentTime % _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.FRAMES_PER_SECOND / _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.FRAMES_PER_SECOND * 1000);\n        var textInMilliseconds = timeInMilliseconds.toString().padStart(3, '0').slice(0, 2);\n        var timeInSeconds = Math.floor(currentTime / _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.FRAMES_PER_SECOND);\n        var textInSeconds = timeInSeconds.toString().padStart(3, ' ');\n        var timeText = \"time\\u2BC8 \".concat(textInSeconds, \".\").concat(textInMilliseconds);\n        c2d.textAlign = 'left';\n        c2d.strokeStyle = '#fff';\n        c2d.strokeText(timeText, MID_X + CLOCK_RADIUS * 1.5, TOP);\n        c2d.fillStyle = 'hsl(30, 80%, 60%)';\n        c2d.fillText(timeText, MID_X + CLOCK_RADIUS * 1.5, TOP);\n      }\n\n      // Paint score\n      var score = this.score;\n      var textScore = \"\".concat(score, \" \\u2BC7score\");\n      c2d.textAlign = 'right';\n      c2d.strokeStyle = '#fff';\n      c2d.strokeText(textScore, MID_X - CLOCK_RADIUS * 1.5, TOP);\n      c2d.fillStyle = '#c04040';\n      c2d.fillText(textScore, MID_X - CLOCK_RADIUS * 1.5, TOP);\n    }\n\n    /*\r\n    Draw UI for the \"this game is finished\" screen.\r\n    - The Finished Screen will animate for a short while (until\r\n      FINISHED_SCREEN_ANIMATION_TIME)\r\n    - After that, the Finished Screen will remain static. \r\n     */\n  }, {\n    key: \"paintFinishedScreen\",\n    value: function paintFinishedScreen() {\n      var progress = Math.max(Math.min(this.gameTimer / FINISHED_SCREEN_ANIMATION_TIME, 1), 0);\n      var c2d = this._app.canvas2d;\n      var text = '';\n      var Y_OFFSET = _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.TILE_SIZE * 1;\n      var MID_X = this._app.canvasWidth / 2;\n      var MID_Y = this._app.canvasHeight / 2;\n      var TARGET_RADIUS = Math.min(this._app.canvasWidth, this._app.canvasHeight) / 2;\n      c2d.lineWidth = 8;\n\n      // Paint background\n      var backgroundRadius = progress * TARGET_RADIUS;\n      c2d.fillStyle = 'rgba(255, 255, 255, 0.8)';\n      c2d.beginPath();\n      c2d.arc(MID_X, MID_Y, backgroundRadius, 0, 2 * Math.PI);\n      c2d.fill();\n\n      // Paint text 1: \"Game Over\"\n      text = 'Shift complete!';\n      c2d.font = \"\".concat((progress * 3 + 1).toFixed(2), \"em Source Code Pro, monospace\");\n      c2d.textAlign = 'center';\n      c2d.textBaseline = 'bottom';\n      c2d.strokeStyle = '#fff';\n      c2d.strokeText(text, MID_X, MID_Y - Y_OFFSET);\n      c2d.fillStyle = '#c04040';\n      c2d.fillText(text, MID_X, MID_Y - Y_OFFSET);\n\n      // Paint text 2: score\n      text = \"Your score: \".concat(this.score);\n      c2d.font = \"bold \".concat((progress * 2 + 0.5).toFixed(2), \"em Source Code Pro, monospace\");\n      c2d.textAlign = 'center';\n      c2d.textBaseline = 'top';\n      c2d.strokeStyle = '#fff';\n      c2d.strokeText(text, MID_X, MID_Y + Y_OFFSET);\n      c2d.fillStyle = '#c04040';\n      c2d.fillText(text, MID_X, MID_Y + Y_OFFSET);\n    }\n\n    // Start the game round!\n  }, {\n    key: \"start\",\n    value: function start() {\n      if (this.state === GAME_STATES.STARTING_UP) {\n        this.state = GAME_STATES.ACTIVE;\n      }\n    }\n\n    // Checks if there are enough Passengers in the game. If not, create one.\n  }, {\n    key: \"populatePassengers\",\n    value: function populatePassengers() {\n      var app = this._app;\n      var passengers = app.entities.filter(function (entity) {\n        return entity._type === 'passenger';\n      });\n      if (passengers.length < DEFAULT_TARGET_NUMBER_OF_PASSENGERS) {\n        // Find a spawn zone that isn't currently occupied by an existing Passenger\n        var spawnZones = app.entities.filter(function (entity) {\n          return entity._type === 'passenger-spawn-zone';\n        });\n        var spawnZonesWithNoNearbyPassengers = spawnZones.filter(function (spawnZone) {\n          return spawnZone.getNearbyPassengers().length === 0;\n        });\n        if (spawnZonesWithNoNearbyPassengers.length > 0) {\n          var randomIndex = Math.floor(Math.random() * spawnZonesWithNoNearbyPassengers.length);\n          spawnZonesWithNoNearbyPassengers[randomIndex].spawnPassenger();\n        }\n      }\n    }\n\n    // Create new cars every once in a while.\n  }, {\n    key: \"populateCars\",\n    value: function populateCars() {\n      var app = this._app;\n      var spawnZones = app.entities.filter(function (entity) {\n        return entity._type === 'car-spawn-zone';\n      });\n      spawnZones = _avo_game_ai_js__WEBPACK_IMPORTED_MODULE_1__.GameAI.shuffleArray(spawnZones, SHUFFLE);\n      var carsToSpawn = (0,_misc_howManyCarsToSpawn_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(this.score);\n      for (var i = 0; i < carsToSpawn && i < spawnZones.length; i++) {\n        spawnZones[i].spawnCar();\n      }\n    }\n  }, {\n    key: \"increaseScore\",\n    value: function increaseScore() {\n      if (this.state === GAME_STATES.ACTIVE) {\n        this.score += SCORE_PER_PICKUP;\n      }\n      var soundManager = this._app.rules.get('sound-manager');\n\n      // Start the Gong Xi Music once player has delivered one passenger.\n      // This is also when the game timer starts.\n      if (this.score === 100) {\n        soundManager.playStartingMusic();\n      }\n    }\n  }]);\n}(_avo_rule__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n\n//# sourceURL=webpack://cny2026/./src/cny2026/rules/cny2026-game-manager.js?");

/***/ }),

/***/ "./src/cny2026/rules/cny2026-start-up.js":
/*!***********************************************!*\
  !*** ./src/cny2026/rules/cny2026-start-up.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ CNY2026StartUp)\n/* harmony export */ });\n/* harmony import */ var _avo_rule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/rule */ \"./src/avo/rule/index.js\");\n/* harmony import */ var _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @avo/constants.js */ \"./src/avo/constants.js\");\n/* harmony import */ var _cny2026_game_manager_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cny2026-game-manager.js */ \"./src/cny2026/rules/cny2026-game-manager.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n/*\r\nCNY2026 Startup\r\nThe Startup is shown before every round of gameplay.\r\n\r\n- Displays the starting message. (i.e. goal of the game and tutorial)\r\n- Starts the gameplay round after seeing some user input.\r\n  - There's a short delay before user input is recognised, to prevent the game\r\n    accidentally starting too soon and ensuring players get to see the starting\r\n    message.\r\n */\n\n\n\n\nvar START_UP_DELAY = 1 * _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.FRAMES_PER_SECOND;\nvar SHORT_ANIMATION_DURATION = 1 * _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.FRAMES_PER_SECOND;\nvar LONG_ANIMATION_DURATION = 3 * _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.FRAMES_PER_SECOND;\nvar CNY2026StartUp = /*#__PURE__*/function (_Rule) {\n  function CNY2026StartUp(app) {\n    var _this;\n    _classCallCheck(this, CNY2026StartUp);\n    _this = _callSuper(this, CNY2026StartUp, [app]);\n    _this.startUpTimer = 0; // Wait a while before letting players start the game.\n    _this.shortAnimationTimer = 0;\n    _this.longAnimationTimer = 0;\n    return _this;\n  }\n  _inherits(CNY2026StartUp, _Rule);\n  return _createClass(CNY2026StartUp, [{\n    key: \"play\",\n    value: function play() {\n      var _app$rules$get;\n      var app = this._app;\n      var gameState = (_app$rules$get = app.rules.get('cny2026-game-manager')) === null || _app$rules$get === void 0 ? void 0 : _app$rules$get.state;\n\n      // Only do something if the gameplay round is starting up\n      if (gameState !== _cny2026_game_manager_js__WEBPACK_IMPORTED_MODULE_2__.GAME_STATES.STARTING_UP) return;\n\n      // Tick the animation counters\n      this.shortAnimationTimer = (this.shortAnimationTimer + 1) % SHORT_ANIMATION_DURATION;\n      this.longAnimationTimer = (this.longAnimationTimer + 1) % LONG_ANIMATION_DURATION;\n\n      // Actually, wait for a while before letting players start the game.\n      // Otherwise, they might click too fast to see the tutorial.\n      if (this.startUpTimer < START_UP_DELAY) {\n        this.startUpTimer++;\n        return;\n      }\n\n      // OK, now start the game as soon as we see any user input.\n      var _app$playerInput = app.playerInput,\n        keysPressed = _app$playerInput.keysPressed,\n        pointerState = _app$playerInput.pointerState;\n      if (pointerState === _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.POINTER_STATES.POINTER_DOWN || keysPressed['ArrowRight'] || keysPressed['ArrowDown'] || keysPressed['ArrowLeft'] || keysPressed['ArrowUp']) {\n        this.start();\n      }\n    }\n  }, {\n    key: \"paint\",\n    value: function paint() {\n      var _app$rules$get2;\n      var layer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var app = this._app;\n      var gameState = (_app$rules$get2 = app.rules.get('cny2026-game-manager')) === null || _app$rules$get2 === void 0 ? void 0 : _app$rules$get2.state;\n      if (layer === _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.LAYERS.OVERLAY && gameState === _cny2026_game_manager_js__WEBPACK_IMPORTED_MODULE_2__.GAME_STATES.STARTING_UP) {\n        var c2d = app.canvas2d;\n        var startUpProgress = this.startUpTimer / START_UP_DELAY;\n\n        // Paint background\n        c2d.fillStyle = \"rgb(255, 255, 255, \".concat(1.0 - startUpProgress * 0.4, \")\");\n        c2d.beginPath();\n        c2d.rect(0, 0, app.canvasWidth, app.canvasHeight);\n        c2d.fill();\n\n        // Paint goals\n        this.paintGoals();\n        this.paintAnimatedExample();\n\n        // Paint \"Let's go!\" prompt and instructions\n        // Do this only when input is ready to start the game. No point telling\n        // people to Let's Go! when we can't, uh, go.\n        if (startUpProgress >= 1) {\n          this.paintLetsGoPrompt();\n          this.paintInstructions();\n        }\n      }\n    }\n  }, {\n    key: \"paintGoals\",\n    value: function paintGoals() {\n      var app = this._app;\n      var c2d = app.canvas2d;\n      var text = 'Deliver passengers to their destinations!';\n      var MID_X = app.canvasWidth / 2;\n      var MID_Y = app.canvasHeight / 2;\n      c2d.font = 'bold 2em Source Code Pro, monospace';\n      c2d.textAlign = 'center';\n      c2d.textBaseline = 'middle';\n      c2d.lineWidth = 8;\n      c2d.strokeStyle = '#ffffff';\n      c2d.fillStyle = '#c04040';\n      c2d.strokeText(text, MID_X, MID_Y - _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE * 7);\n      c2d.fillText(text, MID_X, MID_Y - _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE * 7);\n    }\n  }, {\n    key: \"paintLetsGoPrompt\",\n    value: function paintLetsGoPrompt() {\n      var app = this._app;\n      var c2d = app.canvas2d;\n      var text = 'Let\\'s go!';\n      var MID_X = app.canvasWidth / 2;\n      var MID_Y = app.canvasHeight / 2;\n      c2d.font = 'bold 2em Source Code Pro, monospace';\n      c2d.textAlign = 'center';\n      c2d.textBaseline = 'middle';\n      c2d.lineWidth = 8;\n      c2d.strokeStyle = '#ffffff';\n      c2d.fillStyle = '#c04040';\n      c2d.strokeText(text, MID_X, MID_Y + _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE * 2);\n      c2d.fillText(text, MID_X, MID_Y + _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE * 2);\n    }\n  }, {\n    key: \"paintAnimatedExample\",\n    value: function paintAnimatedExample() {\n      var app = this._app;\n      var progress = this.longAnimationTimer / LONG_ANIMATION_DURATION;\n      var MID_X = app.canvasWidth / 2;\n      var MID_Y = app.canvasHeight / 2;\n      var Y = MID_Y - _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE * 3;\n      var HORSE_MIN_X = MID_X - _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE * 12;\n      var HORSE_MAX_X = MID_X + _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE * 12;\n      var PASSENGER_START_X = MID_X - _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE * 4;\n      var PASSENGER_END_X = MID_X + _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE * 4;\n\n      // Drop Off Zone!\n      this.paintSprite({\n        spriteSheet: app.assets['zones'].img,\n        spriteCol: 1,\n        spriteRow: 1,\n        spriteScale: 3,\n        x: PASSENGER_END_X,\n        y: Y\n      });\n\n      // Horse!\n      var horseX = (HORSE_MAX_X - HORSE_MIN_X) * progress + HORSE_MIN_X;\n      this.paintSprite({\n        spriteSheet: app.assets['horse'].img,\n        spriteCol: 1,\n        spriteRow: 1,\n        spriteScale: 4,\n        x: horseX,\n        y: Y\n      });\n\n      // Passenger!\n      // Must be painted after the horse\n      var passengerX = Math.min(Math.max(PASSENGER_START_X, horseX), PASSENGER_END_X);\n      var passengerPickedUp = horseX >= PASSENGER_START_X;\n      var passengerDroppedOff = horseX >= PASSENGER_END_X;\n      this.paintSprite({\n        spriteSheet: app.assets['passengers'].img,\n        spriteCol: 0,\n        spriteRow: passengerDroppedOff ? 2 : passengerPickedUp ? 1 : 0,\n        spriteScale: 3,\n        spriteSizeX: 24,\n        spriteSizeY: 24,\n        spriteOffsetX: -12,\n        spriteOffsetY: passengerPickedUp && !passengerDroppedOff ? -24 : -16,\n        x: passengerX,\n        y: Y\n      });\n    }\n  }, {\n    key: \"paintInstructions\",\n    value: function paintInstructions() {\n      var app = this._app;\n      var MID_X = app.canvasWidth / 2;\n      var MID_Y = app.canvasHeight / 2;\n      var progress = this.shortAnimationTimer / SHORT_ANIMATION_DURATION;\n\n      // Paint keyboard controls\n      this.paintSprite({\n        spriteSheet: app.assets['misc'].img,\n        spriteCol: progress < 0.5 ? 0 : 1,\n        spriteRow: 0,\n        spriteScale: 4,\n        x: MID_X - _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE * 8,\n        y: MID_Y + _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE * 2\n      });\n\n      // Paint touch controls\n      this.paintSprite({\n        spriteSheet: app.assets['misc'].img,\n        spriteCol: progress < 0.5 ? 2 : 3,\n        spriteRow: 0,\n        spriteScale: 4,\n        x: MID_X + _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE * 8,\n        y: MID_Y + _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE * 2\n      });\n    }\n  }, {\n    key: \"paintSprite\",\n    value: function paintSprite() {\n      var _args$spriteSizeX, _args$spriteSizeY, _args$spriteCol, _args$spriteRow, _args$spriteScale, _args$spriteScale2, _args$spriteOffsetX, _args$spriteOffsetY;\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n        spriteSheet: undefined,\n        x: undefined,\n        y: undefined,\n        // Source values\n        spriteCol: undefined,\n        // Column and row of source sprite on the sprite sheet. \n        spriteRow: undefined,\n        spriteSizeX: undefined,\n        // Size of source sprite on sprite sheet.\n        spriteSizeY: undefined,\n        // Painting target values\n        spriteOffsetX: undefined,\n        // Offset of sprite relative to this Entity's {x,y}, when painted on canvas.\n        spriteOffsetY: undefined,\n        // This is usually -0.5 * spriteSizeXorY to make sure the sprite is centred on Entity.\n        spriteScale: undefined // Scale of the sprite when paint()ed.\n      };\n      var app = this._app;\n      var c2d = app.canvas2d;\n      if (!args.spriteSheet) return;\n\n      // Calculate all the variables\n      var sizeX = (_args$spriteSizeX = args === null || args === void 0 ? void 0 : args.spriteSizeX) !== null && _args$spriteSizeX !== void 0 ? _args$spriteSizeX : _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE;\n      var sizeY = (_args$spriteSizeY = args === null || args === void 0 ? void 0 : args.spriteSizeY) !== null && _args$spriteSizeY !== void 0 ? _args$spriteSizeY : _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE;\n      var srcX = ((_args$spriteCol = args === null || args === void 0 ? void 0 : args.spriteCol) !== null && _args$spriteCol !== void 0 ? _args$spriteCol : 0) * sizeX;\n      var srcY = ((_args$spriteRow = args === null || args === void 0 ? void 0 : args.spriteRow) !== null && _args$spriteRow !== void 0 ? _args$spriteRow : 0) * sizeY;\n      var scaleX = (_args$spriteScale = args === null || args === void 0 ? void 0 : args.spriteScale) !== null && _args$spriteScale !== void 0 ? _args$spriteScale : 1;\n      var scaleY = (_args$spriteScale2 = args === null || args === void 0 ? void 0 : args.spriteScale) !== null && _args$spriteScale2 !== void 0 ? _args$spriteScale2 : 1;\n      c2d.save();\n      c2d.translate(args.x, args.y); // 1. This moves the 'drawing origin' to match the position of (the centre of) the Entity.\n      c2d.scale(scaleX, scaleY); // 2. This ensures the sprite scales with the 'drawing origin' as the anchor point.\n\n      // 4. tgtX and tgtY specify where to draw the sprite, relative to the 'drawing origin'.\n      var tgtX = (_args$spriteOffsetX = args === null || args === void 0 ? void 0 : args.spriteOffsetX) !== null && _args$spriteOffsetX !== void 0 ? _args$spriteOffsetX : -sizeX / 2;\n      var tgtY = (_args$spriteOffsetY = args === null || args === void 0 ? void 0 : args.spriteOffsetY) !== null && _args$spriteOffsetY !== void 0 ? _args$spriteOffsetY : -sizeY / 2;\n      c2d.drawImage(args.spriteSheet, srcX, srcY, sizeX, sizeY, tgtX, tgtY, sizeX, sizeY);\n      c2d.restore();\n    }\n\n    // Start the game round!\n  }, {\n    key: \"start\",\n    value: function start() {\n      var _app$rules$get3;\n      var app = this._app;\n      (_app$rules$get3 = app.rules.get('cny2026-game-manager')) === null || _app$rules$get3 === void 0 || _app$rules$get3.start();\n    }\n  }]);\n}(_avo_rule__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n\n//# sourceURL=webpack://cny2026/./src/cny2026/rules/cny2026-start-up.js?");

/***/ }),

/***/ "./src/cny2026/rules/passenger-guidance.js":
/*!*************************************************!*\
  !*** ./src/cny2026/rules/passenger-guidance.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ PassengerGuidance)\n/* harmony export */ });\n/* harmony import */ var _avo_rule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/rule */ \"./src/avo/rule/index.js\");\n/* harmony import */ var _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @avo/constants.js */ \"./src/avo/constants.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n/*\r\nPassenger Guidance\r\nThis Rule adds a UI overlay that helps direct players to passengers, or the\r\ndestination of a carried passenger.\r\n */\n\n\n\nvar GUIDANCE_RADIUS = _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE * 4;\nvar DESINTATION_ARROW_WIDTH_ANGLE = 0.1;\nvar DESTINATION_ARROW_BASE_LENGTH = _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE * 3.5;\nvar PassengerGuidance = /*#__PURE__*/function (_Rule) {\n  function PassengerGuidance(app) {\n    var _this;\n    _classCallCheck(this, PassengerGuidance);\n    _this = _callSuper(this, PassengerGuidance, [app]);\n    _this._type = 'passenger-directions';\n    return _this;\n  }\n  _inherits(PassengerGuidance, _Rule);\n  return _createClass(PassengerGuidance, [{\n    key: \"paint\",\n    value: function paint(layer) {\n      if (layer === _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.LAYERS.OVERLAY) {\n        var app = this._app;\n        var hero = app.hero;\n        var passenger = hero === null || hero === void 0 ? void 0 : hero.passenger;\n        if (passenger) {\n          var dropOffZones = app.entities.filter(function (entity) {\n            return entity._type === 'drop-off-zone';\n          });\n          var c2d = app.canvas2d;\n          var MID_X = app.canvasWidth / 2;\n          var MID_Y = app.canvasHeight / 2;\n\n          // Guidance circle\n          c2d.strokeStyle = 'rgba(255, 255, 255, 0.05)';\n          c2d.lineWidth = 2;\n          c2d.beginPath();\n          c2d.arc(MID_X, MID_Y, GUIDANCE_RADIUS, 0, 2 * Math.PI);\n          c2d.stroke();\n          c2d.closePath();\n\n          // Destination arrow.\n          var destination = dropOffZones.find(function (zone) {\n            return zone.id === passenger.destination;\n          });\n          if (!destination) return;\n          var distX = destination.x - hero.x;\n          var distY = destination.y - hero.y;\n          var dist = Math.sqrt(distY * distY + distX * distX);\n          var angle = Math.atan2(distY, distX);\n          var cos = Math.cos,\n            sin = Math.sin;\n          if (dist > GUIDANCE_RADIUS) {\n            switch (passenger.destination) {\n              case 0:\n                c2d.fillStyle = 'hsla(60, 80%, 60%, 0.5)';\n                break;\n              case 1:\n                c2d.fillStyle = 'hsla(210, 80%, 60%, 0.5)';\n                break;\n              case 2:\n                c2d.fillStyle = 'hsla(120, 80%, 60%, 0.5)';\n                break;\n              case 3:\n                c2d.fillStyle = 'hsla(330, 80%, 60%, 0.5)';\n                break;\n              default:\n                c2d.fillStyle = 'hsla(0, 0%, 100%, 0.5)';\n            }\n            c2d.strokeStyle = 'hsla(0, 0%, 100%, 0.5)';\n            c2d.lineWidth = 2;\n            c2d.beginPath();\n            c2d.moveTo(MID_X + cos(angle) * GUIDANCE_RADIUS, MID_Y + sin(angle) * GUIDANCE_RADIUS);\n            c2d.lineTo(MID_X + cos(angle + DESINTATION_ARROW_WIDTH_ANGLE) * DESTINATION_ARROW_BASE_LENGTH, MID_Y + sin(angle + DESINTATION_ARROW_WIDTH_ANGLE) * DESTINATION_ARROW_BASE_LENGTH);\n            c2d.lineTo(MID_X + cos(angle - DESINTATION_ARROW_WIDTH_ANGLE) * DESTINATION_ARROW_BASE_LENGTH, MID_Y + sin(angle - DESINTATION_ARROW_WIDTH_ANGLE) * DESTINATION_ARROW_BASE_LENGTH);\n            c2d.closePath();\n            c2d.fill();\n            c2d.stroke();\n          }\n        }\n      }\n    }\n  }]);\n}(_avo_rule__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n\n//# sourceURL=webpack://cny2026/./src/cny2026/rules/passenger-guidance.js?");

/***/ }),

/***/ "./src/cny2026/rules/player-bounds.js":
/*!********************************************!*\
  !*** ./src/cny2026/rules/player-bounds.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ PlayerBounds)\n/* harmony export */ });\n/* harmony import */ var _avo_rule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/rule */ \"./src/avo/rule/index.js\");\n/* harmony import */ var _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @avo/constants.js */ \"./src/avo/constants.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n/*\r\nPlayer Bounds\r\nThe Hero must always remain within the bounds of the game map.\r\n */\n\n\n\nvar PlayerBounds = /*#__PURE__*/function (_Rule) {\n  function PlayerBounds(app) {\n    var _this;\n    _classCallCheck(this, PlayerBounds);\n    _this = _callSuper(this, PlayerBounds, [app]);\n    _this._type = 'player-bounds';\n    return _this;\n  }\n  _inherits(PlayerBounds, _Rule);\n  return _createClass(PlayerBounds, [{\n    key: \"play\",\n    value: function play() {\n      var hero = this._app.hero;\n      var gameMap = this._app.gameMap;\n      if (!hero || !gameMap || !gameMap.width || !gameMap.height) return;\n      var MIN_X = 0;\n      var MIN_Y = 0;\n      var MAX_X = gameMap.width * _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE - 1;\n      var MAX_Y = gameMap.height * _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.TILE_SIZE - 1;\n      if (hero.x < MIN_X) {\n        hero.x = MIN_X;\n        hero.moveX = -hero.moveX;\n        hero.pushX = -hero.pushX;\n      }\n      if (hero.x > MAX_X) {\n        hero.x = MAX_X;\n        hero.moveX = -hero.moveX;\n        hero.pushX = -hero.pushX;\n      }\n      if (hero.y < MIN_Y) {\n        hero.y = MIN_Y;\n        hero.moveY = -hero.moveY;\n        hero.pushY = -hero.pushY;\n      }\n      if (hero.y > MAX_Y) {\n        hero.y = MAX_Y;\n        hero.moveY = -hero.moveY;\n        hero.pushY = -hero.pushY;\n      }\n    }\n  }]);\n}(_avo_rule__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n\n//# sourceURL=webpack://cny2026/./src/cny2026/rules/player-bounds.js?");

/***/ }),

/***/ "./src/cny2026/rules/player-controls.js":
/*!**********************************************!*\
  !*** ./src/cny2026/rules/player-controls.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ PlayerControls)\n/* harmony export */ });\n/* harmony import */ var _avo_rule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/rule */ \"./src/avo/rule/index.js\");\n/* harmony import */ var _cny2026_game_manager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cny2026-game-manager.js */ \"./src/cny2026/rules/cny2026-game-manager.js\");\n/* harmony import */ var _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @avo/constants.js */ \"./src/avo/constants.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && \"function\" == typeof p ? function (t) { return p.apply(e, t); } : p; }\nfunction _get() { return _get = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }\nfunction _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n/*\r\nPlayer Controls\r\nStandard player controls for top-down adventure games.\r\n\r\nKeyboard controls:\r\n- Up/down/left/right keys moves the Hero around the map.\r\n\r\nTouch controls:\r\n- Drag action moves the Hero around the map.\r\n  - The initial touch/start of drag acts as a \"base\".\r\n  - The direction of the Hero's movement is determined by the current position\r\n    of the touch/cursor relative to the base.\r\n */\n\n\n\n\nvar PlayerControls = /*#__PURE__*/function (_Rule) {\n  function PlayerControls(app) {\n    var _this;\n    _classCallCheck(this, PlayerControls);\n    _this = _callSuper(this, PlayerControls, [app]);\n    _this._type = 'player-controls';\n    _this.inputTap = false;\n    _this.onKeyDown = _this.onKeyDown.bind(_this);\n    _this.onKeyUp = _this.onKeyUp.bind(_this);\n    app.addEventListener('keydown', _this.onKeyDown);\n    app.addEventListener('keyup', _this.onKeyUp);\n    _this.onPointerTap = _this.onPointerTap.bind(_this);\n    app.addEventListener('pointertap', _this.onPointerTap);\n    return _this;\n  }\n  _inherits(PlayerControls, _Rule);\n  return _createClass(PlayerControls, [{\n    key: \"deconstructor\",\n    value: function deconstructor() {\n      app.removeEventListener('keydown', this.onKeyDown);\n      app.removeEventListener('keyup', this.onKeyUp);\n      app.removeEventListener('pointertap', this.onPointerTap);\n    }\n  }, {\n    key: \"play\",\n    value: function play() {\n      var _app$rules$get;\n      var app = this._app;\n      var hero = app.hero;\n      var gameState = (_app$rules$get = app.rules.get('cny2026-game-manager')) === null || _app$rules$get === void 0 ? void 0 : _app$rules$get.state;\n      _superPropGet(PlayerControls, \"play\", this, 3)([]);\n      if (hero && gameState !== _cny2026_game_manager_js__WEBPACK_IMPORTED_MODULE_1__.GAME_STATES.STARTING_UP) {\n        var _app$playerInput = app.playerInput,\n          keysPressed = _app$playerInput.keysPressed,\n          pointerCurrent = _app$playerInput.pointerCurrent,\n          pointerStart = _app$playerInput.pointerStart,\n          pointerState = _app$playerInput.pointerState;\n        var intent = undefined;\n        var directionX = 0;\n        var directionY = 0;\n        if (pointerState === _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.POINTER_STATES.POINTER_DOWN) {\n          // Get pointer input if there's any.\n\n          var distX = pointerCurrent.x - pointerStart.x;\n          var distY = pointerCurrent.y - pointerStart.y;\n          var pointerDistance = Math.sqrt(distX * distX + distY * distY);\n          // const movementAngle = Math.atan2(distY, distX)\n\n          if (pointerDistance > _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.POINTER_DEADZONE_RADIUS) {\n            directionX = distX / pointerDistance;\n            directionY = distY / pointerDistance;\n          }\n        } else {\n          // Otherwise, check for keyboard input.\n\n          if (keysPressed['ArrowRight']) directionX++;\n          if (keysPressed['ArrowDown']) directionY++;\n          if (keysPressed['ArrowLeft']) directionX--;\n          if (keysPressed['ArrowUp']) directionY--;\n        }\n\n        // Move action\n        if (!intent && (directionX || directionY)) {\n          intent = {\n            name: 'move',\n            directionX: directionX,\n            directionY: directionY\n          };\n        }\n        hero.intent = intent;\n      }\n    }\n  }, {\n    key: \"paint\",\n    value: function paint() {\n      var layer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      if (layer === _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.LAYERS.OVERLAY) {\n        this.paintPointerInput();\n      }\n    }\n\n    /*\r\n    Draw pointer input, if any. This helps players get visual feedback on their\r\n    touchscreens.\r\n     */\n  }, {\n    key: \"paintPointerInput\",\n    value: function paintPointerInput() {\n      var c2d = this._app.canvas2d;\n      var _this$_app$playerInpu = this._app.playerInput,\n        pointerCurrent = _this$_app$playerInpu.pointerCurrent,\n        pointerStart = _this$_app$playerInpu.pointerStart,\n        pointerState = _this$_app$playerInpu.pointerState;\n      var START_POINT_RADIUS = _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.TILE_SIZE * 1,\n        CURRENT_POINT_RADIUS = _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.TILE_SIZE * 0.5;\n      if (pointerState === _avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.POINTER_STATES.POINTER_DOWN) {\n        c2d.lineWidth = Math.floor(Math.min(_avo_constants_js__WEBPACK_IMPORTED_MODULE_2__.TILE_SIZE * 0.125, 2));\n        c2d.fillStyle = '#80808080';\n        c2d.strokeStyle = '#80808080';\n        c2d.beginPath();\n        c2d.arc(pointerStart.x, pointerStart.y, START_POINT_RADIUS, 0, 2 * Math.PI);\n        c2d.stroke();\n        c2d.beginPath();\n        c2d.arc(pointerCurrent.x, pointerCurrent.y, CURRENT_POINT_RADIUS, 0, 2 * Math.PI);\n        c2d.fill();\n        c2d.beginPath();\n        c2d.moveTo(pointerStart.x, pointerStart.y);\n        c2d.lineTo(pointerCurrent.x, pointerCurrent.y);\n        c2d.stroke();\n      }\n    }\n  }, {\n    key: \"onPointerTap\",\n    value: function onPointerTap() {\n      this.inputTap = true;\n    }\n  }, {\n    key: \"onKeyDown\",\n    value: function onKeyDown(_ref) {\n      var key = _ref.key;\n    }\n  }, {\n    key: \"onKeyUp\",\n    value: function onKeyUp(_ref2) {\n      var key = _ref2.key;\n    }\n  }]);\n}(_avo_rule__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n\n//# sourceURL=webpack://cny2026/./src/cny2026/rules/player-controls.js?");

/***/ }),

/***/ "./src/cny2026/rules/sound-manager.js":
/*!********************************************!*\
  !*** ./src/cny2026/rules/sound-manager.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SoundManager)\n/* harmony export */ });\n/* harmony import */ var _avo_rule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/rule */ \"./src/avo/rule/index.js\");\n/* harmony import */ var howler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! howler */ \"./node_modules/howler/dist/howler.js\");\n/* harmony import */ var howler__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(howler__WEBPACK_IMPORTED_MODULE_1__);\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n/*\r\nSound Manager Manager\r\nPlays sounds.\r\n */\n\n\n\nvar MUSIC_STATES = {\n  INIT: 'init',\n  STARTING_MUSIC: 'starting-music',\n  ESCALATION_MUSIC: 'escalation-music',\n  FINISHING_MUSIC: 'finishing-music'\n};\nvar MAX_VOL = 0.5;\nvar CNY2026_HIGHSCORE_MUTED_KEY = 'cny2026.muted';\nfunction getMutedValueFromStorage() {\n  var _window;\n  var storage = (_window = window) === null || _window === void 0 ? void 0 : _window.localStorage;\n  if (!storage) return;\n  try {\n    var mutedValue = storage.getItem(CNY2026_HIGHSCORE_MUTED_KEY);\n    return mutedValue === 'true';\n  } catch (err) {}\n  return false;\n}\nfunction setMutedValueToStorage(value) {\n  var _window2;\n  var storage = (_window2 = window) === null || _window2 === void 0 ? void 0 : _window2.localStorage;\n  if (!storage) return;\n  try {\n    var mutedValue = storage.setItem(CNY2026_HIGHSCORE_MUTED_KEY, !!value ? 'true' : 'false');\n  } catch (err) {}\n}\nvar SoundManager = /*#__PURE__*/function (_Rule) {\n  function SoundManager(app) {\n    var _this;\n    _classCallCheck(this, SoundManager);\n    _this = _callSuper(this, SoundManager, [app]);\n    _this._type = 'sound-manager';\n    _this.muted = getMutedValueFromStorage();\n    _this.musicVolume = MAX_VOL;\n    _this.musicState = MUSIC_STATES.INIT;\n    _this.pickUpSound = new howler__WEBPACK_IMPORTED_MODULE_1__.Howl({\n      src: ['assets/sound-pick-up.wav']\n    });\n    _this.dropOffSound = new howler__WEBPACK_IMPORTED_MODULE_1__.Howl({\n      src: ['assets/sound-drop-off.wav']\n    });\n    _this.destinationReachedSound = new howler__WEBPACK_IMPORTED_MODULE_1__.Howl({\n      src: ['assets/sound-destination-reached.wav']\n    });\n    _this.gongxi40bpmMusic = new howler__WEBPACK_IMPORTED_MODULE_1__.Howl({\n      src: ['assets/gongxigongxi-v2-40bpm.mp3'],\n      loop: true,\n      sprite: {\n        loopingBody: [0, 18000]\n      }\n    });\n    _this.williamTellOvertureMusic = new howler__WEBPACK_IMPORTED_MODULE_1__.Howl({\n      src: ['assets/william-tell-overture-finale.mp3'],\n      sprite: {\n        escalation: [0, 52000, true],\n        finishing: [52000, 62000, false]\n      }\n    });\n    _this.toggleSound = _this.toggleSound.bind(_this);\n    document.getElementById('button-sound').addEventListener('click', _this.toggleSound);\n    document.getElementById('button-sound').dataset.muted = _this.muted ? 'true' : 'false';\n    _this.startingMusicId = undefined;\n    _this.escalationMusicId = undefined;\n    _this.finishingMusicId = undefined;\n    _this.updateSoundState();\n    return _this;\n  }\n  _inherits(SoundManager, _Rule);\n  return _createClass(SoundManager, [{\n    key: \"deconstructor\",\n    value: function deconstructor() {\n      this.gongxi40bpmMusic.stop();\n      this.williamTellOvertureMusic.stop();\n    }\n  }, {\n    key: \"playPickUp\",\n    value: function playPickUp() {\n      if (this.muted) return;\n      this.pickUpSound.play();\n    }\n  }, {\n    key: \"playDropOff\",\n    value: function playDropOff() {\n      if (this.muted) return;\n      // this.dropOffSound.play()\n    }\n  }, {\n    key: \"playDestinationReached\",\n    value: function playDestinationReached() {\n      if (this.muted) return;\n      // this.dropOffSound.stop()\n      this.destinationReachedSound.play();\n    }\n  }, {\n    key: \"playStartingMusic\",\n    value: function playStartingMusic() {\n      if (this.musicState === MUSIC_STATES.INIT) {\n        this.startingMusicId = this.gongxi40bpmMusic.play('loopingBody');\n        this.gongxi40bpmMusic.fade(0, this.musicVolume, 1000, this.startingMusicId);\n        this.musicState = MUSIC_STATES.STARTING_MUSIC;\n      }\n    }\n  }, {\n    key: \"playEscalationMusic\",\n    value: function playEscalationMusic() {\n      if (this.musicState === MUSIC_STATES.STARTING_MUSIC) {\n        this.gongxi40bpmMusic.fade(this.musicVolume, 0, 2000);\n        this.escalationMusicId = this.williamTellOvertureMusic.play('escalation');\n        this.williamTellOvertureMusic.fade(0, this.musicVolume, 2000, this.escalationMusicId);\n        this.musicState = MUSIC_STATES.ESCALATION_MUSIC;\n      }\n    }\n  }, {\n    key: \"playFinishingMusic\",\n    value: function playFinishingMusic() {\n      if (this.musicState === MUSIC_STATES.ESCALATION_MUSIC) {\n        this.williamTellOvertureMusic.fade(this.musicVolume, 0, 1000, this.escalationMusicId);\n        this.finishingMusicId = this.williamTellOvertureMusic.play('finishing');\n        this.williamTellOvertureMusic.fade(0, this.musicVolume, 1000, this.finishingMusicId);\n        this.musicState = MUSIC_STATES.FINISHING_MUSIC;\n      } else {\n        this.fadeOutMusic();\n      }\n    }\n  }, {\n    key: \"fadeInMusic\",\n    value: function fadeInMusic() {\n      switch (this.musicState) {\n        case MUSIC_STATES.STARTING_MUSIC:\n          this.gongxi40bpmMusic.fade(0, this.musicVolume, 1000);\n          break;\n        case MUSIC_STATES.ESCALATION_MUSIC:\n        case MUSIC_STATES.FINISHING_MUSIC:\n          this.williamTellOvertureMusic.fade(0, this.musicVolume, 1000);\n          break;\n      }\n    }\n  }, {\n    key: \"fadeOutMusic\",\n    value: function fadeOutMusic() {\n      var currentVolume = this.gongxi40bpmMusic.volume() || 0;\n      this.gongxi40bpmMusic.fade(currentVolume, 0, 1000);\n      currentVolume = this.williamTellOvertureMusic.volume(undefined, this.escalationMusicId) || 0;\n      this.williamTellOvertureMusic.fade(currentVolume, 0, 1000, this.escalationMusicId);\n      currentVolume = this.williamTellOvertureMusic.volume(undefined, this.finishingMusicId) || 0;\n      this.williamTellOvertureMusic.fade(currentVolume, 0, 1000, this.finishingMusicId);\n    }\n  }, {\n    key: \"toggleSound\",\n    value: function toggleSound() {\n      this.muted = !this.muted;\n      setMutedValueToStorage(this.muted);\n      this.updateSoundState();\n    }\n  }, {\n    key: \"updateSoundState\",\n    value: function updateSoundState() {\n      document.getElementById('button-sound').dataset.muted = this.muted ? 'true' : 'false';\n      if (this.muted) {\n        this.musicVolume = 0;\n        this.fadeOutMusic();\n      } else {\n        this.musicVolume = MAX_VOL;\n        this.fadeInMusic();\n      }\n    }\n  }]);\n}(_avo_rule__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n\n//# sourceURL=webpack://cny2026/./src/cny2026/rules/sound-manager.js?");

/***/ }),

/***/ "./src/cny2026/tiles/floor-tile.js":
/*!*****************************************!*\
  !*** ./src/cny2026/tiles/floor-tile.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ FloorTile)\n/* harmony export */ });\n/* harmony import */ var _avo_tile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/tile */ \"./src/avo/tile/index.js\");\n/* harmony import */ var _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @avo/constants.js */ \"./src/avo/constants.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n\n\nvar FloorTile = /*#__PURE__*/function (_Tile) {\n  function FloorTile(app) {\n    var _this;\n    var col = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var row = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    _classCallCheck(this, FloorTile);\n    _this = _callSuper(this, FloorTile, [app, col, row]);\n    _this._type = 'floor-tile';\n    _this.colour = '#f0f0f0';\n    _this.solid = false;\n    _this.spriteSheet = app.assets['map'].img;\n    _this.floorSpriteCol = 0;\n    _this.floorSpriteRow = 6;\n    return _this;\n  }\n  _inherits(FloorTile, _Tile);\n  return _createClass(FloorTile, [{\n    key: \"paint\",\n    value: function paint() {\n      var layer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      if (layer === _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.LAYERS.BOTTOM) {\n        this.paintSprite({\n          spriteCol: this.floorSpriteCol,\n          spriteRow: this.floorSpriteRow\n        });\n      }\n    }\n  }]);\n}(_avo_tile__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n\n//# sourceURL=webpack://cny2026/./src/cny2026/tiles/floor-tile.js?");

/***/ }),

/***/ "./src/cny2026/tiles/street-tile.js":
/*!******************************************!*\
  !*** ./src/cny2026/tiles/street-tile.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ StreetTile)\n/* harmony export */ });\n/* harmony import */ var _avo_tile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/tile */ \"./src/avo/tile/index.js\");\n/* harmony import */ var _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @avo/constants.js */ \"./src/avo/constants.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n\n\nvar StreetTile = /*#__PURE__*/function (_Tile) {\n  function StreetTile(app) {\n    var _this;\n    var col = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var row = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    _classCallCheck(this, StreetTile);\n    _this = _callSuper(this, StreetTile, [app, col, row]);\n    _this._type = 'street-tile';\n    _this.colour = '#f0f0f0';\n    _this.solid = false;\n    _this.spriteSheet = app.assets['map'].img;\n    _this.floorSpriteCol = 5;\n    _this.floorSpriteRow = 6;\n    return _this;\n  }\n  _inherits(StreetTile, _Tile);\n  return _createClass(StreetTile, [{\n    key: \"paint\",\n    value: function paint() {\n      var layer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      if (layer === _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.LAYERS.BOTTOM) {\n        this.paintSprite({\n          spriteCol: this.floorSpriteCol,\n          spriteRow: this.floorSpriteRow\n        });\n      }\n    }\n  }]);\n}(_avo_tile__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n\n//# sourceURL=webpack://cny2026/./src/cny2026/tiles/street-tile.js?");

/***/ }),

/***/ "./src/cny2026/tiles/wall-tile.js":
/*!****************************************!*\
  !*** ./src/cny2026/tiles/wall-tile.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ WallTile)\n/* harmony export */ });\n/* harmony import */ var _avo_tile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo/tile */ \"./src/avo/tile/index.js\");\n/* harmony import */ var _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @avo/constants.js */ \"./src/avo/constants.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n\n\nvar WallTile = /*#__PURE__*/function (_Tile) {\n  function WallTile(app) {\n    var _this;\n    var col = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var row = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    _classCallCheck(this, WallTile);\n    _this = _callSuper(this, WallTile, [app, col, row]);\n    _this._type = 'wall-tile';\n    _this.colour = '#808080';\n    _this.solid = true;\n    _this.spriteSheet = app.assets['map'].img;\n    _this.ceilingSpriteCol = 0;\n    _this.ceilingSpriteRow = 0;\n    _this.wallSpriteCol = 0;\n    _this.wallSpriteRow = 4;\n    return _this;\n  }\n  _inherits(WallTile, _Tile);\n  return _createClass(WallTile, [{\n    key: \"paint\",\n    value: function paint() {\n      var layer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      if (layer === _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.LAYERS.BOTTOM) {\n        this.paintSprite({\n          spriteRow: this.wallSpriteRow,\n          spriteCol: this.wallSpriteCol\n        });\n      } else if (layer === _avo_constants_js__WEBPACK_IMPORTED_MODULE_1__.LAYERS.TOP) {\n        this.paintSprite({\n          spriteRow: this.ceilingSpriteRow,\n          spriteCol: this.ceilingSpriteCol,\n          spriteOffsetY: -24\n        });\n      }\n    }\n  }]);\n}(_avo_tile__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n\n//# sourceURL=webpack://cny2026/./src/cny2026/tiles/wall-tile.js?");

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _avo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @avo */ \"./src/avo/index.js\");\n/* harmony import */ var _cny2026__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cny2026 */ \"./src/cny2026/index.js\");\n\n\nwindow.onload = function init() {\n  window.avo = new _avo__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n    story: _cny2026__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n    width: 40 * 32,\n    height: 20 * 32\n  });\n};\n\n//# sourceURL=webpack://cny2026/./src/main.js?");

/***/ }),

/***/ "./node_modules/howler/dist/howler.js":
/*!********************************************!*\
  !*** ./node_modules/howler/dist/howler.js ***!
  \********************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n *  howler.js v2.2.4\n *  howlerjs.com\n *\n *  (c) 2013-2020, James Simpson of GoldFire Studios\n *  goldfirestudios.com\n *\n *  MIT License\n */\n\n(function() {\n\n  'use strict';\n\n  /** Global Methods **/\n  /***************************************************************************/\n\n  /**\n   * Create the global controller. All contained methods and properties apply\n   * to all sounds that are currently playing or will be in the future.\n   */\n  var HowlerGlobal = function() {\n    this.init();\n  };\n  HowlerGlobal.prototype = {\n    /**\n     * Initialize the global Howler object.\n     * @return {Howler}\n     */\n    init: function() {\n      var self = this || Howler;\n\n      // Create a global ID counter.\n      self._counter = 1000;\n\n      // Pool of unlocked HTML5 Audio objects.\n      self._html5AudioPool = [];\n      self.html5PoolSize = 10;\n\n      // Internal properties.\n      self._codecs = {};\n      self._howls = [];\n      self._muted = false;\n      self._volume = 1;\n      self._canPlayEvent = 'canplaythrough';\n      self._navigator = (typeof window !== 'undefined' && window.navigator) ? window.navigator : null;\n\n      // Public properties.\n      self.masterGain = null;\n      self.noAudio = false;\n      self.usingWebAudio = true;\n      self.autoSuspend = true;\n      self.ctx = null;\n\n      // Set to false to disable the auto audio unlocker.\n      self.autoUnlock = true;\n\n      // Setup the various state values for global tracking.\n      self._setup();\n\n      return self;\n    },\n\n    /**\n     * Get/set the global volume for all sounds.\n     * @param  {Float} vol Volume from 0.0 to 1.0.\n     * @return {Howler/Float}     Returns self or current volume.\n     */\n    volume: function(vol) {\n      var self = this || Howler;\n      vol = parseFloat(vol);\n\n      // If we don't have an AudioContext created yet, run the setup.\n      if (!self.ctx) {\n        setupAudioContext();\n      }\n\n      if (typeof vol !== 'undefined' && vol >= 0 && vol <= 1) {\n        self._volume = vol;\n\n        // Don't update any of the nodes if we are muted.\n        if (self._muted) {\n          return self;\n        }\n\n        // When using Web Audio, we just need to adjust the master gain.\n        if (self.usingWebAudio) {\n          self.masterGain.gain.setValueAtTime(vol, Howler.ctx.currentTime);\n        }\n\n        // Loop through and change volume for all HTML5 audio nodes.\n        for (var i=0; i<self._howls.length; i++) {\n          if (!self._howls[i]._webAudio) {\n            // Get all of the sounds in this Howl group.\n            var ids = self._howls[i]._getSoundIds();\n\n            // Loop through all sounds and change the volumes.\n            for (var j=0; j<ids.length; j++) {\n              var sound = self._howls[i]._soundById(ids[j]);\n\n              if (sound && sound._node) {\n                sound._node.volume = sound._volume * vol;\n              }\n            }\n          }\n        }\n\n        return self;\n      }\n\n      return self._volume;\n    },\n\n    /**\n     * Handle muting and unmuting globally.\n     * @param  {Boolean} muted Is muted or not.\n     */\n    mute: function(muted) {\n      var self = this || Howler;\n\n      // If we don't have an AudioContext created yet, run the setup.\n      if (!self.ctx) {\n        setupAudioContext();\n      }\n\n      self._muted = muted;\n\n      // With Web Audio, we just need to mute the master gain.\n      if (self.usingWebAudio) {\n        self.masterGain.gain.setValueAtTime(muted ? 0 : self._volume, Howler.ctx.currentTime);\n      }\n\n      // Loop through and mute all HTML5 Audio nodes.\n      for (var i=0; i<self._howls.length; i++) {\n        if (!self._howls[i]._webAudio) {\n          // Get all of the sounds in this Howl group.\n          var ids = self._howls[i]._getSoundIds();\n\n          // Loop through all sounds and mark the audio node as muted.\n          for (var j=0; j<ids.length; j++) {\n            var sound = self._howls[i]._soundById(ids[j]);\n\n            if (sound && sound._node) {\n              sound._node.muted = (muted) ? true : sound._muted;\n            }\n          }\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Handle stopping all sounds globally.\n     */\n    stop: function() {\n      var self = this || Howler;\n\n      // Loop through all Howls and stop them.\n      for (var i=0; i<self._howls.length; i++) {\n        self._howls[i].stop();\n      }\n\n      return self;\n    },\n\n    /**\n     * Unload and destroy all currently loaded Howl objects.\n     * @return {Howler}\n     */\n    unload: function() {\n      var self = this || Howler;\n\n      for (var i=self._howls.length-1; i>=0; i--) {\n        self._howls[i].unload();\n      }\n\n      // Create a new AudioContext to make sure it is fully reset.\n      if (self.usingWebAudio && self.ctx && typeof self.ctx.close !== 'undefined') {\n        self.ctx.close();\n        self.ctx = null;\n        setupAudioContext();\n      }\n\n      return self;\n    },\n\n    /**\n     * Check for codec support of specific extension.\n     * @param  {String} ext Audio file extention.\n     * @return {Boolean}\n     */\n    codecs: function(ext) {\n      return (this || Howler)._codecs[ext.replace(/^x-/, '')];\n    },\n\n    /**\n     * Setup various state values for global tracking.\n     * @return {Howler}\n     */\n    _setup: function() {\n      var self = this || Howler;\n\n      // Keeps track of the suspend/resume state of the AudioContext.\n      self.state = self.ctx ? self.ctx.state || 'suspended' : 'suspended';\n\n      // Automatically begin the 30-second suspend process\n      self._autoSuspend();\n\n      // Check if audio is available.\n      if (!self.usingWebAudio) {\n        // No audio is available on this system if noAudio is set to true.\n        if (typeof Audio !== 'undefined') {\n          try {\n            var test = new Audio();\n\n            // Check if the canplaythrough event is available.\n            if (typeof test.oncanplaythrough === 'undefined') {\n              self._canPlayEvent = 'canplay';\n            }\n          } catch(e) {\n            self.noAudio = true;\n          }\n        } else {\n          self.noAudio = true;\n        }\n      }\n\n      // Test to make sure audio isn't disabled in Internet Explorer.\n      try {\n        var test = new Audio();\n        if (test.muted) {\n          self.noAudio = true;\n        }\n      } catch (e) {}\n\n      // Check for supported codecs.\n      if (!self.noAudio) {\n        self._setupCodecs();\n      }\n\n      return self;\n    },\n\n    /**\n     * Check for browser support for various codecs and cache the results.\n     * @return {Howler}\n     */\n    _setupCodecs: function() {\n      var self = this || Howler;\n      var audioTest = null;\n\n      // Must wrap in a try/catch because IE11 in server mode throws an error.\n      try {\n        audioTest = (typeof Audio !== 'undefined') ? new Audio() : null;\n      } catch (err) {\n        return self;\n      }\n\n      if (!audioTest || typeof audioTest.canPlayType !== 'function') {\n        return self;\n      }\n\n      var mpegTest = audioTest.canPlayType('audio/mpeg;').replace(/^no$/, '');\n\n      // Opera version <33 has mixed MP3 support, so we need to check for and block it.\n      var ua = self._navigator ? self._navigator.userAgent : '';\n      var checkOpera = ua.match(/OPR\\/(\\d+)/g);\n      var isOldOpera = (checkOpera && parseInt(checkOpera[0].split('/')[1], 10) < 33);\n      var checkSafari = ua.indexOf('Safari') !== -1 && ua.indexOf('Chrome') === -1;\n      var safariVersion = ua.match(/Version\\/(.*?) /);\n      var isOldSafari = (checkSafari && safariVersion && parseInt(safariVersion[1], 10) < 15);\n\n      self._codecs = {\n        mp3: !!(!isOldOpera && (mpegTest || audioTest.canPlayType('audio/mp3;').replace(/^no$/, ''))),\n        mpeg: !!mpegTest,\n        opus: !!audioTest.canPlayType('audio/ogg; codecs=\"opus\"').replace(/^no$/, ''),\n        ogg: !!audioTest.canPlayType('audio/ogg; codecs=\"vorbis\"').replace(/^no$/, ''),\n        oga: !!audioTest.canPlayType('audio/ogg; codecs=\"vorbis\"').replace(/^no$/, ''),\n        wav: !!(audioTest.canPlayType('audio/wav; codecs=\"1\"') || audioTest.canPlayType('audio/wav')).replace(/^no$/, ''),\n        aac: !!audioTest.canPlayType('audio/aac;').replace(/^no$/, ''),\n        caf: !!audioTest.canPlayType('audio/x-caf;').replace(/^no$/, ''),\n        m4a: !!(audioTest.canPlayType('audio/x-m4a;') || audioTest.canPlayType('audio/m4a;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),\n        m4b: !!(audioTest.canPlayType('audio/x-m4b;') || audioTest.canPlayType('audio/m4b;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),\n        mp4: !!(audioTest.canPlayType('audio/x-mp4;') || audioTest.canPlayType('audio/mp4;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),\n        weba: !!(!isOldSafari && audioTest.canPlayType('audio/webm; codecs=\"vorbis\"').replace(/^no$/, '')),\n        webm: !!(!isOldSafari && audioTest.canPlayType('audio/webm; codecs=\"vorbis\"').replace(/^no$/, '')),\n        dolby: !!audioTest.canPlayType('audio/mp4; codecs=\"ec-3\"').replace(/^no$/, ''),\n        flac: !!(audioTest.canPlayType('audio/x-flac;') || audioTest.canPlayType('audio/flac;')).replace(/^no$/, '')\n      };\n\n      return self;\n    },\n\n    /**\n     * Some browsers/devices will only allow audio to be played after a user interaction.\n     * Attempt to automatically unlock audio on the first user interaction.\n     * Concept from: http://paulbakaus.com/tutorials/html5/web-audio-on-ios/\n     * @return {Howler}\n     */\n    _unlockAudio: function() {\n      var self = this || Howler;\n\n      // Only run this if Web Audio is supported and it hasn't already been unlocked.\n      if (self._audioUnlocked || !self.ctx) {\n        return;\n      }\n\n      self._audioUnlocked = false;\n      self.autoUnlock = false;\n\n      // Some mobile devices/platforms have distortion issues when opening/closing tabs and/or web views.\n      // Bugs in the browser (especially Mobile Safari) can cause the sampleRate to change from 44100 to 48000.\n      // By calling Howler.unload(), we create a new AudioContext with the correct sampleRate.\n      if (!self._mobileUnloaded && self.ctx.sampleRate !== 44100) {\n        self._mobileUnloaded = true;\n        self.unload();\n      }\n\n      // Scratch buffer for enabling iOS to dispose of web audio buffers correctly, as per:\n      // http://stackoverflow.com/questions/24119684\n      self._scratchBuffer = self.ctx.createBuffer(1, 1, 22050);\n\n      // Call this method on touch start to create and play a buffer,\n      // then check if the audio actually played to determine if\n      // audio has now been unlocked on iOS, Android, etc.\n      var unlock = function(e) {\n        // Create a pool of unlocked HTML5 Audio objects that can\n        // be used for playing sounds without user interaction. HTML5\n        // Audio objects must be individually unlocked, as opposed\n        // to the WebAudio API which only needs a single activation.\n        // This must occur before WebAudio setup or the source.onended\n        // event will not fire.\n        while (self._html5AudioPool.length < self.html5PoolSize) {\n          try {\n            var audioNode = new Audio();\n\n            // Mark this Audio object as unlocked to ensure it can get returned\n            // to the unlocked pool when released.\n            audioNode._unlocked = true;\n\n            // Add the audio node to the pool.\n            self._releaseHtml5Audio(audioNode);\n          } catch (e) {\n            self.noAudio = true;\n            break;\n          }\n        }\n\n        // Loop through any assigned audio nodes and unlock them.\n        for (var i=0; i<self._howls.length; i++) {\n          if (!self._howls[i]._webAudio) {\n            // Get all of the sounds in this Howl group.\n            var ids = self._howls[i]._getSoundIds();\n\n            // Loop through all sounds and unlock the audio nodes.\n            for (var j=0; j<ids.length; j++) {\n              var sound = self._howls[i]._soundById(ids[j]);\n\n              if (sound && sound._node && !sound._node._unlocked) {\n                sound._node._unlocked = true;\n                sound._node.load();\n              }\n            }\n          }\n        }\n\n        // Fix Android can not play in suspend state.\n        self._autoResume();\n\n        // Create an empty buffer.\n        var source = self.ctx.createBufferSource();\n        source.buffer = self._scratchBuffer;\n        source.connect(self.ctx.destination);\n\n        // Play the empty buffer.\n        if (typeof source.start === 'undefined') {\n          source.noteOn(0);\n        } else {\n          source.start(0);\n        }\n\n        // Calling resume() on a stack initiated by user gesture is what actually unlocks the audio on Android Chrome >= 55.\n        if (typeof self.ctx.resume === 'function') {\n          self.ctx.resume();\n        }\n\n        // Setup a timeout to check that we are unlocked on the next event loop.\n        source.onended = function() {\n          source.disconnect(0);\n\n          // Update the unlocked state and prevent this check from happening again.\n          self._audioUnlocked = true;\n\n          // Remove the touch start listener.\n          document.removeEventListener('touchstart', unlock, true);\n          document.removeEventListener('touchend', unlock, true);\n          document.removeEventListener('click', unlock, true);\n          document.removeEventListener('keydown', unlock, true);\n\n          // Let all sounds know that audio has been unlocked.\n          for (var i=0; i<self._howls.length; i++) {\n            self._howls[i]._emit('unlock');\n          }\n        };\n      };\n\n      // Setup a touch start listener to attempt an unlock in.\n      document.addEventListener('touchstart', unlock, true);\n      document.addEventListener('touchend', unlock, true);\n      document.addEventListener('click', unlock, true);\n      document.addEventListener('keydown', unlock, true);\n\n      return self;\n    },\n\n    /**\n     * Get an unlocked HTML5 Audio object from the pool. If none are left,\n     * return a new Audio object and throw a warning.\n     * @return {Audio} HTML5 Audio object.\n     */\n    _obtainHtml5Audio: function() {\n      var self = this || Howler;\n\n      // Return the next object from the pool if one exists.\n      if (self._html5AudioPool.length) {\n        return self._html5AudioPool.pop();\n      }\n\n      //.Check if the audio is locked and throw a warning.\n      var testPlay = new Audio().play();\n      if (testPlay && typeof Promise !== 'undefined' && (testPlay instanceof Promise || typeof testPlay.then === 'function')) {\n        testPlay.catch(function() {\n          console.warn('HTML5 Audio pool exhausted, returning potentially locked audio object.');\n        });\n      }\n\n      return new Audio();\n    },\n\n    /**\n     * Return an activated HTML5 Audio object to the pool.\n     * @return {Howler}\n     */\n    _releaseHtml5Audio: function(audio) {\n      var self = this || Howler;\n\n      // Don't add audio to the pool if we don't know if it has been unlocked.\n      if (audio._unlocked) {\n        self._html5AudioPool.push(audio);\n      }\n\n      return self;\n    },\n\n    /**\n     * Automatically suspend the Web Audio AudioContext after no sound has played for 30 seconds.\n     * This saves processing/energy and fixes various browser-specific bugs with audio getting stuck.\n     * @return {Howler}\n     */\n    _autoSuspend: function() {\n      var self = this;\n\n      if (!self.autoSuspend || !self.ctx || typeof self.ctx.suspend === 'undefined' || !Howler.usingWebAudio) {\n        return;\n      }\n\n      // Check if any sounds are playing.\n      for (var i=0; i<self._howls.length; i++) {\n        if (self._howls[i]._webAudio) {\n          for (var j=0; j<self._howls[i]._sounds.length; j++) {\n            if (!self._howls[i]._sounds[j]._paused) {\n              return self;\n            }\n          }\n        }\n      }\n\n      if (self._suspendTimer) {\n        clearTimeout(self._suspendTimer);\n      }\n\n      // If no sound has played after 30 seconds, suspend the context.\n      self._suspendTimer = setTimeout(function() {\n        if (!self.autoSuspend) {\n          return;\n        }\n\n        self._suspendTimer = null;\n        self.state = 'suspending';\n\n        // Handle updating the state of the audio context after suspending.\n        var handleSuspension = function() {\n          self.state = 'suspended';\n\n          if (self._resumeAfterSuspend) {\n            delete self._resumeAfterSuspend;\n            self._autoResume();\n          }\n        };\n\n        // Either the state gets suspended or it is interrupted.\n        // Either way, we need to update the state to suspended.\n        self.ctx.suspend().then(handleSuspension, handleSuspension);\n      }, 30000);\n\n      return self;\n    },\n\n    /**\n     * Automatically resume the Web Audio AudioContext when a new sound is played.\n     * @return {Howler}\n     */\n    _autoResume: function() {\n      var self = this;\n\n      if (!self.ctx || typeof self.ctx.resume === 'undefined' || !Howler.usingWebAudio) {\n        return;\n      }\n\n      if (self.state === 'running' && self.ctx.state !== 'interrupted' && self._suspendTimer) {\n        clearTimeout(self._suspendTimer);\n        self._suspendTimer = null;\n      } else if (self.state === 'suspended' || self.state === 'running' && self.ctx.state === 'interrupted') {\n        self.ctx.resume().then(function() {\n          self.state = 'running';\n\n          // Emit to all Howls that the audio has resumed.\n          for (var i=0; i<self._howls.length; i++) {\n            self._howls[i]._emit('resume');\n          }\n        });\n\n        if (self._suspendTimer) {\n          clearTimeout(self._suspendTimer);\n          self._suspendTimer = null;\n        }\n      } else if (self.state === 'suspending') {\n        self._resumeAfterSuspend = true;\n      }\n\n      return self;\n    }\n  };\n\n  // Setup the global audio controller.\n  var Howler = new HowlerGlobal();\n\n  /** Group Methods **/\n  /***************************************************************************/\n\n  /**\n   * Create an audio group controller.\n   * @param {Object} o Passed in properties for this group.\n   */\n  var Howl = function(o) {\n    var self = this;\n\n    // Throw an error if no source is provided.\n    if (!o.src || o.src.length === 0) {\n      console.error('An array of source files must be passed with any new Howl.');\n      return;\n    }\n\n    self.init(o);\n  };\n  Howl.prototype = {\n    /**\n     * Initialize a new Howl group object.\n     * @param  {Object} o Passed in properties for this group.\n     * @return {Howl}\n     */\n    init: function(o) {\n      var self = this;\n\n      // If we don't have an AudioContext created yet, run the setup.\n      if (!Howler.ctx) {\n        setupAudioContext();\n      }\n\n      // Setup user-defined default properties.\n      self._autoplay = o.autoplay || false;\n      self._format = (typeof o.format !== 'string') ? o.format : [o.format];\n      self._html5 = o.html5 || false;\n      self._muted = o.mute || false;\n      self._loop = o.loop || false;\n      self._pool = o.pool || 5;\n      self._preload = (typeof o.preload === 'boolean' || o.preload === 'metadata') ? o.preload : true;\n      self._rate = o.rate || 1;\n      self._sprite = o.sprite || {};\n      self._src = (typeof o.src !== 'string') ? o.src : [o.src];\n      self._volume = o.volume !== undefined ? o.volume : 1;\n      self._xhr = {\n        method: o.xhr && o.xhr.method ? o.xhr.method : 'GET',\n        headers: o.xhr && o.xhr.headers ? o.xhr.headers : null,\n        withCredentials: o.xhr && o.xhr.withCredentials ? o.xhr.withCredentials : false,\n      };\n\n      // Setup all other default properties.\n      self._duration = 0;\n      self._state = 'unloaded';\n      self._sounds = [];\n      self._endTimers = {};\n      self._queue = [];\n      self._playLock = false;\n\n      // Setup event listeners.\n      self._onend = o.onend ? [{fn: o.onend}] : [];\n      self._onfade = o.onfade ? [{fn: o.onfade}] : [];\n      self._onload = o.onload ? [{fn: o.onload}] : [];\n      self._onloaderror = o.onloaderror ? [{fn: o.onloaderror}] : [];\n      self._onplayerror = o.onplayerror ? [{fn: o.onplayerror}] : [];\n      self._onpause = o.onpause ? [{fn: o.onpause}] : [];\n      self._onplay = o.onplay ? [{fn: o.onplay}] : [];\n      self._onstop = o.onstop ? [{fn: o.onstop}] : [];\n      self._onmute = o.onmute ? [{fn: o.onmute}] : [];\n      self._onvolume = o.onvolume ? [{fn: o.onvolume}] : [];\n      self._onrate = o.onrate ? [{fn: o.onrate}] : [];\n      self._onseek = o.onseek ? [{fn: o.onseek}] : [];\n      self._onunlock = o.onunlock ? [{fn: o.onunlock}] : [];\n      self._onresume = [];\n\n      // Web Audio or HTML5 Audio?\n      self._webAudio = Howler.usingWebAudio && !self._html5;\n\n      // Automatically try to enable audio.\n      if (typeof Howler.ctx !== 'undefined' && Howler.ctx && Howler.autoUnlock) {\n        Howler._unlockAudio();\n      }\n\n      // Keep track of this Howl group in the global controller.\n      Howler._howls.push(self);\n\n      // If they selected autoplay, add a play event to the load queue.\n      if (self._autoplay) {\n        self._queue.push({\n          event: 'play',\n          action: function() {\n            self.play();\n          }\n        });\n      }\n\n      // Load the source file unless otherwise specified.\n      if (self._preload && self._preload !== 'none') {\n        self.load();\n      }\n\n      return self;\n    },\n\n    /**\n     * Load the audio file.\n     * @return {Howler}\n     */\n    load: function() {\n      var self = this;\n      var url = null;\n\n      // If no audio is available, quit immediately.\n      if (Howler.noAudio) {\n        self._emit('loaderror', null, 'No audio support.');\n        return;\n      }\n\n      // Make sure our source is in an array.\n      if (typeof self._src === 'string') {\n        self._src = [self._src];\n      }\n\n      // Loop through the sources and pick the first one that is compatible.\n      for (var i=0; i<self._src.length; i++) {\n        var ext, str;\n\n        if (self._format && self._format[i]) {\n          // If an extension was specified, use that instead.\n          ext = self._format[i];\n        } else {\n          // Make sure the source is a string.\n          str = self._src[i];\n          if (typeof str !== 'string') {\n            self._emit('loaderror', null, 'Non-string found in selected audio sources - ignoring.');\n            continue;\n          }\n\n          // Extract the file extension from the URL or base64 data URI.\n          ext = /^data:audio\\/([^;,]+);/i.exec(str);\n          if (!ext) {\n            ext = /\\.([^.]+)$/.exec(str.split('?', 1)[0]);\n          }\n\n          if (ext) {\n            ext = ext[1].toLowerCase();\n          }\n        }\n\n        // Log a warning if no extension was found.\n        if (!ext) {\n          console.warn('No file extension was found. Consider using the \"format\" property or specify an extension.');\n        }\n\n        // Check if this extension is available.\n        if (ext && Howler.codecs(ext)) {\n          url = self._src[i];\n          break;\n        }\n      }\n\n      if (!url) {\n        self._emit('loaderror', null, 'No codec support for selected audio sources.');\n        return;\n      }\n\n      self._src = url;\n      self._state = 'loading';\n\n      // If the hosting page is HTTPS and the source isn't,\n      // drop down to HTML5 Audio to avoid Mixed Content errors.\n      if (window.location.protocol === 'https:' && url.slice(0, 5) === 'http:') {\n        self._html5 = true;\n        self._webAudio = false;\n      }\n\n      // Create a new sound object and add it to the pool.\n      new Sound(self);\n\n      // Load and decode the audio data for playback.\n      if (self._webAudio) {\n        loadBuffer(self);\n      }\n\n      return self;\n    },\n\n    /**\n     * Play a sound or resume previous playback.\n     * @param  {String/Number} sprite   Sprite name for sprite playback or sound id to continue previous.\n     * @param  {Boolean} internal Internal Use: true prevents event firing.\n     * @return {Number}          Sound ID.\n     */\n    play: function(sprite, internal) {\n      var self = this;\n      var id = null;\n\n      // Determine if a sprite, sound id or nothing was passed\n      if (typeof sprite === 'number') {\n        id = sprite;\n        sprite = null;\n      } else if (typeof sprite === 'string' && self._state === 'loaded' && !self._sprite[sprite]) {\n        // If the passed sprite doesn't exist, do nothing.\n        return null;\n      } else if (typeof sprite === 'undefined') {\n        // Use the default sound sprite (plays the full audio length).\n        sprite = '__default';\n\n        // Check if there is a single paused sound that isn't ended.\n        // If there is, play that sound. If not, continue as usual.\n        if (!self._playLock) {\n          var num = 0;\n          for (var i=0; i<self._sounds.length; i++) {\n            if (self._sounds[i]._paused && !self._sounds[i]._ended) {\n              num++;\n              id = self._sounds[i]._id;\n            }\n          }\n\n          if (num === 1) {\n            sprite = null;\n          } else {\n            id = null;\n          }\n        }\n      }\n\n      // Get the selected node, or get one from the pool.\n      var sound = id ? self._soundById(id) : self._inactiveSound();\n\n      // If the sound doesn't exist, do nothing.\n      if (!sound) {\n        return null;\n      }\n\n      // Select the sprite definition.\n      if (id && !sprite) {\n        sprite = sound._sprite || '__default';\n      }\n\n      // If the sound hasn't loaded, we must wait to get the audio's duration.\n      // We also need to wait to make sure we don't run into race conditions with\n      // the order of function calls.\n      if (self._state !== 'loaded') {\n        // Set the sprite value on this sound.\n        sound._sprite = sprite;\n\n        // Mark this sound as not ended in case another sound is played before this one loads.\n        sound._ended = false;\n\n        // Add the sound to the queue to be played on load.\n        var soundId = sound._id;\n        self._queue.push({\n          event: 'play',\n          action: function() {\n            self.play(soundId);\n          }\n        });\n\n        return soundId;\n      }\n\n      // Don't play the sound if an id was passed and it is already playing.\n      if (id && !sound._paused) {\n        // Trigger the play event, in order to keep iterating through queue.\n        if (!internal) {\n          self._loadQueue('play');\n        }\n\n        return sound._id;\n      }\n\n      // Make sure the AudioContext isn't suspended, and resume it if it is.\n      if (self._webAudio) {\n        Howler._autoResume();\n      }\n\n      // Determine how long to play for and where to start playing.\n      var seek = Math.max(0, sound._seek > 0 ? sound._seek : self._sprite[sprite][0] / 1000);\n      var duration = Math.max(0, ((self._sprite[sprite][0] + self._sprite[sprite][1]) / 1000) - seek);\n      var timeout = (duration * 1000) / Math.abs(sound._rate);\n      var start = self._sprite[sprite][0] / 1000;\n      var stop = (self._sprite[sprite][0] + self._sprite[sprite][1]) / 1000;\n      sound._sprite = sprite;\n\n      // Mark the sound as ended instantly so that this async playback\n      // doesn't get grabbed by another call to play while this one waits to start.\n      sound._ended = false;\n\n      // Update the parameters of the sound.\n      var setParams = function() {\n        sound._paused = false;\n        sound._seek = seek;\n        sound._start = start;\n        sound._stop = stop;\n        sound._loop = !!(sound._loop || self._sprite[sprite][2]);\n      };\n\n      // End the sound instantly if seek is at the end.\n      if (seek >= stop) {\n        self._ended(sound);\n        return;\n      }\n\n      // Begin the actual playback.\n      var node = sound._node;\n      if (self._webAudio) {\n        // Fire this when the sound is ready to play to begin Web Audio playback.\n        var playWebAudio = function() {\n          self._playLock = false;\n          setParams();\n          self._refreshBuffer(sound);\n\n          // Setup the playback params.\n          var vol = (sound._muted || self._muted) ? 0 : sound._volume;\n          node.gain.setValueAtTime(vol, Howler.ctx.currentTime);\n          sound._playStart = Howler.ctx.currentTime;\n\n          // Play the sound using the supported method.\n          if (typeof node.bufferSource.start === 'undefined') {\n            sound._loop ? node.bufferSource.noteGrainOn(0, seek, 86400) : node.bufferSource.noteGrainOn(0, seek, duration);\n          } else {\n            sound._loop ? node.bufferSource.start(0, seek, 86400) : node.bufferSource.start(0, seek, duration);\n          }\n\n          // Start a new timer if none is present.\n          if (timeout !== Infinity) {\n            self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);\n          }\n\n          if (!internal) {\n            setTimeout(function() {\n              self._emit('play', sound._id);\n              self._loadQueue();\n            }, 0);\n          }\n        };\n\n        if (Howler.state === 'running' && Howler.ctx.state !== 'interrupted') {\n          playWebAudio();\n        } else {\n          self._playLock = true;\n\n          // Wait for the audio context to resume before playing.\n          self.once('resume', playWebAudio);\n\n          // Cancel the end timer.\n          self._clearTimer(sound._id);\n        }\n      } else {\n        // Fire this when the sound is ready to play to begin HTML5 Audio playback.\n        var playHtml5 = function() {\n          node.currentTime = seek;\n          node.muted = sound._muted || self._muted || Howler._muted || node.muted;\n          node.volume = sound._volume * Howler.volume();\n          node.playbackRate = sound._rate;\n\n          // Some browsers will throw an error if this is called without user interaction.\n          try {\n            var play = node.play();\n\n            // Support older browsers that don't support promises, and thus don't have this issue.\n            if (play && typeof Promise !== 'undefined' && (play instanceof Promise || typeof play.then === 'function')) {\n              // Implements a lock to prevent DOMException: The play() request was interrupted by a call to pause().\n              self._playLock = true;\n\n              // Set param values immediately.\n              setParams();\n\n              // Releases the lock and executes queued actions.\n              play\n                .then(function() {\n                  self._playLock = false;\n                  node._unlocked = true;\n                  if (!internal) {\n                    self._emit('play', sound._id);\n                  } else {\n                    self._loadQueue();\n                  }\n                })\n                .catch(function() {\n                  self._playLock = false;\n                  self._emit('playerror', sound._id, 'Playback was unable to start. This is most commonly an issue ' +\n                    'on mobile devices and Chrome where playback was not within a user interaction.');\n\n                  // Reset the ended and paused values.\n                  sound._ended = true;\n                  sound._paused = true;\n                });\n            } else if (!internal) {\n              self._playLock = false;\n              setParams();\n              self._emit('play', sound._id);\n            }\n\n            // Setting rate before playing won't work in IE, so we set it again here.\n            node.playbackRate = sound._rate;\n\n            // If the node is still paused, then we can assume there was a playback issue.\n            if (node.paused) {\n              self._emit('playerror', sound._id, 'Playback was unable to start. This is most commonly an issue ' +\n                'on mobile devices and Chrome where playback was not within a user interaction.');\n              return;\n            }\n\n            // Setup the end timer on sprites or listen for the ended event.\n            if (sprite !== '__default' || sound._loop) {\n              self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);\n            } else {\n              self._endTimers[sound._id] = function() {\n                // Fire ended on this audio node.\n                self._ended(sound);\n\n                // Clear this listener.\n                node.removeEventListener('ended', self._endTimers[sound._id], false);\n              };\n              node.addEventListener('ended', self._endTimers[sound._id], false);\n            }\n          } catch (err) {\n            self._emit('playerror', sound._id, err);\n          }\n        };\n\n        // If this is streaming audio, make sure the src is set and load again.\n        if (node.src === 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA') {\n          node.src = self._src;\n          node.load();\n        }\n\n        // Play immediately if ready, or wait for the 'canplaythrough'e vent.\n        var loadedNoReadyState = (window && window.ejecta) || (!node.readyState && Howler._navigator.isCocoonJS);\n        if (node.readyState >= 3 || loadedNoReadyState) {\n          playHtml5();\n        } else {\n          self._playLock = true;\n          self._state = 'loading';\n\n          var listener = function() {\n            self._state = 'loaded';\n            \n            // Begin playback.\n            playHtml5();\n\n            // Clear this listener.\n            node.removeEventListener(Howler._canPlayEvent, listener, false);\n          };\n          node.addEventListener(Howler._canPlayEvent, listener, false);\n\n          // Cancel the end timer.\n          self._clearTimer(sound._id);\n        }\n      }\n\n      return sound._id;\n    },\n\n    /**\n     * Pause playback and save current position.\n     * @param  {Number} id The sound ID (empty to pause all in group).\n     * @return {Howl}\n     */\n    pause: function(id) {\n      var self = this;\n\n      // If the sound hasn't loaded or a play() promise is pending, add it to the load queue to pause when capable.\n      if (self._state !== 'loaded' || self._playLock) {\n        self._queue.push({\n          event: 'pause',\n          action: function() {\n            self.pause(id);\n          }\n        });\n\n        return self;\n      }\n\n      // If no id is passed, get all ID's to be paused.\n      var ids = self._getSoundIds(id);\n\n      for (var i=0; i<ids.length; i++) {\n        // Clear the end timer.\n        self._clearTimer(ids[i]);\n\n        // Get the sound.\n        var sound = self._soundById(ids[i]);\n\n        if (sound && !sound._paused) {\n          // Reset the seek position.\n          sound._seek = self.seek(ids[i]);\n          sound._rateSeek = 0;\n          sound._paused = true;\n\n          // Stop currently running fades.\n          self._stopFade(ids[i]);\n\n          if (sound._node) {\n            if (self._webAudio) {\n              // Make sure the sound has been created.\n              if (!sound._node.bufferSource) {\n                continue;\n              }\n\n              if (typeof sound._node.bufferSource.stop === 'undefined') {\n                sound._node.bufferSource.noteOff(0);\n              } else {\n                sound._node.bufferSource.stop(0);\n              }\n\n              // Clean up the buffer source.\n              self._cleanBuffer(sound._node);\n            } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {\n              sound._node.pause();\n            }\n          }\n        }\n\n        // Fire the pause event, unless `true` is passed as the 2nd argument.\n        if (!arguments[1]) {\n          self._emit('pause', sound ? sound._id : null);\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Stop playback and reset to start.\n     * @param  {Number} id The sound ID (empty to stop all in group).\n     * @param  {Boolean} internal Internal Use: true prevents event firing.\n     * @return {Howl}\n     */\n    stop: function(id, internal) {\n      var self = this;\n\n      // If the sound hasn't loaded, add it to the load queue to stop when capable.\n      if (self._state !== 'loaded' || self._playLock) {\n        self._queue.push({\n          event: 'stop',\n          action: function() {\n            self.stop(id);\n          }\n        });\n\n        return self;\n      }\n\n      // If no id is passed, get all ID's to be stopped.\n      var ids = self._getSoundIds(id);\n\n      for (var i=0; i<ids.length; i++) {\n        // Clear the end timer.\n        self._clearTimer(ids[i]);\n\n        // Get the sound.\n        var sound = self._soundById(ids[i]);\n\n        if (sound) {\n          // Reset the seek position.\n          sound._seek = sound._start || 0;\n          sound._rateSeek = 0;\n          sound._paused = true;\n          sound._ended = true;\n\n          // Stop currently running fades.\n          self._stopFade(ids[i]);\n\n          if (sound._node) {\n            if (self._webAudio) {\n              // Make sure the sound's AudioBufferSourceNode has been created.\n              if (sound._node.bufferSource) {\n                if (typeof sound._node.bufferSource.stop === 'undefined') {\n                  sound._node.bufferSource.noteOff(0);\n                } else {\n                  sound._node.bufferSource.stop(0);\n                }\n\n                // Clean up the buffer source.\n                self._cleanBuffer(sound._node);\n              }\n            } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {\n              sound._node.currentTime = sound._start || 0;\n              sound._node.pause();\n\n              // If this is a live stream, stop download once the audio is stopped.\n              if (sound._node.duration === Infinity) {\n                self._clearSound(sound._node);\n              }\n            }\n          }\n\n          if (!internal) {\n            self._emit('stop', sound._id);\n          }\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Mute/unmute a single sound or all sounds in this Howl group.\n     * @param  {Boolean} muted Set to true to mute and false to unmute.\n     * @param  {Number} id    The sound ID to update (omit to mute/unmute all).\n     * @return {Howl}\n     */\n    mute: function(muted, id) {\n      var self = this;\n\n      // If the sound hasn't loaded, add it to the load queue to mute when capable.\n      if (self._state !== 'loaded'|| self._playLock) {\n        self._queue.push({\n          event: 'mute',\n          action: function() {\n            self.mute(muted, id);\n          }\n        });\n\n        return self;\n      }\n\n      // If applying mute/unmute to all sounds, update the group's value.\n      if (typeof id === 'undefined') {\n        if (typeof muted === 'boolean') {\n          self._muted = muted;\n        } else {\n          return self._muted;\n        }\n      }\n\n      // If no id is passed, get all ID's to be muted.\n      var ids = self._getSoundIds(id);\n\n      for (var i=0; i<ids.length; i++) {\n        // Get the sound.\n        var sound = self._soundById(ids[i]);\n\n        if (sound) {\n          sound._muted = muted;\n\n          // Cancel active fade and set the volume to the end value.\n          if (sound._interval) {\n            self._stopFade(sound._id);\n          }\n\n          if (self._webAudio && sound._node) {\n            sound._node.gain.setValueAtTime(muted ? 0 : sound._volume, Howler.ctx.currentTime);\n          } else if (sound._node) {\n            sound._node.muted = Howler._muted ? true : muted;\n          }\n\n          self._emit('mute', sound._id);\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Get/set the volume of this sound or of the Howl group. This method can optionally take 0, 1 or 2 arguments.\n     *   volume() -> Returns the group's volume value.\n     *   volume(id) -> Returns the sound id's current volume.\n     *   volume(vol) -> Sets the volume of all sounds in this Howl group.\n     *   volume(vol, id) -> Sets the volume of passed sound id.\n     * @return {Howl/Number} Returns self or current volume.\n     */\n    volume: function() {\n      var self = this;\n      var args = arguments;\n      var vol, id;\n\n      // Determine the values based on arguments.\n      if (args.length === 0) {\n        // Return the value of the groups' volume.\n        return self._volume;\n      } else if (args.length === 1 || args.length === 2 && typeof args[1] === 'undefined') {\n        // First check if this is an ID, and if not, assume it is a new volume.\n        var ids = self._getSoundIds();\n        var index = ids.indexOf(args[0]);\n        if (index >= 0) {\n          id = parseInt(args[0], 10);\n        } else {\n          vol = parseFloat(args[0]);\n        }\n      } else if (args.length >= 2) {\n        vol = parseFloat(args[0]);\n        id = parseInt(args[1], 10);\n      }\n\n      // Update the volume or return the current volume.\n      var sound;\n      if (typeof vol !== 'undefined' && vol >= 0 && vol <= 1) {\n        // If the sound hasn't loaded, add it to the load queue to change volume when capable.\n        if (self._state !== 'loaded'|| self._playLock) {\n          self._queue.push({\n            event: 'volume',\n            action: function() {\n              self.volume.apply(self, args);\n            }\n          });\n\n          return self;\n        }\n\n        // Set the group volume.\n        if (typeof id === 'undefined') {\n          self._volume = vol;\n        }\n\n        // Update one or all volumes.\n        id = self._getSoundIds(id);\n        for (var i=0; i<id.length; i++) {\n          // Get the sound.\n          sound = self._soundById(id[i]);\n\n          if (sound) {\n            sound._volume = vol;\n\n            // Stop currently running fades.\n            if (!args[2]) {\n              self._stopFade(id[i]);\n            }\n\n            if (self._webAudio && sound._node && !sound._muted) {\n              sound._node.gain.setValueAtTime(vol, Howler.ctx.currentTime);\n            } else if (sound._node && !sound._muted) {\n              sound._node.volume = vol * Howler.volume();\n            }\n\n            self._emit('volume', sound._id);\n          }\n        }\n      } else {\n        sound = id ? self._soundById(id) : self._sounds[0];\n        return sound ? sound._volume : 0;\n      }\n\n      return self;\n    },\n\n    /**\n     * Fade a currently playing sound between two volumes (if no id is passed, all sounds will fade).\n     * @param  {Number} from The value to fade from (0.0 to 1.0).\n     * @param  {Number} to   The volume to fade to (0.0 to 1.0).\n     * @param  {Number} len  Time in milliseconds to fade.\n     * @param  {Number} id   The sound id (omit to fade all sounds).\n     * @return {Howl}\n     */\n    fade: function(from, to, len, id) {\n      var self = this;\n\n      // If the sound hasn't loaded, add it to the load queue to fade when capable.\n      if (self._state !== 'loaded' || self._playLock) {\n        self._queue.push({\n          event: 'fade',\n          action: function() {\n            self.fade(from, to, len, id);\n          }\n        });\n\n        return self;\n      }\n\n      // Make sure the to/from/len values are numbers.\n      from = Math.min(Math.max(0, parseFloat(from)), 1);\n      to = Math.min(Math.max(0, parseFloat(to)), 1);\n      len = parseFloat(len);\n\n      // Set the volume to the start position.\n      self.volume(from, id);\n\n      // Fade the volume of one or all sounds.\n      var ids = self._getSoundIds(id);\n      for (var i=0; i<ids.length; i++) {\n        // Get the sound.\n        var sound = self._soundById(ids[i]);\n\n        // Create a linear fade or fall back to timeouts with HTML5 Audio.\n        if (sound) {\n          // Stop the previous fade if no sprite is being used (otherwise, volume handles this).\n          if (!id) {\n            self._stopFade(ids[i]);\n          }\n\n          // If we are using Web Audio, let the native methods do the actual fade.\n          if (self._webAudio && !sound._muted) {\n            var currentTime = Howler.ctx.currentTime;\n            var end = currentTime + (len / 1000);\n            sound._volume = from;\n            sound._node.gain.setValueAtTime(from, currentTime);\n            sound._node.gain.linearRampToValueAtTime(to, end);\n          }\n\n          self._startFadeInterval(sound, from, to, len, ids[i], typeof id === 'undefined');\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Starts the internal interval to fade a sound.\n     * @param  {Object} sound Reference to sound to fade.\n     * @param  {Number} from The value to fade from (0.0 to 1.0).\n     * @param  {Number} to   The volume to fade to (0.0 to 1.0).\n     * @param  {Number} len  Time in milliseconds to fade.\n     * @param  {Number} id   The sound id to fade.\n     * @param  {Boolean} isGroup   If true, set the volume on the group.\n     */\n    _startFadeInterval: function(sound, from, to, len, id, isGroup) {\n      var self = this;\n      var vol = from;\n      var diff = to - from;\n      var steps = Math.abs(diff / 0.01);\n      var stepLen = Math.max(4, (steps > 0) ? len / steps : len);\n      var lastTick = Date.now();\n\n      // Store the value being faded to.\n      sound._fadeTo = to;\n\n      // Update the volume value on each interval tick.\n      sound._interval = setInterval(function() {\n        // Update the volume based on the time since the last tick.\n        var tick = (Date.now() - lastTick) / len;\n        lastTick = Date.now();\n        vol += diff * tick;\n\n        // Round to within 2 decimal points.\n        vol = Math.round(vol * 100) / 100;\n\n        // Make sure the volume is in the right bounds.\n        if (diff < 0) {\n          vol = Math.max(to, vol);\n        } else {\n          vol = Math.min(to, vol);\n        }\n\n        // Change the volume.\n        if (self._webAudio) {\n          sound._volume = vol;\n        } else {\n          self.volume(vol, sound._id, true);\n        }\n\n        // Set the group's volume.\n        if (isGroup) {\n          self._volume = vol;\n        }\n\n        // When the fade is complete, stop it and fire event.\n        if ((to < from && vol <= to) || (to > from && vol >= to)) {\n          clearInterval(sound._interval);\n          sound._interval = null;\n          sound._fadeTo = null;\n          self.volume(to, sound._id);\n          self._emit('fade', sound._id);\n        }\n      }, stepLen);\n    },\n\n    /**\n     * Internal method that stops the currently playing fade when\n     * a new fade starts, volume is changed or the sound is stopped.\n     * @param  {Number} id The sound id.\n     * @return {Howl}\n     */\n    _stopFade: function(id) {\n      var self = this;\n      var sound = self._soundById(id);\n\n      if (sound && sound._interval) {\n        if (self._webAudio) {\n          sound._node.gain.cancelScheduledValues(Howler.ctx.currentTime);\n        }\n\n        clearInterval(sound._interval);\n        sound._interval = null;\n        self.volume(sound._fadeTo, id);\n        sound._fadeTo = null;\n        self._emit('fade', id);\n      }\n\n      return self;\n    },\n\n    /**\n     * Get/set the loop parameter on a sound. This method can optionally take 0, 1 or 2 arguments.\n     *   loop() -> Returns the group's loop value.\n     *   loop(id) -> Returns the sound id's loop value.\n     *   loop(loop) -> Sets the loop value for all sounds in this Howl group.\n     *   loop(loop, id) -> Sets the loop value of passed sound id.\n     * @return {Howl/Boolean} Returns self or current loop value.\n     */\n    loop: function() {\n      var self = this;\n      var args = arguments;\n      var loop, id, sound;\n\n      // Determine the values for loop and id.\n      if (args.length === 0) {\n        // Return the grou's loop value.\n        return self._loop;\n      } else if (args.length === 1) {\n        if (typeof args[0] === 'boolean') {\n          loop = args[0];\n          self._loop = loop;\n        } else {\n          // Return this sound's loop value.\n          sound = self._soundById(parseInt(args[0], 10));\n          return sound ? sound._loop : false;\n        }\n      } else if (args.length === 2) {\n        loop = args[0];\n        id = parseInt(args[1], 10);\n      }\n\n      // If no id is passed, get all ID's to be looped.\n      var ids = self._getSoundIds(id);\n      for (var i=0; i<ids.length; i++) {\n        sound = self._soundById(ids[i]);\n\n        if (sound) {\n          sound._loop = loop;\n          if (self._webAudio && sound._node && sound._node.bufferSource) {\n            sound._node.bufferSource.loop = loop;\n            if (loop) {\n              sound._node.bufferSource.loopStart = sound._start || 0;\n              sound._node.bufferSource.loopEnd = sound._stop;\n\n              // If playing, restart playback to ensure looping updates.\n              if (self.playing(ids[i])) {\n                self.pause(ids[i], true);\n                self.play(ids[i], true);\n              }\n            }\n          }\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Get/set the playback rate of a sound. This method can optionally take 0, 1 or 2 arguments.\n     *   rate() -> Returns the first sound node's current playback rate.\n     *   rate(id) -> Returns the sound id's current playback rate.\n     *   rate(rate) -> Sets the playback rate of all sounds in this Howl group.\n     *   rate(rate, id) -> Sets the playback rate of passed sound id.\n     * @return {Howl/Number} Returns self or the current playback rate.\n     */\n    rate: function() {\n      var self = this;\n      var args = arguments;\n      var rate, id;\n\n      // Determine the values based on arguments.\n      if (args.length === 0) {\n        // We will simply return the current rate of the first node.\n        id = self._sounds[0]._id;\n      } else if (args.length === 1) {\n        // First check if this is an ID, and if not, assume it is a new rate value.\n        var ids = self._getSoundIds();\n        var index = ids.indexOf(args[0]);\n        if (index >= 0) {\n          id = parseInt(args[0], 10);\n        } else {\n          rate = parseFloat(args[0]);\n        }\n      } else if (args.length === 2) {\n        rate = parseFloat(args[0]);\n        id = parseInt(args[1], 10);\n      }\n\n      // Update the playback rate or return the current value.\n      var sound;\n      if (typeof rate === 'number') {\n        // If the sound hasn't loaded, add it to the load queue to change playback rate when capable.\n        if (self._state !== 'loaded' || self._playLock) {\n          self._queue.push({\n            event: 'rate',\n            action: function() {\n              self.rate.apply(self, args);\n            }\n          });\n\n          return self;\n        }\n\n        // Set the group rate.\n        if (typeof id === 'undefined') {\n          self._rate = rate;\n        }\n\n        // Update one or all volumes.\n        id = self._getSoundIds(id);\n        for (var i=0; i<id.length; i++) {\n          // Get the sound.\n          sound = self._soundById(id[i]);\n\n          if (sound) {\n            // Keep track of our position when the rate changed and update the playback\n            // start position so we can properly adjust the seek position for time elapsed.\n            if (self.playing(id[i])) {\n              sound._rateSeek = self.seek(id[i]);\n              sound._playStart = self._webAudio ? Howler.ctx.currentTime : sound._playStart;\n            }\n            sound._rate = rate;\n\n            // Change the playback rate.\n            if (self._webAudio && sound._node && sound._node.bufferSource) {\n              sound._node.bufferSource.playbackRate.setValueAtTime(rate, Howler.ctx.currentTime);\n            } else if (sound._node) {\n              sound._node.playbackRate = rate;\n            }\n\n            // Reset the timers.\n            var seek = self.seek(id[i]);\n            var duration = ((self._sprite[sound._sprite][0] + self._sprite[sound._sprite][1]) / 1000) - seek;\n            var timeout = (duration * 1000) / Math.abs(sound._rate);\n\n            // Start a new end timer if sound is already playing.\n            if (self._endTimers[id[i]] || !sound._paused) {\n              self._clearTimer(id[i]);\n              self._endTimers[id[i]] = setTimeout(self._ended.bind(self, sound), timeout);\n            }\n\n            self._emit('rate', sound._id);\n          }\n        }\n      } else {\n        sound = self._soundById(id);\n        return sound ? sound._rate : self._rate;\n      }\n\n      return self;\n    },\n\n    /**\n     * Get/set the seek position of a sound. This method can optionally take 0, 1 or 2 arguments.\n     *   seek() -> Returns the first sound node's current seek position.\n     *   seek(id) -> Returns the sound id's current seek position.\n     *   seek(seek) -> Sets the seek position of the first sound node.\n     *   seek(seek, id) -> Sets the seek position of passed sound id.\n     * @return {Howl/Number} Returns self or the current seek position.\n     */\n    seek: function() {\n      var self = this;\n      var args = arguments;\n      var seek, id;\n\n      // Determine the values based on arguments.\n      if (args.length === 0) {\n        // We will simply return the current position of the first node.\n        if (self._sounds.length) {\n          id = self._sounds[0]._id;\n        }\n      } else if (args.length === 1) {\n        // First check if this is an ID, and if not, assume it is a new seek position.\n        var ids = self._getSoundIds();\n        var index = ids.indexOf(args[0]);\n        if (index >= 0) {\n          id = parseInt(args[0], 10);\n        } else if (self._sounds.length) {\n          id = self._sounds[0]._id;\n          seek = parseFloat(args[0]);\n        }\n      } else if (args.length === 2) {\n        seek = parseFloat(args[0]);\n        id = parseInt(args[1], 10);\n      }\n\n      // If there is no ID, bail out.\n      if (typeof id === 'undefined') {\n        return 0;\n      }\n\n      // If the sound hasn't loaded, add it to the load queue to seek when capable.\n      if (typeof seek === 'number' && (self._state !== 'loaded' || self._playLock)) {\n        self._queue.push({\n          event: 'seek',\n          action: function() {\n            self.seek.apply(self, args);\n          }\n        });\n\n        return self;\n      }\n\n      // Get the sound.\n      var sound = self._soundById(id);\n\n      if (sound) {\n        if (typeof seek === 'number' && seek >= 0) {\n          // Pause the sound and update position for restarting playback.\n          var playing = self.playing(id);\n          if (playing) {\n            self.pause(id, true);\n          }\n\n          // Move the position of the track and cancel timer.\n          sound._seek = seek;\n          sound._ended = false;\n          self._clearTimer(id);\n\n          // Update the seek position for HTML5 Audio.\n          if (!self._webAudio && sound._node && !isNaN(sound._node.duration)) {\n            sound._node.currentTime = seek;\n          }\n\n          // Seek and emit when ready.\n          var seekAndEmit = function() {\n            // Restart the playback if the sound was playing.\n            if (playing) {\n              self.play(id, true);\n            }\n\n            self._emit('seek', id);\n          };\n\n          // Wait for the play lock to be unset before emitting (HTML5 Audio).\n          if (playing && !self._webAudio) {\n            var emitSeek = function() {\n              if (!self._playLock) {\n                seekAndEmit();\n              } else {\n                setTimeout(emitSeek, 0);\n              }\n            };\n            setTimeout(emitSeek, 0);\n          } else {\n            seekAndEmit();\n          }\n        } else {\n          if (self._webAudio) {\n            var realTime = self.playing(id) ? Howler.ctx.currentTime - sound._playStart : 0;\n            var rateSeek = sound._rateSeek ? sound._rateSeek - sound._seek : 0;\n            return sound._seek + (rateSeek + realTime * Math.abs(sound._rate));\n          } else {\n            return sound._node.currentTime;\n          }\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Check if a specific sound is currently playing or not (if id is provided), or check if at least one of the sounds in the group is playing or not.\n     * @param  {Number}  id The sound id to check. If none is passed, the whole sound group is checked.\n     * @return {Boolean} True if playing and false if not.\n     */\n    playing: function(id) {\n      var self = this;\n\n      // Check the passed sound ID (if any).\n      if (typeof id === 'number') {\n        var sound = self._soundById(id);\n        return sound ? !sound._paused : false;\n      }\n\n      // Otherwise, loop through all sounds and check if any are playing.\n      for (var i=0; i<self._sounds.length; i++) {\n        if (!self._sounds[i]._paused) {\n          return true;\n        }\n      }\n\n      return false;\n    },\n\n    /**\n     * Get the duration of this sound. Passing a sound id will return the sprite duration.\n     * @param  {Number} id The sound id to check. If none is passed, return full source duration.\n     * @return {Number} Audio duration in seconds.\n     */\n    duration: function(id) {\n      var self = this;\n      var duration = self._duration;\n\n      // If we pass an ID, get the sound and return the sprite length.\n      var sound = self._soundById(id);\n      if (sound) {\n        duration = self._sprite[sound._sprite][1] / 1000;\n      }\n\n      return duration;\n    },\n\n    /**\n     * Returns the current loaded state of this Howl.\n     * @return {String} 'unloaded', 'loading', 'loaded'\n     */\n    state: function() {\n      return this._state;\n    },\n\n    /**\n     * Unload and destroy the current Howl object.\n     * This will immediately stop all sound instances attached to this group.\n     */\n    unload: function() {\n      var self = this;\n\n      // Stop playing any active sounds.\n      var sounds = self._sounds;\n      for (var i=0; i<sounds.length; i++) {\n        // Stop the sound if it is currently playing.\n        if (!sounds[i]._paused) {\n          self.stop(sounds[i]._id);\n        }\n\n        // Remove the source or disconnect.\n        if (!self._webAudio) {\n          // Set the source to 0-second silence to stop any downloading (except in IE).\n          self._clearSound(sounds[i]._node);\n\n          // Remove any event listeners.\n          sounds[i]._node.removeEventListener('error', sounds[i]._errorFn, false);\n          sounds[i]._node.removeEventListener(Howler._canPlayEvent, sounds[i]._loadFn, false);\n          sounds[i]._node.removeEventListener('ended', sounds[i]._endFn, false);\n\n          // Release the Audio object back to the pool.\n          Howler._releaseHtml5Audio(sounds[i]._node);\n        }\n\n        // Empty out all of the nodes.\n        delete sounds[i]._node;\n\n        // Make sure all timers are cleared out.\n        self._clearTimer(sounds[i]._id);\n      }\n\n      // Remove the references in the global Howler object.\n      var index = Howler._howls.indexOf(self);\n      if (index >= 0) {\n        Howler._howls.splice(index, 1);\n      }\n\n      // Delete this sound from the cache (if no other Howl is using it).\n      var remCache = true;\n      for (i=0; i<Howler._howls.length; i++) {\n        if (Howler._howls[i]._src === self._src || self._src.indexOf(Howler._howls[i]._src) >= 0) {\n          remCache = false;\n          break;\n        }\n      }\n\n      if (cache && remCache) {\n        delete cache[self._src];\n      }\n\n      // Clear global errors.\n      Howler.noAudio = false;\n\n      // Clear out `self`.\n      self._state = 'unloaded';\n      self._sounds = [];\n      self = null;\n\n      return null;\n    },\n\n    /**\n     * Listen to a custom event.\n     * @param  {String}   event Event name.\n     * @param  {Function} fn    Listener to call.\n     * @param  {Number}   id    (optional) Only listen to events for this sound.\n     * @param  {Number}   once  (INTERNAL) Marks event to fire only once.\n     * @return {Howl}\n     */\n    on: function(event, fn, id, once) {\n      var self = this;\n      var events = self['_on' + event];\n\n      if (typeof fn === 'function') {\n        events.push(once ? {id: id, fn: fn, once: once} : {id: id, fn: fn});\n      }\n\n      return self;\n    },\n\n    /**\n     * Remove a custom event. Call without parameters to remove all events.\n     * @param  {String}   event Event name.\n     * @param  {Function} fn    Listener to remove. Leave empty to remove all.\n     * @param  {Number}   id    (optional) Only remove events for this sound.\n     * @return {Howl}\n     */\n    off: function(event, fn, id) {\n      var self = this;\n      var events = self['_on' + event];\n      var i = 0;\n\n      // Allow passing just an event and ID.\n      if (typeof fn === 'number') {\n        id = fn;\n        fn = null;\n      }\n\n      if (fn || id) {\n        // Loop through event store and remove the passed function.\n        for (i=0; i<events.length; i++) {\n          var isId = (id === events[i].id);\n          if (fn === events[i].fn && isId || !fn && isId) {\n            events.splice(i, 1);\n            break;\n          }\n        }\n      } else if (event) {\n        // Clear out all events of this type.\n        self['_on' + event] = [];\n      } else {\n        // Clear out all events of every type.\n        var keys = Object.keys(self);\n        for (i=0; i<keys.length; i++) {\n          if ((keys[i].indexOf('_on') === 0) && Array.isArray(self[keys[i]])) {\n            self[keys[i]] = [];\n          }\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Listen to a custom event and remove it once fired.\n     * @param  {String}   event Event name.\n     * @param  {Function} fn    Listener to call.\n     * @param  {Number}   id    (optional) Only listen to events for this sound.\n     * @return {Howl}\n     */\n    once: function(event, fn, id) {\n      var self = this;\n\n      // Setup the event listener.\n      self.on(event, fn, id, 1);\n\n      return self;\n    },\n\n    /**\n     * Emit all events of a specific type and pass the sound id.\n     * @param  {String} event Event name.\n     * @param  {Number} id    Sound ID.\n     * @param  {Number} msg   Message to go with event.\n     * @return {Howl}\n     */\n    _emit: function(event, id, msg) {\n      var self = this;\n      var events = self['_on' + event];\n\n      // Loop through event store and fire all functions.\n      for (var i=events.length-1; i>=0; i--) {\n        // Only fire the listener if the correct ID is used.\n        if (!events[i].id || events[i].id === id || event === 'load') {\n          setTimeout(function(fn) {\n            fn.call(this, id, msg);\n          }.bind(self, events[i].fn), 0);\n\n          // If this event was setup with `once`, remove it.\n          if (events[i].once) {\n            self.off(event, events[i].fn, events[i].id);\n          }\n        }\n      }\n\n      // Pass the event type into load queue so that it can continue stepping.\n      self._loadQueue(event);\n\n      return self;\n    },\n\n    /**\n     * Queue of actions initiated before the sound has loaded.\n     * These will be called in sequence, with the next only firing\n     * after the previous has finished executing (even if async like play).\n     * @return {Howl}\n     */\n    _loadQueue: function(event) {\n      var self = this;\n\n      if (self._queue.length > 0) {\n        var task = self._queue[0];\n\n        // Remove this task if a matching event was passed.\n        if (task.event === event) {\n          self._queue.shift();\n          self._loadQueue();\n        }\n\n        // Run the task if no event type is passed.\n        if (!event) {\n          task.action();\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Fired when playback ends at the end of the duration.\n     * @param  {Sound} sound The sound object to work with.\n     * @return {Howl}\n     */\n    _ended: function(sound) {\n      var self = this;\n      var sprite = sound._sprite;\n\n      // If we are using IE and there was network latency we may be clipping\n      // audio before it completes playing. Lets check the node to make sure it\n      // believes it has completed, before ending the playback.\n      if (!self._webAudio && sound._node && !sound._node.paused && !sound._node.ended && sound._node.currentTime < sound._stop) {\n        setTimeout(self._ended.bind(self, sound), 100);\n        return self;\n      }\n\n      // Should this sound loop?\n      var loop = !!(sound._loop || self._sprite[sprite][2]);\n\n      // Fire the ended event.\n      self._emit('end', sound._id);\n\n      // Restart the playback for HTML5 Audio loop.\n      if (!self._webAudio && loop) {\n        self.stop(sound._id, true).play(sound._id);\n      }\n\n      // Restart this timer if on a Web Audio loop.\n      if (self._webAudio && loop) {\n        self._emit('play', sound._id);\n        sound._seek = sound._start || 0;\n        sound._rateSeek = 0;\n        sound._playStart = Howler.ctx.currentTime;\n\n        var timeout = ((sound._stop - sound._start) * 1000) / Math.abs(sound._rate);\n        self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);\n      }\n\n      // Mark the node as paused.\n      if (self._webAudio && !loop) {\n        sound._paused = true;\n        sound._ended = true;\n        sound._seek = sound._start || 0;\n        sound._rateSeek = 0;\n        self._clearTimer(sound._id);\n\n        // Clean up the buffer source.\n        self._cleanBuffer(sound._node);\n\n        // Attempt to auto-suspend AudioContext if no sounds are still playing.\n        Howler._autoSuspend();\n      }\n\n      // When using a sprite, end the track.\n      if (!self._webAudio && !loop) {\n        self.stop(sound._id, true);\n      }\n\n      return self;\n    },\n\n    /**\n     * Clear the end timer for a sound playback.\n     * @param  {Number} id The sound ID.\n     * @return {Howl}\n     */\n    _clearTimer: function(id) {\n      var self = this;\n\n      if (self._endTimers[id]) {\n        // Clear the timeout or remove the ended listener.\n        if (typeof self._endTimers[id] !== 'function') {\n          clearTimeout(self._endTimers[id]);\n        } else {\n          var sound = self._soundById(id);\n          if (sound && sound._node) {\n            sound._node.removeEventListener('ended', self._endTimers[id], false);\n          }\n        }\n\n        delete self._endTimers[id];\n      }\n\n      return self;\n    },\n\n    /**\n     * Return the sound identified by this ID, or return null.\n     * @param  {Number} id Sound ID\n     * @return {Object}    Sound object or null.\n     */\n    _soundById: function(id) {\n      var self = this;\n\n      // Loop through all sounds and find the one with this ID.\n      for (var i=0; i<self._sounds.length; i++) {\n        if (id === self._sounds[i]._id) {\n          return self._sounds[i];\n        }\n      }\n\n      return null;\n    },\n\n    /**\n     * Return an inactive sound from the pool or create a new one.\n     * @return {Sound} Sound playback object.\n     */\n    _inactiveSound: function() {\n      var self = this;\n\n      self._drain();\n\n      // Find the first inactive node to recycle.\n      for (var i=0; i<self._sounds.length; i++) {\n        if (self._sounds[i]._ended) {\n          return self._sounds[i].reset();\n        }\n      }\n\n      // If no inactive node was found, create a new one.\n      return new Sound(self);\n    },\n\n    /**\n     * Drain excess inactive sounds from the pool.\n     */\n    _drain: function() {\n      var self = this;\n      var limit = self._pool;\n      var cnt = 0;\n      var i = 0;\n\n      // If there are less sounds than the max pool size, we are done.\n      if (self._sounds.length < limit) {\n        return;\n      }\n\n      // Count the number of inactive sounds.\n      for (i=0; i<self._sounds.length; i++) {\n        if (self._sounds[i]._ended) {\n          cnt++;\n        }\n      }\n\n      // Remove excess inactive sounds, going in reverse order.\n      for (i=self._sounds.length - 1; i>=0; i--) {\n        if (cnt <= limit) {\n          return;\n        }\n\n        if (self._sounds[i]._ended) {\n          // Disconnect the audio source when using Web Audio.\n          if (self._webAudio && self._sounds[i]._node) {\n            self._sounds[i]._node.disconnect(0);\n          }\n\n          // Remove sounds until we have the pool size.\n          self._sounds.splice(i, 1);\n          cnt--;\n        }\n      }\n    },\n\n    /**\n     * Get all ID's from the sounds pool.\n     * @param  {Number} id Only return one ID if one is passed.\n     * @return {Array}    Array of IDs.\n     */\n    _getSoundIds: function(id) {\n      var self = this;\n\n      if (typeof id === 'undefined') {\n        var ids = [];\n        for (var i=0; i<self._sounds.length; i++) {\n          ids.push(self._sounds[i]._id);\n        }\n\n        return ids;\n      } else {\n        return [id];\n      }\n    },\n\n    /**\n     * Load the sound back into the buffer source.\n     * @param  {Sound} sound The sound object to work with.\n     * @return {Howl}\n     */\n    _refreshBuffer: function(sound) {\n      var self = this;\n\n      // Setup the buffer source for playback.\n      sound._node.bufferSource = Howler.ctx.createBufferSource();\n      sound._node.bufferSource.buffer = cache[self._src];\n\n      // Connect to the correct node.\n      if (sound._panner) {\n        sound._node.bufferSource.connect(sound._panner);\n      } else {\n        sound._node.bufferSource.connect(sound._node);\n      }\n\n      // Setup looping and playback rate.\n      sound._node.bufferSource.loop = sound._loop;\n      if (sound._loop) {\n        sound._node.bufferSource.loopStart = sound._start || 0;\n        sound._node.bufferSource.loopEnd = sound._stop || 0;\n      }\n      sound._node.bufferSource.playbackRate.setValueAtTime(sound._rate, Howler.ctx.currentTime);\n\n      return self;\n    },\n\n    /**\n     * Prevent memory leaks by cleaning up the buffer source after playback.\n     * @param  {Object} node Sound's audio node containing the buffer source.\n     * @return {Howl}\n     */\n    _cleanBuffer: function(node) {\n      var self = this;\n      var isIOS = Howler._navigator && Howler._navigator.vendor.indexOf('Apple') >= 0;\n\n      if (!node.bufferSource) {\n        return self;\n      }\n\n      if (Howler._scratchBuffer && node.bufferSource) {\n        node.bufferSource.onended = null;\n        node.bufferSource.disconnect(0);\n        if (isIOS) {\n          try { node.bufferSource.buffer = Howler._scratchBuffer; } catch(e) {}\n        }\n      }\n      node.bufferSource = null;\n\n      return self;\n    },\n\n    /**\n     * Set the source to a 0-second silence to stop any downloading (except in IE).\n     * @param  {Object} node Audio node to clear.\n     */\n    _clearSound: function(node) {\n      var checkIE = /MSIE |Trident\\//.test(Howler._navigator && Howler._navigator.userAgent);\n      if (!checkIE) {\n        node.src = 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA';\n      }\n    }\n  };\n\n  /** Single Sound Methods **/\n  /***************************************************************************/\n\n  /**\n   * Setup the sound object, which each node attached to a Howl group is contained in.\n   * @param {Object} howl The Howl parent group.\n   */\n  var Sound = function(howl) {\n    this._parent = howl;\n    this.init();\n  };\n  Sound.prototype = {\n    /**\n     * Initialize a new Sound object.\n     * @return {Sound}\n     */\n    init: function() {\n      var self = this;\n      var parent = self._parent;\n\n      // Setup the default parameters.\n      self._muted = parent._muted;\n      self._loop = parent._loop;\n      self._volume = parent._volume;\n      self._rate = parent._rate;\n      self._seek = 0;\n      self._paused = true;\n      self._ended = true;\n      self._sprite = '__default';\n\n      // Generate a unique ID for this sound.\n      self._id = ++Howler._counter;\n\n      // Add itself to the parent's pool.\n      parent._sounds.push(self);\n\n      // Create the new node.\n      self.create();\n\n      return self;\n    },\n\n    /**\n     * Create and setup a new sound object, whether HTML5 Audio or Web Audio.\n     * @return {Sound}\n     */\n    create: function() {\n      var self = this;\n      var parent = self._parent;\n      var volume = (Howler._muted || self._muted || self._parent._muted) ? 0 : self._volume;\n\n      if (parent._webAudio) {\n        // Create the gain node for controlling volume (the source will connect to this).\n        self._node = (typeof Howler.ctx.createGain === 'undefined') ? Howler.ctx.createGainNode() : Howler.ctx.createGain();\n        self._node.gain.setValueAtTime(volume, Howler.ctx.currentTime);\n        self._node.paused = true;\n        self._node.connect(Howler.masterGain);\n      } else if (!Howler.noAudio) {\n        // Get an unlocked Audio object from the pool.\n        self._node = Howler._obtainHtml5Audio();\n\n        // Listen for errors (http://dev.w3.org/html5/spec-author-view/spec.html#mediaerror).\n        self._errorFn = self._errorListener.bind(self);\n        self._node.addEventListener('error', self._errorFn, false);\n\n        // Listen for 'canplaythrough' event to let us know the sound is ready.\n        self._loadFn = self._loadListener.bind(self);\n        self._node.addEventListener(Howler._canPlayEvent, self._loadFn, false);\n\n        // Listen for the 'ended' event on the sound to account for edge-case where\n        // a finite sound has a duration of Infinity.\n        self._endFn = self._endListener.bind(self);\n        self._node.addEventListener('ended', self._endFn, false);\n\n        // Setup the new audio node.\n        self._node.src = parent._src;\n        self._node.preload = parent._preload === true ? 'auto' : parent._preload;\n        self._node.volume = volume * Howler.volume();\n\n        // Begin loading the source.\n        self._node.load();\n      }\n\n      return self;\n    },\n\n    /**\n     * Reset the parameters of this sound to the original state (for recycle).\n     * @return {Sound}\n     */\n    reset: function() {\n      var self = this;\n      var parent = self._parent;\n\n      // Reset all of the parameters of this sound.\n      self._muted = parent._muted;\n      self._loop = parent._loop;\n      self._volume = parent._volume;\n      self._rate = parent._rate;\n      self._seek = 0;\n      self._rateSeek = 0;\n      self._paused = true;\n      self._ended = true;\n      self._sprite = '__default';\n\n      // Generate a new ID so that it isn't confused with the previous sound.\n      self._id = ++Howler._counter;\n\n      return self;\n    },\n\n    /**\n     * HTML5 Audio error listener callback.\n     */\n    _errorListener: function() {\n      var self = this;\n\n      // Fire an error event and pass back the code.\n      self._parent._emit('loaderror', self._id, self._node.error ? self._node.error.code : 0);\n\n      // Clear the event listener.\n      self._node.removeEventListener('error', self._errorFn, false);\n    },\n\n    /**\n     * HTML5 Audio canplaythrough listener callback.\n     */\n    _loadListener: function() {\n      var self = this;\n      var parent = self._parent;\n\n      // Round up the duration to account for the lower precision in HTML5 Audio.\n      parent._duration = Math.ceil(self._node.duration * 10) / 10;\n\n      // Setup a sprite if none is defined.\n      if (Object.keys(parent._sprite).length === 0) {\n        parent._sprite = {__default: [0, parent._duration * 1000]};\n      }\n\n      if (parent._state !== 'loaded') {\n        parent._state = 'loaded';\n        parent._emit('load');\n        parent._loadQueue();\n      }\n\n      // Clear the event listener.\n      self._node.removeEventListener(Howler._canPlayEvent, self._loadFn, false);\n    },\n\n    /**\n     * HTML5 Audio ended listener callback.\n     */\n    _endListener: function() {\n      var self = this;\n      var parent = self._parent;\n\n      // Only handle the `ended`` event if the duration is Infinity.\n      if (parent._duration === Infinity) {\n        // Update the parent duration to match the real audio duration.\n        // Round up the duration to account for the lower precision in HTML5 Audio.\n        parent._duration = Math.ceil(self._node.duration * 10) / 10;\n\n        // Update the sprite that corresponds to the real duration.\n        if (parent._sprite.__default[1] === Infinity) {\n          parent._sprite.__default[1] = parent._duration * 1000;\n        }\n\n        // Run the regular ended method.\n        parent._ended(self);\n      }\n\n      // Clear the event listener since the duration is now correct.\n      self._node.removeEventListener('ended', self._endFn, false);\n    }\n  };\n\n  /** Helper Methods **/\n  /***************************************************************************/\n\n  var cache = {};\n\n  /**\n   * Buffer a sound from URL, Data URI or cache and decode to audio source (Web Audio API).\n   * @param  {Howl} self\n   */\n  var loadBuffer = function(self) {\n    var url = self._src;\n\n    // Check if the buffer has already been cached and use it instead.\n    if (cache[url]) {\n      // Set the duration from the cache.\n      self._duration = cache[url].duration;\n\n      // Load the sound into this Howl.\n      loadSound(self);\n\n      return;\n    }\n\n    if (/^data:[^;]+;base64,/.test(url)) {\n      // Decode the base64 data URI without XHR, since some browsers don't support it.\n      var data = atob(url.split(',')[1]);\n      var dataView = new Uint8Array(data.length);\n      for (var i=0; i<data.length; ++i) {\n        dataView[i] = data.charCodeAt(i);\n      }\n\n      decodeAudioData(dataView.buffer, self);\n    } else {\n      // Load the buffer from the URL.\n      var xhr = new XMLHttpRequest();\n      xhr.open(self._xhr.method, url, true);\n      xhr.withCredentials = self._xhr.withCredentials;\n      xhr.responseType = 'arraybuffer';\n\n      // Apply any custom headers to the request.\n      if (self._xhr.headers) {\n        Object.keys(self._xhr.headers).forEach(function(key) {\n          xhr.setRequestHeader(key, self._xhr.headers[key]);\n        });\n      }\n\n      xhr.onload = function() {\n        // Make sure we get a successful response back.\n        var code = (xhr.status + '')[0];\n        if (code !== '0' && code !== '2' && code !== '3') {\n          self._emit('loaderror', null, 'Failed loading audio file with status: ' + xhr.status + '.');\n          return;\n        }\n\n        decodeAudioData(xhr.response, self);\n      };\n      xhr.onerror = function() {\n        // If there is an error, switch to HTML5 Audio.\n        if (self._webAudio) {\n          self._html5 = true;\n          self._webAudio = false;\n          self._sounds = [];\n          delete cache[url];\n          self.load();\n        }\n      };\n      safeXhrSend(xhr);\n    }\n  };\n\n  /**\n   * Send the XHR request wrapped in a try/catch.\n   * @param  {Object} xhr XHR to send.\n   */\n  var safeXhrSend = function(xhr) {\n    try {\n      xhr.send();\n    } catch (e) {\n      xhr.onerror();\n    }\n  };\n\n  /**\n   * Decode audio data from an array buffer.\n   * @param  {ArrayBuffer} arraybuffer The audio data.\n   * @param  {Howl}        self\n   */\n  var decodeAudioData = function(arraybuffer, self) {\n    // Fire a load error if something broke.\n    var error = function() {\n      self._emit('loaderror', null, 'Decoding audio data failed.');\n    };\n\n    // Load the sound on success.\n    var success = function(buffer) {\n      if (buffer && self._sounds.length > 0) {\n        cache[self._src] = buffer;\n        loadSound(self, buffer);\n      } else {\n        error();\n      }\n    };\n\n    // Decode the buffer into an audio source.\n    if (typeof Promise !== 'undefined' && Howler.ctx.decodeAudioData.length === 1) {\n      Howler.ctx.decodeAudioData(arraybuffer).then(success).catch(error);\n    } else {\n      Howler.ctx.decodeAudioData(arraybuffer, success, error);\n    }\n  }\n\n  /**\n   * Sound is now loaded, so finish setting everything up and fire the loaded event.\n   * @param  {Howl} self\n   * @param  {Object} buffer The decoded buffer sound source.\n   */\n  var loadSound = function(self, buffer) {\n    // Set the duration.\n    if (buffer && !self._duration) {\n      self._duration = buffer.duration;\n    }\n\n    // Setup a sprite if none is defined.\n    if (Object.keys(self._sprite).length === 0) {\n      self._sprite = {__default: [0, self._duration * 1000]};\n    }\n\n    // Fire the loaded event.\n    if (self._state !== 'loaded') {\n      self._state = 'loaded';\n      self._emit('load');\n      self._loadQueue();\n    }\n  };\n\n  /**\n   * Setup the audio context when available, or switch to HTML5 Audio mode.\n   */\n  var setupAudioContext = function() {\n    // If we have already detected that Web Audio isn't supported, don't run this step again.\n    if (!Howler.usingWebAudio) {\n      return;\n    }\n\n    // Check if we are using Web Audio and setup the AudioContext if we are.\n    try {\n      if (typeof AudioContext !== 'undefined') {\n        Howler.ctx = new AudioContext();\n      } else if (typeof webkitAudioContext !== 'undefined') {\n        Howler.ctx = new webkitAudioContext();\n      } else {\n        Howler.usingWebAudio = false;\n      }\n    } catch(e) {\n      Howler.usingWebAudio = false;\n    }\n\n    // If the audio context creation still failed, set using web audio to false.\n    if (!Howler.ctx) {\n      Howler.usingWebAudio = false;\n    }\n\n    // Check if a webview is being used on iOS8 or earlier (rather than the browser).\n    // If it is, disable Web Audio as it causes crashing.\n    var iOS = (/iP(hone|od|ad)/.test(Howler._navigator && Howler._navigator.platform));\n    var appVersion = Howler._navigator && Howler._navigator.appVersion.match(/OS (\\d+)_(\\d+)_?(\\d+)?/);\n    var version = appVersion ? parseInt(appVersion[1], 10) : null;\n    if (iOS && version && version < 9) {\n      var safari = /safari/.test(Howler._navigator && Howler._navigator.userAgent.toLowerCase());\n      if (Howler._navigator && !safari) {\n        Howler.usingWebAudio = false;\n      }\n    }\n\n    // Create and expose the master GainNode when using Web Audio (useful for plugins or advanced usage).\n    if (Howler.usingWebAudio) {\n      Howler.masterGain = (typeof Howler.ctx.createGain === 'undefined') ? Howler.ctx.createGainNode() : Howler.ctx.createGain();\n      Howler.masterGain.gain.setValueAtTime(Howler._muted ? 0 : Howler._volume, Howler.ctx.currentTime);\n      Howler.masterGain.connect(Howler.ctx.destination);\n    }\n\n    // Re-run the setup on Howler.\n    Howler._setup();\n  };\n\n  // Add support for AMD (Asynchronous Module Definition) libraries such as require.js.\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n      return {\n        Howler: Howler,\n        Howl: Howl\n      };\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  }\n\n  // Add support for CommonJS libraries such as browserify.\n  if (true) {\n    exports.Howler = Howler;\n    exports.Howl = Howl;\n  }\n\n  // Add to global in Node.js (for testing, etc).\n  if (typeof __webpack_require__.g !== 'undefined') {\n    __webpack_require__.g.HowlerGlobal = HowlerGlobal;\n    __webpack_require__.g.Howler = Howler;\n    __webpack_require__.g.Howl = Howl;\n    __webpack_require__.g.Sound = Sound;\n  } else if (typeof window !== 'undefined') {  // Define globally in case AMD is not available or unused.\n    window.HowlerGlobal = HowlerGlobal;\n    window.Howler = Howler;\n    window.Howl = Howl;\n    window.Sound = Sound;\n  }\n})();\n\n\n/*!\n *  Spatial Plugin - Adds support for stereo and 3D audio where Web Audio is supported.\n *  \n *  howler.js v2.2.4\n *  howlerjs.com\n *\n *  (c) 2013-2020, James Simpson of GoldFire Studios\n *  goldfirestudios.com\n *\n *  MIT License\n */\n\n(function() {\n\n  'use strict';\n\n  // Setup default properties.\n  HowlerGlobal.prototype._pos = [0, 0, 0];\n  HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0];\n\n  /** Global Methods **/\n  /***************************************************************************/\n\n  /**\n   * Helper method to update the stereo panning position of all current Howls.\n   * Future Howls will not use this value unless explicitly set.\n   * @param  {Number} pan A value of -1.0 is all the way left and 1.0 is all the way right.\n   * @return {Howler/Number}     Self or current stereo panning value.\n   */\n  HowlerGlobal.prototype.stereo = function(pan) {\n    var self = this;\n\n    // Stop right here if not using Web Audio.\n    if (!self.ctx || !self.ctx.listener) {\n      return self;\n    }\n\n    // Loop through all Howls and update their stereo panning.\n    for (var i=self._howls.length-1; i>=0; i--) {\n      self._howls[i].stereo(pan);\n    }\n\n    return self;\n  };\n\n  /**\n   * Get/set the position of the listener in 3D cartesian space. Sounds using\n   * 3D position will be relative to the listener's position.\n   * @param  {Number} x The x-position of the listener.\n   * @param  {Number} y The y-position of the listener.\n   * @param  {Number} z The z-position of the listener.\n   * @return {Howler/Array}   Self or current listener position.\n   */\n  HowlerGlobal.prototype.pos = function(x, y, z) {\n    var self = this;\n\n    // Stop right here if not using Web Audio.\n    if (!self.ctx || !self.ctx.listener) {\n      return self;\n    }\n\n    // Set the defaults for optional 'y' & 'z'.\n    y = (typeof y !== 'number') ? self._pos[1] : y;\n    z = (typeof z !== 'number') ? self._pos[2] : z;\n\n    if (typeof x === 'number') {\n      self._pos = [x, y, z];\n\n      if (typeof self.ctx.listener.positionX !== 'undefined') {\n        self.ctx.listener.positionX.setTargetAtTime(self._pos[0], Howler.ctx.currentTime, 0.1);\n        self.ctx.listener.positionY.setTargetAtTime(self._pos[1], Howler.ctx.currentTime, 0.1);\n        self.ctx.listener.positionZ.setTargetAtTime(self._pos[2], Howler.ctx.currentTime, 0.1);\n      } else {\n        self.ctx.listener.setPosition(self._pos[0], self._pos[1], self._pos[2]);\n      }\n    } else {\n      return self._pos;\n    }\n\n    return self;\n  };\n\n  /**\n   * Get/set the direction the listener is pointing in the 3D cartesian space.\n   * A front and up vector must be provided. The front is the direction the\n   * face of the listener is pointing, and up is the direction the top of the\n   * listener is pointing. Thus, these values are expected to be at right angles\n   * from each other.\n   * @param  {Number} x   The x-orientation of the listener.\n   * @param  {Number} y   The y-orientation of the listener.\n   * @param  {Number} z   The z-orientation of the listener.\n   * @param  {Number} xUp The x-orientation of the top of the listener.\n   * @param  {Number} yUp The y-orientation of the top of the listener.\n   * @param  {Number} zUp The z-orientation of the top of the listener.\n   * @return {Howler/Array}     Returns self or the current orientation vectors.\n   */\n  HowlerGlobal.prototype.orientation = function(x, y, z, xUp, yUp, zUp) {\n    var self = this;\n\n    // Stop right here if not using Web Audio.\n    if (!self.ctx || !self.ctx.listener) {\n      return self;\n    }\n\n    // Set the defaults for optional 'y' & 'z'.\n    var or = self._orientation;\n    y = (typeof y !== 'number') ? or[1] : y;\n    z = (typeof z !== 'number') ? or[2] : z;\n    xUp = (typeof xUp !== 'number') ? or[3] : xUp;\n    yUp = (typeof yUp !== 'number') ? or[4] : yUp;\n    zUp = (typeof zUp !== 'number') ? or[5] : zUp;\n\n    if (typeof x === 'number') {\n      self._orientation = [x, y, z, xUp, yUp, zUp];\n\n      if (typeof self.ctx.listener.forwardX !== 'undefined') {\n        self.ctx.listener.forwardX.setTargetAtTime(x, Howler.ctx.currentTime, 0.1);\n        self.ctx.listener.forwardY.setTargetAtTime(y, Howler.ctx.currentTime, 0.1);\n        self.ctx.listener.forwardZ.setTargetAtTime(z, Howler.ctx.currentTime, 0.1);\n        self.ctx.listener.upX.setTargetAtTime(xUp, Howler.ctx.currentTime, 0.1);\n        self.ctx.listener.upY.setTargetAtTime(yUp, Howler.ctx.currentTime, 0.1);\n        self.ctx.listener.upZ.setTargetAtTime(zUp, Howler.ctx.currentTime, 0.1);\n      } else {\n        self.ctx.listener.setOrientation(x, y, z, xUp, yUp, zUp);\n      }\n    } else {\n      return or;\n    }\n\n    return self;\n  };\n\n  /** Group Methods **/\n  /***************************************************************************/\n\n  /**\n   * Add new properties to the core init.\n   * @param  {Function} _super Core init method.\n   * @return {Howl}\n   */\n  Howl.prototype.init = (function(_super) {\n    return function(o) {\n      var self = this;\n\n      // Setup user-defined default properties.\n      self._orientation = o.orientation || [1, 0, 0];\n      self._stereo = o.stereo || null;\n      self._pos = o.pos || null;\n      self._pannerAttr = {\n        coneInnerAngle: typeof o.coneInnerAngle !== 'undefined' ? o.coneInnerAngle : 360,\n        coneOuterAngle: typeof o.coneOuterAngle !== 'undefined' ? o.coneOuterAngle : 360,\n        coneOuterGain: typeof o.coneOuterGain !== 'undefined' ? o.coneOuterGain : 0,\n        distanceModel: typeof o.distanceModel !== 'undefined' ? o.distanceModel : 'inverse',\n        maxDistance: typeof o.maxDistance !== 'undefined' ? o.maxDistance : 10000,\n        panningModel: typeof o.panningModel !== 'undefined' ? o.panningModel : 'HRTF',\n        refDistance: typeof o.refDistance !== 'undefined' ? o.refDistance : 1,\n        rolloffFactor: typeof o.rolloffFactor !== 'undefined' ? o.rolloffFactor : 1\n      };\n\n      // Setup event listeners.\n      self._onstereo = o.onstereo ? [{fn: o.onstereo}] : [];\n      self._onpos = o.onpos ? [{fn: o.onpos}] : [];\n      self._onorientation = o.onorientation ? [{fn: o.onorientation}] : [];\n\n      // Complete initilization with howler.js core's init function.\n      return _super.call(this, o);\n    };\n  })(Howl.prototype.init);\n\n  /**\n   * Get/set the stereo panning of the audio source for this sound or all in the group.\n   * @param  {Number} pan  A value of -1.0 is all the way left and 1.0 is all the way right.\n   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.\n   * @return {Howl/Number}    Returns self or the current stereo panning value.\n   */\n  Howl.prototype.stereo = function(pan, id) {\n    var self = this;\n\n    // Stop right here if not using Web Audio.\n    if (!self._webAudio) {\n      return self;\n    }\n\n    // If the sound hasn't loaded, add it to the load queue to change stereo pan when capable.\n    if (self._state !== 'loaded') {\n      self._queue.push({\n        event: 'stereo',\n        action: function() {\n          self.stereo(pan, id);\n        }\n      });\n\n      return self;\n    }\n\n    // Check for PannerStereoNode support and fallback to PannerNode if it doesn't exist.\n    var pannerType = (typeof Howler.ctx.createStereoPanner === 'undefined') ? 'spatial' : 'stereo';\n\n    // Setup the group's stereo panning if no ID is passed.\n    if (typeof id === 'undefined') {\n      // Return the group's stereo panning if no parameters are passed.\n      if (typeof pan === 'number') {\n        self._stereo = pan;\n        self._pos = [pan, 0, 0];\n      } else {\n        return self._stereo;\n      }\n    }\n\n    // Change the streo panning of one or all sounds in group.\n    var ids = self._getSoundIds(id);\n    for (var i=0; i<ids.length; i++) {\n      // Get the sound.\n      var sound = self._soundById(ids[i]);\n\n      if (sound) {\n        if (typeof pan === 'number') {\n          sound._stereo = pan;\n          sound._pos = [pan, 0, 0];\n\n          if (sound._node) {\n            // If we are falling back, make sure the panningModel is equalpower.\n            sound._pannerAttr.panningModel = 'equalpower';\n\n            // Check if there is a panner setup and create a new one if not.\n            if (!sound._panner || !sound._panner.pan) {\n              setupPanner(sound, pannerType);\n            }\n\n            if (pannerType === 'spatial') {\n              if (typeof sound._panner.positionX !== 'undefined') {\n                sound._panner.positionX.setValueAtTime(pan, Howler.ctx.currentTime);\n                sound._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime);\n                sound._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime);\n              } else {\n                sound._panner.setPosition(pan, 0, 0);\n              }\n            } else {\n              sound._panner.pan.setValueAtTime(pan, Howler.ctx.currentTime);\n            }\n          }\n\n          self._emit('stereo', sound._id);\n        } else {\n          return sound._stereo;\n        }\n      }\n    }\n\n    return self;\n  };\n\n  /**\n   * Get/set the 3D spatial position of the audio source for this sound or group relative to the global listener.\n   * @param  {Number} x  The x-position of the audio source.\n   * @param  {Number} y  The y-position of the audio source.\n   * @param  {Number} z  The z-position of the audio source.\n   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.\n   * @return {Howl/Array}    Returns self or the current 3D spatial position: [x, y, z].\n   */\n  Howl.prototype.pos = function(x, y, z, id) {\n    var self = this;\n\n    // Stop right here if not using Web Audio.\n    if (!self._webAudio) {\n      return self;\n    }\n\n    // If the sound hasn't loaded, add it to the load queue to change position when capable.\n    if (self._state !== 'loaded') {\n      self._queue.push({\n        event: 'pos',\n        action: function() {\n          self.pos(x, y, z, id);\n        }\n      });\n\n      return self;\n    }\n\n    // Set the defaults for optional 'y' & 'z'.\n    y = (typeof y !== 'number') ? 0 : y;\n    z = (typeof z !== 'number') ? -0.5 : z;\n\n    // Setup the group's spatial position if no ID is passed.\n    if (typeof id === 'undefined') {\n      // Return the group's spatial position if no parameters are passed.\n      if (typeof x === 'number') {\n        self._pos = [x, y, z];\n      } else {\n        return self._pos;\n      }\n    }\n\n    // Change the spatial position of one or all sounds in group.\n    var ids = self._getSoundIds(id);\n    for (var i=0; i<ids.length; i++) {\n      // Get the sound.\n      var sound = self._soundById(ids[i]);\n\n      if (sound) {\n        if (typeof x === 'number') {\n          sound._pos = [x, y, z];\n\n          if (sound._node) {\n            // Check if there is a panner setup and create a new one if not.\n            if (!sound._panner || sound._panner.pan) {\n              setupPanner(sound, 'spatial');\n            }\n\n            if (typeof sound._panner.positionX !== 'undefined') {\n              sound._panner.positionX.setValueAtTime(x, Howler.ctx.currentTime);\n              sound._panner.positionY.setValueAtTime(y, Howler.ctx.currentTime);\n              sound._panner.positionZ.setValueAtTime(z, Howler.ctx.currentTime);\n            } else {\n              sound._panner.setPosition(x, y, z);\n            }\n          }\n\n          self._emit('pos', sound._id);\n        } else {\n          return sound._pos;\n        }\n      }\n    }\n\n    return self;\n  };\n\n  /**\n   * Get/set the direction the audio source is pointing in the 3D cartesian coordinate\n   * space. Depending on how direction the sound is, based on the `cone` attributes,\n   * a sound pointing away from the listener can be quiet or silent.\n   * @param  {Number} x  The x-orientation of the source.\n   * @param  {Number} y  The y-orientation of the source.\n   * @param  {Number} z  The z-orientation of the source.\n   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.\n   * @return {Howl/Array}    Returns self or the current 3D spatial orientation: [x, y, z].\n   */\n  Howl.prototype.orientation = function(x, y, z, id) {\n    var self = this;\n\n    // Stop right here if not using Web Audio.\n    if (!self._webAudio) {\n      return self;\n    }\n\n    // If the sound hasn't loaded, add it to the load queue to change orientation when capable.\n    if (self._state !== 'loaded') {\n      self._queue.push({\n        event: 'orientation',\n        action: function() {\n          self.orientation(x, y, z, id);\n        }\n      });\n\n      return self;\n    }\n\n    // Set the defaults for optional 'y' & 'z'.\n    y = (typeof y !== 'number') ? self._orientation[1] : y;\n    z = (typeof z !== 'number') ? self._orientation[2] : z;\n\n    // Setup the group's spatial orientation if no ID is passed.\n    if (typeof id === 'undefined') {\n      // Return the group's spatial orientation if no parameters are passed.\n      if (typeof x === 'number') {\n        self._orientation = [x, y, z];\n      } else {\n        return self._orientation;\n      }\n    }\n\n    // Change the spatial orientation of one or all sounds in group.\n    var ids = self._getSoundIds(id);\n    for (var i=0; i<ids.length; i++) {\n      // Get the sound.\n      var sound = self._soundById(ids[i]);\n\n      if (sound) {\n        if (typeof x === 'number') {\n          sound._orientation = [x, y, z];\n\n          if (sound._node) {\n            // Check if there is a panner setup and create a new one if not.\n            if (!sound._panner) {\n              // Make sure we have a position to setup the node with.\n              if (!sound._pos) {\n                sound._pos = self._pos || [0, 0, -0.5];\n              }\n\n              setupPanner(sound, 'spatial');\n            }\n\n            if (typeof sound._panner.orientationX !== 'undefined') {\n              sound._panner.orientationX.setValueAtTime(x, Howler.ctx.currentTime);\n              sound._panner.orientationY.setValueAtTime(y, Howler.ctx.currentTime);\n              sound._panner.orientationZ.setValueAtTime(z, Howler.ctx.currentTime);\n            } else {\n              sound._panner.setOrientation(x, y, z);\n            }\n          }\n\n          self._emit('orientation', sound._id);\n        } else {\n          return sound._orientation;\n        }\n      }\n    }\n\n    return self;\n  };\n\n  /**\n   * Get/set the panner node's attributes for a sound or group of sounds.\n   * This method can optionall take 0, 1 or 2 arguments.\n   *   pannerAttr() -> Returns the group's values.\n   *   pannerAttr(id) -> Returns the sound id's values.\n   *   pannerAttr(o) -> Set's the values of all sounds in this Howl group.\n   *   pannerAttr(o, id) -> Set's the values of passed sound id.\n   *\n   *   Attributes:\n   *     coneInnerAngle - (360 by default) A parameter for directional audio sources, this is an angle, in degrees,\n   *                      inside of which there will be no volume reduction.\n   *     coneOuterAngle - (360 by default) A parameter for directional audio sources, this is an angle, in degrees,\n   *                      outside of which the volume will be reduced to a constant value of `coneOuterGain`.\n   *     coneOuterGain - (0 by default) A parameter for directional audio sources, this is the gain outside of the\n   *                     `coneOuterAngle`. It is a linear value in the range `[0, 1]`.\n   *     distanceModel - ('inverse' by default) Determines algorithm used to reduce volume as audio moves away from\n   *                     listener. Can be `linear`, `inverse` or `exponential.\n   *     maxDistance - (10000 by default) The maximum distance between source and listener, after which the volume\n   *                   will not be reduced any further.\n   *     refDistance - (1 by default) A reference distance for reducing volume as source moves further from the listener.\n   *                   This is simply a variable of the distance model and has a different effect depending on which model\n   *                   is used and the scale of your coordinates. Generally, volume will be equal to 1 at this distance.\n   *     rolloffFactor - (1 by default) How quickly the volume reduces as source moves from listener. This is simply a\n   *                     variable of the distance model and can be in the range of `[0, 1]` with `linear` and `[0, ]`\n   *                     with `inverse` and `exponential`.\n   *     panningModel - ('HRTF' by default) Determines which spatialization algorithm is used to position audio.\n   *                     Can be `HRTF` or `equalpower`.\n   *\n   * @return {Howl/Object} Returns self or current panner attributes.\n   */\n  Howl.prototype.pannerAttr = function() {\n    var self = this;\n    var args = arguments;\n    var o, id, sound;\n\n    // Stop right here if not using Web Audio.\n    if (!self._webAudio) {\n      return self;\n    }\n\n    // Determine the values based on arguments.\n    if (args.length === 0) {\n      // Return the group's panner attribute values.\n      return self._pannerAttr;\n    } else if (args.length === 1) {\n      if (typeof args[0] === 'object') {\n        o = args[0];\n\n        // Set the grou's panner attribute values.\n        if (typeof id === 'undefined') {\n          if (!o.pannerAttr) {\n            o.pannerAttr = {\n              coneInnerAngle: o.coneInnerAngle,\n              coneOuterAngle: o.coneOuterAngle,\n              coneOuterGain: o.coneOuterGain,\n              distanceModel: o.distanceModel,\n              maxDistance: o.maxDistance,\n              refDistance: o.refDistance,\n              rolloffFactor: o.rolloffFactor,\n              panningModel: o.panningModel\n            };\n          }\n\n          self._pannerAttr = {\n            coneInnerAngle: typeof o.pannerAttr.coneInnerAngle !== 'undefined' ? o.pannerAttr.coneInnerAngle : self._coneInnerAngle,\n            coneOuterAngle: typeof o.pannerAttr.coneOuterAngle !== 'undefined' ? o.pannerAttr.coneOuterAngle : self._coneOuterAngle,\n            coneOuterGain: typeof o.pannerAttr.coneOuterGain !== 'undefined' ? o.pannerAttr.coneOuterGain : self._coneOuterGain,\n            distanceModel: typeof o.pannerAttr.distanceModel !== 'undefined' ? o.pannerAttr.distanceModel : self._distanceModel,\n            maxDistance: typeof o.pannerAttr.maxDistance !== 'undefined' ? o.pannerAttr.maxDistance : self._maxDistance,\n            refDistance: typeof o.pannerAttr.refDistance !== 'undefined' ? o.pannerAttr.refDistance : self._refDistance,\n            rolloffFactor: typeof o.pannerAttr.rolloffFactor !== 'undefined' ? o.pannerAttr.rolloffFactor : self._rolloffFactor,\n            panningModel: typeof o.pannerAttr.panningModel !== 'undefined' ? o.pannerAttr.panningModel : self._panningModel\n          };\n        }\n      } else {\n        // Return this sound's panner attribute values.\n        sound = self._soundById(parseInt(args[0], 10));\n        return sound ? sound._pannerAttr : self._pannerAttr;\n      }\n    } else if (args.length === 2) {\n      o = args[0];\n      id = parseInt(args[1], 10);\n    }\n\n    // Update the values of the specified sounds.\n    var ids = self._getSoundIds(id);\n    for (var i=0; i<ids.length; i++) {\n      sound = self._soundById(ids[i]);\n\n      if (sound) {\n        // Merge the new values into the sound.\n        var pa = sound._pannerAttr;\n        pa = {\n          coneInnerAngle: typeof o.coneInnerAngle !== 'undefined' ? o.coneInnerAngle : pa.coneInnerAngle,\n          coneOuterAngle: typeof o.coneOuterAngle !== 'undefined' ? o.coneOuterAngle : pa.coneOuterAngle,\n          coneOuterGain: typeof o.coneOuterGain !== 'undefined' ? o.coneOuterGain : pa.coneOuterGain,\n          distanceModel: typeof o.distanceModel !== 'undefined' ? o.distanceModel : pa.distanceModel,\n          maxDistance: typeof o.maxDistance !== 'undefined' ? o.maxDistance : pa.maxDistance,\n          refDistance: typeof o.refDistance !== 'undefined' ? o.refDistance : pa.refDistance,\n          rolloffFactor: typeof o.rolloffFactor !== 'undefined' ? o.rolloffFactor : pa.rolloffFactor,\n          panningModel: typeof o.panningModel !== 'undefined' ? o.panningModel : pa.panningModel\n        };\n\n        // Create a new panner node if one doesn't already exist.\n        var panner = sound._panner;\n        if (!panner) {\n          // Make sure we have a position to setup the node with.\n          if (!sound._pos) {\n            sound._pos = self._pos || [0, 0, -0.5];\n          }\n\n          // Create a new panner node.\n          setupPanner(sound, 'spatial');\n          panner = sound._panner\n        }\n\n        // Update the panner values or create a new panner if none exists.\n        panner.coneInnerAngle = pa.coneInnerAngle;\n        panner.coneOuterAngle = pa.coneOuterAngle;\n        panner.coneOuterGain = pa.coneOuterGain;\n        panner.distanceModel = pa.distanceModel;\n        panner.maxDistance = pa.maxDistance;\n        panner.refDistance = pa.refDistance;\n        panner.rolloffFactor = pa.rolloffFactor;\n        panner.panningModel = pa.panningModel;\n      }\n    }\n\n    return self;\n  };\n\n  /** Single Sound Methods **/\n  /***************************************************************************/\n\n  /**\n   * Add new properties to the core Sound init.\n   * @param  {Function} _super Core Sound init method.\n   * @return {Sound}\n   */\n  Sound.prototype.init = (function(_super) {\n    return function() {\n      var self = this;\n      var parent = self._parent;\n\n      // Setup user-defined default properties.\n      self._orientation = parent._orientation;\n      self._stereo = parent._stereo;\n      self._pos = parent._pos;\n      self._pannerAttr = parent._pannerAttr;\n\n      // Complete initilization with howler.js core Sound's init function.\n      _super.call(this);\n\n      // If a stereo or position was specified, set it up.\n      if (self._stereo) {\n        parent.stereo(self._stereo);\n      } else if (self._pos) {\n        parent.pos(self._pos[0], self._pos[1], self._pos[2], self._id);\n      }\n    };\n  })(Sound.prototype.init);\n\n  /**\n   * Override the Sound.reset method to clean up properties from the spatial plugin.\n   * @param  {Function} _super Sound reset method.\n   * @return {Sound}\n   */\n  Sound.prototype.reset = (function(_super) {\n    return function() {\n      var self = this;\n      var parent = self._parent;\n\n      // Reset all spatial plugin properties on this sound.\n      self._orientation = parent._orientation;\n      self._stereo = parent._stereo;\n      self._pos = parent._pos;\n      self._pannerAttr = parent._pannerAttr;\n\n      // If a stereo or position was specified, set it up.\n      if (self._stereo) {\n        parent.stereo(self._stereo);\n      } else if (self._pos) {\n        parent.pos(self._pos[0], self._pos[1], self._pos[2], self._id);\n      } else if (self._panner) {\n        // Disconnect the panner.\n        self._panner.disconnect(0);\n        self._panner = undefined;\n        parent._refreshBuffer(self);\n      }\n\n      // Complete resetting of the sound.\n      return _super.call(this);\n    };\n  })(Sound.prototype.reset);\n\n  /** Helper Methods **/\n  /***************************************************************************/\n\n  /**\n   * Create a new panner node and save it on the sound.\n   * @param  {Sound} sound Specific sound to setup panning on.\n   * @param {String} type Type of panner to create: 'stereo' or 'spatial'.\n   */\n  var setupPanner = function(sound, type) {\n    type = type || 'spatial';\n\n    // Create the new panner node.\n    if (type === 'spatial') {\n      sound._panner = Howler.ctx.createPanner();\n      sound._panner.coneInnerAngle = sound._pannerAttr.coneInnerAngle;\n      sound._panner.coneOuterAngle = sound._pannerAttr.coneOuterAngle;\n      sound._panner.coneOuterGain = sound._pannerAttr.coneOuterGain;\n      sound._panner.distanceModel = sound._pannerAttr.distanceModel;\n      sound._panner.maxDistance = sound._pannerAttr.maxDistance;\n      sound._panner.refDistance = sound._pannerAttr.refDistance;\n      sound._panner.rolloffFactor = sound._pannerAttr.rolloffFactor;\n      sound._panner.panningModel = sound._pannerAttr.panningModel;\n\n      if (typeof sound._panner.positionX !== 'undefined') {\n        sound._panner.positionX.setValueAtTime(sound._pos[0], Howler.ctx.currentTime);\n        sound._panner.positionY.setValueAtTime(sound._pos[1], Howler.ctx.currentTime);\n        sound._panner.positionZ.setValueAtTime(sound._pos[2], Howler.ctx.currentTime);\n      } else {\n        sound._panner.setPosition(sound._pos[0], sound._pos[1], sound._pos[2]);\n      }\n\n      if (typeof sound._panner.orientationX !== 'undefined') {\n        sound._panner.orientationX.setValueAtTime(sound._orientation[0], Howler.ctx.currentTime);\n        sound._panner.orientationY.setValueAtTime(sound._orientation[1], Howler.ctx.currentTime);\n        sound._panner.orientationZ.setValueAtTime(sound._orientation[2], Howler.ctx.currentTime);\n      } else {\n        sound._panner.setOrientation(sound._orientation[0], sound._orientation[1], sound._orientation[2]);\n      }\n    } else {\n      sound._panner = Howler.ctx.createStereoPanner();\n      sound._panner.pan.setValueAtTime(sound._stereo, Howler.ctx.currentTime);\n    }\n\n    sound._panner.connect(sound._node);\n\n    // Update the connections.\n    if (!sound._paused) {\n      sound._parent.pause(sound._id, true).play(sound._id, true);\n    }\n  };\n})();\n\n\n//# sourceURL=webpack://cny2026/./node_modules/howler/dist/howler.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/main.js");
/******/ 	
/******/ })()
;